
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Alert
 * 
 */
export type Alert = $Result.DefaultSelection<Prisma.$AlertPayload>
/**
 * Model TelegramIntegration
 * 
 */
export type TelegramIntegration = $Result.DefaultSelection<Prisma.$TelegramIntegrationPayload>
/**
 * Model MonitoredWallet
 * 
 */
export type MonitoredWallet = $Result.DefaultSelection<Prisma.$MonitoredWalletPayload>
/**
 * Model PolymarketActivity
 * 
 */
export type PolymarketActivity = $Result.DefaultSelection<Prisma.$PolymarketActivityPayload>
/**
 * Model MonitoringJobLog
 * 
 */
export type MonitoringJobLog = $Result.DefaultSelection<Prisma.$MonitoringJobLogPayload>
/**
 * Model NotificationQueue
 * 
 */
export type NotificationQueue = $Result.DefaultSelection<Prisma.$NotificationQueuePayload>
/**
 * Model NotificationLog
 * 
 */
export type NotificationLog = $Result.DefaultSelection<Prisma.$NotificationLogPayload>
/**
 * Model CronJobLog
 * 
 */
export type CronJobLog = $Result.DefaultSelection<Prisma.$CronJobLogPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model RulesConversation
 * 
 */
export type RulesConversation = $Result.DefaultSelection<Prisma.$RulesConversationPayload>
/**
 * Model RulesMessage
 * 
 */
export type RulesMessage = $Result.DefaultSelection<Prisma.$RulesMessagePayload>
/**
 * Model WatchList
 * 
 */
export type WatchList = $Result.DefaultSelection<Prisma.$WatchListPayload>
/**
 * Model Market
 * 
 */
export type Market = $Result.DefaultSelection<Prisma.$MarketPayload>
/**
 * Model ProxyWallet
 * 
 */
export type ProxyWallet = $Result.DefaultSelection<Prisma.$ProxyWalletPayload>
/**
 * Model SyncHistory
 * 
 */
export type SyncHistory = $Result.DefaultSelection<Prisma.$SyncHistoryPayload>
/**
 * Model UserAnalytics
 * 
 */
export type UserAnalytics = $Result.DefaultSelection<Prisma.$UserAnalyticsPayload>
/**
 * Model MarketDistribution
 * 
 */
export type MarketDistribution = $Result.DefaultSelection<Prisma.$MarketDistributionPayload>
/**
 * Model BuySellData
 * 
 */
export type BuySellData = $Result.DefaultSelection<Prisma.$BuySellDataPayload>
/**
 * Model TradeSizeData
 * 
 */
export type TradeSizeData = $Result.DefaultSelection<Prisma.$TradeSizeDataPayload>
/**
 * Model PriceStats
 * 
 */
export type PriceStats = $Result.DefaultSelection<Prisma.$PriceStatsPayload>
/**
 * Model MonthlyPerformance
 * 
 */
export type MonthlyPerformance = $Result.DefaultSelection<Prisma.$MonthlyPerformancePayload>
/**
 * Model WeeklyWinRate
 * 
 */
export type WeeklyWinRate = $Result.DefaultSelection<Prisma.$WeeklyWinRatePayload>
/**
 * Model BlogPost
 * 
 */
export type BlogPost = $Result.DefaultSelection<Prisma.$BlogPostPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const NotificationStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  SENT: 'SENT',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]


export const SyncStatus: {
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type SyncStatus = (typeof SyncStatus)[keyof typeof SyncStatus]

}

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

export type SyncStatus = $Enums.SyncStatus

export const SyncStatus: typeof $Enums.SyncStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.telegramIntegration`: Exposes CRUD operations for the **TelegramIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TelegramIntegrations
    * const telegramIntegrations = await prisma.telegramIntegration.findMany()
    * ```
    */
  get telegramIntegration(): Prisma.TelegramIntegrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.monitoredWallet`: Exposes CRUD operations for the **MonitoredWallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MonitoredWallets
    * const monitoredWallets = await prisma.monitoredWallet.findMany()
    * ```
    */
  get monitoredWallet(): Prisma.MonitoredWalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.polymarketActivity`: Exposes CRUD operations for the **PolymarketActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PolymarketActivities
    * const polymarketActivities = await prisma.polymarketActivity.findMany()
    * ```
    */
  get polymarketActivity(): Prisma.PolymarketActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.monitoringJobLog`: Exposes CRUD operations for the **MonitoringJobLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MonitoringJobLogs
    * const monitoringJobLogs = await prisma.monitoringJobLog.findMany()
    * ```
    */
  get monitoringJobLog(): Prisma.MonitoringJobLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationQueue`: Exposes CRUD operations for the **NotificationQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationQueues
    * const notificationQueues = await prisma.notificationQueue.findMany()
    * ```
    */
  get notificationQueue(): Prisma.NotificationQueueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationLog`: Exposes CRUD operations for the **NotificationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationLogs
    * const notificationLogs = await prisma.notificationLog.findMany()
    * ```
    */
  get notificationLog(): Prisma.NotificationLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cronJobLog`: Exposes CRUD operations for the **CronJobLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CronJobLogs
    * const cronJobLogs = await prisma.cronJobLog.findMany()
    * ```
    */
  get cronJobLog(): Prisma.CronJobLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rulesConversation`: Exposes CRUD operations for the **RulesConversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RulesConversations
    * const rulesConversations = await prisma.rulesConversation.findMany()
    * ```
    */
  get rulesConversation(): Prisma.RulesConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rulesMessage`: Exposes CRUD operations for the **RulesMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RulesMessages
    * const rulesMessages = await prisma.rulesMessage.findMany()
    * ```
    */
  get rulesMessage(): Prisma.RulesMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.watchList`: Exposes CRUD operations for the **WatchList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WatchLists
    * const watchLists = await prisma.watchList.findMany()
    * ```
    */
  get watchList(): Prisma.WatchListDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.market`: Exposes CRUD operations for the **Market** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Markets
    * const markets = await prisma.market.findMany()
    * ```
    */
  get market(): Prisma.MarketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proxyWallet`: Exposes CRUD operations for the **ProxyWallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProxyWallets
    * const proxyWallets = await prisma.proxyWallet.findMany()
    * ```
    */
  get proxyWallet(): Prisma.ProxyWalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syncHistory`: Exposes CRUD operations for the **SyncHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncHistories
    * const syncHistories = await prisma.syncHistory.findMany()
    * ```
    */
  get syncHistory(): Prisma.SyncHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAnalytics`: Exposes CRUD operations for the **UserAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAnalytics
    * const userAnalytics = await prisma.userAnalytics.findMany()
    * ```
    */
  get userAnalytics(): Prisma.UserAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketDistribution`: Exposes CRUD operations for the **MarketDistribution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketDistributions
    * const marketDistributions = await prisma.marketDistribution.findMany()
    * ```
    */
  get marketDistribution(): Prisma.MarketDistributionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.buySellData`: Exposes CRUD operations for the **BuySellData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuySellData
    * const buySellData = await prisma.buySellData.findMany()
    * ```
    */
  get buySellData(): Prisma.BuySellDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tradeSizeData`: Exposes CRUD operations for the **TradeSizeData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TradeSizeData
    * const tradeSizeData = await prisma.tradeSizeData.findMany()
    * ```
    */
  get tradeSizeData(): Prisma.TradeSizeDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.priceStats`: Exposes CRUD operations for the **PriceStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceStats
    * const priceStats = await prisma.priceStats.findMany()
    * ```
    */
  get priceStats(): Prisma.PriceStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.monthlyPerformance`: Exposes CRUD operations for the **MonthlyPerformance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MonthlyPerformances
    * const monthlyPerformances = await prisma.monthlyPerformance.findMany()
    * ```
    */
  get monthlyPerformance(): Prisma.MonthlyPerformanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weeklyWinRate`: Exposes CRUD operations for the **WeeklyWinRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeeklyWinRates
    * const weeklyWinRates = await prisma.weeklyWinRate.findMany()
    * ```
    */
  get weeklyWinRate(): Prisma.WeeklyWinRateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogPost`: Exposes CRUD operations for the **BlogPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPosts
    * const blogPosts = await prisma.blogPost.findMany()
    * ```
    */
  get blogPost(): Prisma.BlogPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    Verification: 'Verification',
    Alert: 'Alert',
    TelegramIntegration: 'TelegramIntegration',
    MonitoredWallet: 'MonitoredWallet',
    PolymarketActivity: 'PolymarketActivity',
    MonitoringJobLog: 'MonitoringJobLog',
    NotificationQueue: 'NotificationQueue',
    NotificationLog: 'NotificationLog',
    CronJobLog: 'CronJobLog',
    Conversation: 'Conversation',
    Message: 'Message',
    RulesConversation: 'RulesConversation',
    RulesMessage: 'RulesMessage',
    WatchList: 'WatchList',
    Market: 'Market',
    ProxyWallet: 'ProxyWallet',
    SyncHistory: 'SyncHistory',
    UserAnalytics: 'UserAnalytics',
    MarketDistribution: 'MarketDistribution',
    BuySellData: 'BuySellData',
    TradeSizeData: 'TradeSizeData',
    PriceStats: 'PriceStats',
    MonthlyPerformance: 'MonthlyPerformance',
    WeeklyWinRate: 'WeeklyWinRate',
    BlogPost: 'BlogPost',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "session" | "verification" | "alert" | "telegramIntegration" | "monitoredWallet" | "polymarketActivity" | "monitoringJobLog" | "notificationQueue" | "notificationLog" | "cronJobLog" | "conversation" | "message" | "rulesConversation" | "rulesMessage" | "watchList" | "market" | "proxyWallet" | "syncHistory" | "userAnalytics" | "marketDistribution" | "buySellData" | "tradeSizeData" | "priceStats" | "monthlyPerformance" | "weeklyWinRate" | "blogPost" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Alert: {
        payload: Prisma.$AlertPayload<ExtArgs>
        fields: Prisma.AlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findFirst: {
            args: Prisma.AlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findMany: {
            args: Prisma.AlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          create: {
            args: Prisma.AlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          createMany: {
            args: Prisma.AlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          delete: {
            args: Prisma.AlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          update: {
            args: Prisma.AlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          upsert: {
            args: Prisma.AlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.AlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertCountArgs<ExtArgs>
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
      TelegramIntegration: {
        payload: Prisma.$TelegramIntegrationPayload<ExtArgs>
        fields: Prisma.TelegramIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TelegramIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TelegramIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramIntegrationPayload>
          }
          findFirst: {
            args: Prisma.TelegramIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TelegramIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramIntegrationPayload>
          }
          findMany: {
            args: Prisma.TelegramIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramIntegrationPayload>[]
          }
          create: {
            args: Prisma.TelegramIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramIntegrationPayload>
          }
          createMany: {
            args: Prisma.TelegramIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TelegramIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramIntegrationPayload>[]
          }
          delete: {
            args: Prisma.TelegramIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramIntegrationPayload>
          }
          update: {
            args: Prisma.TelegramIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.TelegramIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TelegramIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TelegramIntegrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramIntegrationPayload>[]
          }
          upsert: {
            args: Prisma.TelegramIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramIntegrationPayload>
          }
          aggregate: {
            args: Prisma.TelegramIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTelegramIntegration>
          }
          groupBy: {
            args: Prisma.TelegramIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TelegramIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TelegramIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<TelegramIntegrationCountAggregateOutputType> | number
          }
        }
      }
      MonitoredWallet: {
        payload: Prisma.$MonitoredWalletPayload<ExtArgs>
        fields: Prisma.MonitoredWalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MonitoredWalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredWalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MonitoredWalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredWalletPayload>
          }
          findFirst: {
            args: Prisma.MonitoredWalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredWalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MonitoredWalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredWalletPayload>
          }
          findMany: {
            args: Prisma.MonitoredWalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredWalletPayload>[]
          }
          create: {
            args: Prisma.MonitoredWalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredWalletPayload>
          }
          createMany: {
            args: Prisma.MonitoredWalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MonitoredWalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredWalletPayload>[]
          }
          delete: {
            args: Prisma.MonitoredWalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredWalletPayload>
          }
          update: {
            args: Prisma.MonitoredWalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredWalletPayload>
          }
          deleteMany: {
            args: Prisma.MonitoredWalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MonitoredWalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MonitoredWalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredWalletPayload>[]
          }
          upsert: {
            args: Prisma.MonitoredWalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredWalletPayload>
          }
          aggregate: {
            args: Prisma.MonitoredWalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonitoredWallet>
          }
          groupBy: {
            args: Prisma.MonitoredWalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonitoredWalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.MonitoredWalletCountArgs<ExtArgs>
            result: $Utils.Optional<MonitoredWalletCountAggregateOutputType> | number
          }
        }
      }
      PolymarketActivity: {
        payload: Prisma.$PolymarketActivityPayload<ExtArgs>
        fields: Prisma.PolymarketActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PolymarketActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolymarketActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PolymarketActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolymarketActivityPayload>
          }
          findFirst: {
            args: Prisma.PolymarketActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolymarketActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PolymarketActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolymarketActivityPayload>
          }
          findMany: {
            args: Prisma.PolymarketActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolymarketActivityPayload>[]
          }
          create: {
            args: Prisma.PolymarketActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolymarketActivityPayload>
          }
          createMany: {
            args: Prisma.PolymarketActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PolymarketActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolymarketActivityPayload>[]
          }
          delete: {
            args: Prisma.PolymarketActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolymarketActivityPayload>
          }
          update: {
            args: Prisma.PolymarketActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolymarketActivityPayload>
          }
          deleteMany: {
            args: Prisma.PolymarketActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PolymarketActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PolymarketActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolymarketActivityPayload>[]
          }
          upsert: {
            args: Prisma.PolymarketActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolymarketActivityPayload>
          }
          aggregate: {
            args: Prisma.PolymarketActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePolymarketActivity>
          }
          groupBy: {
            args: Prisma.PolymarketActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<PolymarketActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.PolymarketActivityCountArgs<ExtArgs>
            result: $Utils.Optional<PolymarketActivityCountAggregateOutputType> | number
          }
        }
      }
      MonitoringJobLog: {
        payload: Prisma.$MonitoringJobLogPayload<ExtArgs>
        fields: Prisma.MonitoringJobLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MonitoringJobLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoringJobLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MonitoringJobLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoringJobLogPayload>
          }
          findFirst: {
            args: Prisma.MonitoringJobLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoringJobLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MonitoringJobLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoringJobLogPayload>
          }
          findMany: {
            args: Prisma.MonitoringJobLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoringJobLogPayload>[]
          }
          create: {
            args: Prisma.MonitoringJobLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoringJobLogPayload>
          }
          createMany: {
            args: Prisma.MonitoringJobLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MonitoringJobLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoringJobLogPayload>[]
          }
          delete: {
            args: Prisma.MonitoringJobLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoringJobLogPayload>
          }
          update: {
            args: Prisma.MonitoringJobLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoringJobLogPayload>
          }
          deleteMany: {
            args: Prisma.MonitoringJobLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MonitoringJobLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MonitoringJobLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoringJobLogPayload>[]
          }
          upsert: {
            args: Prisma.MonitoringJobLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoringJobLogPayload>
          }
          aggregate: {
            args: Prisma.MonitoringJobLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonitoringJobLog>
          }
          groupBy: {
            args: Prisma.MonitoringJobLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonitoringJobLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.MonitoringJobLogCountArgs<ExtArgs>
            result: $Utils.Optional<MonitoringJobLogCountAggregateOutputType> | number
          }
        }
      }
      NotificationQueue: {
        payload: Prisma.$NotificationQueuePayload<ExtArgs>
        fields: Prisma.NotificationQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>
          }
          findFirst: {
            args: Prisma.NotificationQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>
          }
          findMany: {
            args: Prisma.NotificationQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>[]
          }
          create: {
            args: Prisma.NotificationQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>
          }
          createMany: {
            args: Prisma.NotificationQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>[]
          }
          delete: {
            args: Prisma.NotificationQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>
          }
          update: {
            args: Prisma.NotificationQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>
          }
          deleteMany: {
            args: Prisma.NotificationQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationQueueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>[]
          }
          upsert: {
            args: Prisma.NotificationQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>
          }
          aggregate: {
            args: Prisma.NotificationQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationQueue>
          }
          groupBy: {
            args: Prisma.NotificationQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationQueueCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationQueueCountAggregateOutputType> | number
          }
        }
      }
      NotificationLog: {
        payload: Prisma.$NotificationLogPayload<ExtArgs>
        fields: Prisma.NotificationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findFirst: {
            args: Prisma.NotificationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findMany: {
            args: Prisma.NotificationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          create: {
            args: Prisma.NotificationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          createMany: {
            args: Prisma.NotificationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          delete: {
            args: Prisma.NotificationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          update: {
            args: Prisma.NotificationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          deleteMany: {
            args: Prisma.NotificationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          upsert: {
            args: Prisma.NotificationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          aggregate: {
            args: Prisma.NotificationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationLog>
          }
          groupBy: {
            args: Prisma.NotificationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationLogCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogCountAggregateOutputType> | number
          }
        }
      }
      CronJobLog: {
        payload: Prisma.$CronJobLogPayload<ExtArgs>
        fields: Prisma.CronJobLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CronJobLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CronJobLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobLogPayload>
          }
          findFirst: {
            args: Prisma.CronJobLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CronJobLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobLogPayload>
          }
          findMany: {
            args: Prisma.CronJobLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobLogPayload>[]
          }
          create: {
            args: Prisma.CronJobLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobLogPayload>
          }
          createMany: {
            args: Prisma.CronJobLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CronJobLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobLogPayload>[]
          }
          delete: {
            args: Prisma.CronJobLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobLogPayload>
          }
          update: {
            args: Prisma.CronJobLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobLogPayload>
          }
          deleteMany: {
            args: Prisma.CronJobLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CronJobLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CronJobLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobLogPayload>[]
          }
          upsert: {
            args: Prisma.CronJobLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronJobLogPayload>
          }
          aggregate: {
            args: Prisma.CronJobLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCronJobLog>
          }
          groupBy: {
            args: Prisma.CronJobLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CronJobLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CronJobLogCountArgs<ExtArgs>
            result: $Utils.Optional<CronJobLogCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      RulesConversation: {
        payload: Prisma.$RulesConversationPayload<ExtArgs>
        fields: Prisma.RulesConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RulesConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RulesConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesConversationPayload>
          }
          findFirst: {
            args: Prisma.RulesConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RulesConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesConversationPayload>
          }
          findMany: {
            args: Prisma.RulesConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesConversationPayload>[]
          }
          create: {
            args: Prisma.RulesConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesConversationPayload>
          }
          createMany: {
            args: Prisma.RulesConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RulesConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesConversationPayload>[]
          }
          delete: {
            args: Prisma.RulesConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesConversationPayload>
          }
          update: {
            args: Prisma.RulesConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesConversationPayload>
          }
          deleteMany: {
            args: Prisma.RulesConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RulesConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RulesConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesConversationPayload>[]
          }
          upsert: {
            args: Prisma.RulesConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesConversationPayload>
          }
          aggregate: {
            args: Prisma.RulesConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRulesConversation>
          }
          groupBy: {
            args: Prisma.RulesConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<RulesConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.RulesConversationCountArgs<ExtArgs>
            result: $Utils.Optional<RulesConversationCountAggregateOutputType> | number
          }
        }
      }
      RulesMessage: {
        payload: Prisma.$RulesMessagePayload<ExtArgs>
        fields: Prisma.RulesMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RulesMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RulesMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesMessagePayload>
          }
          findFirst: {
            args: Prisma.RulesMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RulesMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesMessagePayload>
          }
          findMany: {
            args: Prisma.RulesMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesMessagePayload>[]
          }
          create: {
            args: Prisma.RulesMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesMessagePayload>
          }
          createMany: {
            args: Prisma.RulesMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RulesMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesMessagePayload>[]
          }
          delete: {
            args: Prisma.RulesMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesMessagePayload>
          }
          update: {
            args: Prisma.RulesMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesMessagePayload>
          }
          deleteMany: {
            args: Prisma.RulesMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RulesMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RulesMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesMessagePayload>[]
          }
          upsert: {
            args: Prisma.RulesMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulesMessagePayload>
          }
          aggregate: {
            args: Prisma.RulesMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRulesMessage>
          }
          groupBy: {
            args: Prisma.RulesMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<RulesMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.RulesMessageCountArgs<ExtArgs>
            result: $Utils.Optional<RulesMessageCountAggregateOutputType> | number
          }
        }
      }
      WatchList: {
        payload: Prisma.$WatchListPayload<ExtArgs>
        fields: Prisma.WatchListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WatchListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WatchListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchListPayload>
          }
          findFirst: {
            args: Prisma.WatchListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WatchListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchListPayload>
          }
          findMany: {
            args: Prisma.WatchListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchListPayload>[]
          }
          create: {
            args: Prisma.WatchListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchListPayload>
          }
          createMany: {
            args: Prisma.WatchListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WatchListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchListPayload>[]
          }
          delete: {
            args: Prisma.WatchListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchListPayload>
          }
          update: {
            args: Prisma.WatchListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchListPayload>
          }
          deleteMany: {
            args: Prisma.WatchListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WatchListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WatchListUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchListPayload>[]
          }
          upsert: {
            args: Prisma.WatchListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchListPayload>
          }
          aggregate: {
            args: Prisma.WatchListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWatchList>
          }
          groupBy: {
            args: Prisma.WatchListGroupByArgs<ExtArgs>
            result: $Utils.Optional<WatchListGroupByOutputType>[]
          }
          count: {
            args: Prisma.WatchListCountArgs<ExtArgs>
            result: $Utils.Optional<WatchListCountAggregateOutputType> | number
          }
        }
      }
      Market: {
        payload: Prisma.$MarketPayload<ExtArgs>
        fields: Prisma.MarketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketPayload>
          }
          findFirst: {
            args: Prisma.MarketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketPayload>
          }
          findMany: {
            args: Prisma.MarketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketPayload>[]
          }
          create: {
            args: Prisma.MarketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketPayload>
          }
          createMany: {
            args: Prisma.MarketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketPayload>[]
          }
          delete: {
            args: Prisma.MarketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketPayload>
          }
          update: {
            args: Prisma.MarketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketPayload>
          }
          deleteMany: {
            args: Prisma.MarketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MarketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketPayload>[]
          }
          upsert: {
            args: Prisma.MarketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketPayload>
          }
          aggregate: {
            args: Prisma.MarketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarket>
          }
          groupBy: {
            args: Prisma.MarketGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketCountArgs<ExtArgs>
            result: $Utils.Optional<MarketCountAggregateOutputType> | number
          }
        }
      }
      ProxyWallet: {
        payload: Prisma.$ProxyWalletPayload<ExtArgs>
        fields: Prisma.ProxyWalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProxyWalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyWalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProxyWalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyWalletPayload>
          }
          findFirst: {
            args: Prisma.ProxyWalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyWalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProxyWalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyWalletPayload>
          }
          findMany: {
            args: Prisma.ProxyWalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyWalletPayload>[]
          }
          create: {
            args: Prisma.ProxyWalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyWalletPayload>
          }
          createMany: {
            args: Prisma.ProxyWalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProxyWalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyWalletPayload>[]
          }
          delete: {
            args: Prisma.ProxyWalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyWalletPayload>
          }
          update: {
            args: Prisma.ProxyWalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyWalletPayload>
          }
          deleteMany: {
            args: Prisma.ProxyWalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProxyWalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProxyWalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyWalletPayload>[]
          }
          upsert: {
            args: Prisma.ProxyWalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyWalletPayload>
          }
          aggregate: {
            args: Prisma.ProxyWalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProxyWallet>
          }
          groupBy: {
            args: Prisma.ProxyWalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProxyWalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProxyWalletCountArgs<ExtArgs>
            result: $Utils.Optional<ProxyWalletCountAggregateOutputType> | number
          }
        }
      }
      SyncHistory: {
        payload: Prisma.$SyncHistoryPayload<ExtArgs>
        fields: Prisma.SyncHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>
          }
          findFirst: {
            args: Prisma.SyncHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>
          }
          findMany: {
            args: Prisma.SyncHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>[]
          }
          create: {
            args: Prisma.SyncHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>
          }
          createMany: {
            args: Prisma.SyncHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyncHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>[]
          }
          delete: {
            args: Prisma.SyncHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>
          }
          update: {
            args: Prisma.SyncHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>
          }
          deleteMany: {
            args: Prisma.SyncHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SyncHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>[]
          }
          upsert: {
            args: Prisma.SyncHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>
          }
          aggregate: {
            args: Prisma.SyncHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncHistory>
          }
          groupBy: {
            args: Prisma.SyncHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<SyncHistoryCountAggregateOutputType> | number
          }
        }
      }
      UserAnalytics: {
        payload: Prisma.$UserAnalyticsPayload<ExtArgs>
        fields: Prisma.UserAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.UserAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>
          }
          findMany: {
            args: Prisma.UserAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>[]
          }
          create: {
            args: Prisma.UserAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>
          }
          createMany: {
            args: Prisma.UserAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.UserAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>
          }
          update: {
            args: Prisma.UserAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.UserAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.UserAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.UserAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAnalytics>
          }
          groupBy: {
            args: Prisma.UserAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<UserAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      MarketDistribution: {
        payload: Prisma.$MarketDistributionPayload<ExtArgs>
        fields: Prisma.MarketDistributionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketDistributionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketDistributionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketDistributionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketDistributionPayload>
          }
          findFirst: {
            args: Prisma.MarketDistributionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketDistributionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketDistributionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketDistributionPayload>
          }
          findMany: {
            args: Prisma.MarketDistributionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketDistributionPayload>[]
          }
          create: {
            args: Prisma.MarketDistributionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketDistributionPayload>
          }
          createMany: {
            args: Prisma.MarketDistributionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketDistributionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketDistributionPayload>[]
          }
          delete: {
            args: Prisma.MarketDistributionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketDistributionPayload>
          }
          update: {
            args: Prisma.MarketDistributionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketDistributionPayload>
          }
          deleteMany: {
            args: Prisma.MarketDistributionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketDistributionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MarketDistributionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketDistributionPayload>[]
          }
          upsert: {
            args: Prisma.MarketDistributionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketDistributionPayload>
          }
          aggregate: {
            args: Prisma.MarketDistributionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketDistribution>
          }
          groupBy: {
            args: Prisma.MarketDistributionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketDistributionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketDistributionCountArgs<ExtArgs>
            result: $Utils.Optional<MarketDistributionCountAggregateOutputType> | number
          }
        }
      }
      BuySellData: {
        payload: Prisma.$BuySellDataPayload<ExtArgs>
        fields: Prisma.BuySellDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuySellDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuySellDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuySellDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuySellDataPayload>
          }
          findFirst: {
            args: Prisma.BuySellDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuySellDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuySellDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuySellDataPayload>
          }
          findMany: {
            args: Prisma.BuySellDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuySellDataPayload>[]
          }
          create: {
            args: Prisma.BuySellDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuySellDataPayload>
          }
          createMany: {
            args: Prisma.BuySellDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BuySellDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuySellDataPayload>[]
          }
          delete: {
            args: Prisma.BuySellDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuySellDataPayload>
          }
          update: {
            args: Prisma.BuySellDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuySellDataPayload>
          }
          deleteMany: {
            args: Prisma.BuySellDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuySellDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BuySellDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuySellDataPayload>[]
          }
          upsert: {
            args: Prisma.BuySellDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuySellDataPayload>
          }
          aggregate: {
            args: Prisma.BuySellDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuySellData>
          }
          groupBy: {
            args: Prisma.BuySellDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuySellDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuySellDataCountArgs<ExtArgs>
            result: $Utils.Optional<BuySellDataCountAggregateOutputType> | number
          }
        }
      }
      TradeSizeData: {
        payload: Prisma.$TradeSizeDataPayload<ExtArgs>
        fields: Prisma.TradeSizeDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TradeSizeDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeSizeDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TradeSizeDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeSizeDataPayload>
          }
          findFirst: {
            args: Prisma.TradeSizeDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeSizeDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TradeSizeDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeSizeDataPayload>
          }
          findMany: {
            args: Prisma.TradeSizeDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeSizeDataPayload>[]
          }
          create: {
            args: Prisma.TradeSizeDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeSizeDataPayload>
          }
          createMany: {
            args: Prisma.TradeSizeDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TradeSizeDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeSizeDataPayload>[]
          }
          delete: {
            args: Prisma.TradeSizeDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeSizeDataPayload>
          }
          update: {
            args: Prisma.TradeSizeDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeSizeDataPayload>
          }
          deleteMany: {
            args: Prisma.TradeSizeDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TradeSizeDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TradeSizeDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeSizeDataPayload>[]
          }
          upsert: {
            args: Prisma.TradeSizeDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeSizeDataPayload>
          }
          aggregate: {
            args: Prisma.TradeSizeDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTradeSizeData>
          }
          groupBy: {
            args: Prisma.TradeSizeDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<TradeSizeDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.TradeSizeDataCountArgs<ExtArgs>
            result: $Utils.Optional<TradeSizeDataCountAggregateOutputType> | number
          }
        }
      }
      PriceStats: {
        payload: Prisma.$PriceStatsPayload<ExtArgs>
        fields: Prisma.PriceStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceStatsPayload>
          }
          findFirst: {
            args: Prisma.PriceStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceStatsPayload>
          }
          findMany: {
            args: Prisma.PriceStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceStatsPayload>[]
          }
          create: {
            args: Prisma.PriceStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceStatsPayload>
          }
          createMany: {
            args: Prisma.PriceStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriceStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceStatsPayload>[]
          }
          delete: {
            args: Prisma.PriceStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceStatsPayload>
          }
          update: {
            args: Prisma.PriceStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceStatsPayload>
          }
          deleteMany: {
            args: Prisma.PriceStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PriceStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceStatsPayload>[]
          }
          upsert: {
            args: Prisma.PriceStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceStatsPayload>
          }
          aggregate: {
            args: Prisma.PriceStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceStats>
          }
          groupBy: {
            args: Prisma.PriceStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceStatsCountArgs<ExtArgs>
            result: $Utils.Optional<PriceStatsCountAggregateOutputType> | number
          }
        }
      }
      MonthlyPerformance: {
        payload: Prisma.$MonthlyPerformancePayload<ExtArgs>
        fields: Prisma.MonthlyPerformanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MonthlyPerformanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyPerformancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MonthlyPerformanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyPerformancePayload>
          }
          findFirst: {
            args: Prisma.MonthlyPerformanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyPerformancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MonthlyPerformanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyPerformancePayload>
          }
          findMany: {
            args: Prisma.MonthlyPerformanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyPerformancePayload>[]
          }
          create: {
            args: Prisma.MonthlyPerformanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyPerformancePayload>
          }
          createMany: {
            args: Prisma.MonthlyPerformanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MonthlyPerformanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyPerformancePayload>[]
          }
          delete: {
            args: Prisma.MonthlyPerformanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyPerformancePayload>
          }
          update: {
            args: Prisma.MonthlyPerformanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyPerformancePayload>
          }
          deleteMany: {
            args: Prisma.MonthlyPerformanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MonthlyPerformanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MonthlyPerformanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyPerformancePayload>[]
          }
          upsert: {
            args: Prisma.MonthlyPerformanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyPerformancePayload>
          }
          aggregate: {
            args: Prisma.MonthlyPerformanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonthlyPerformance>
          }
          groupBy: {
            args: Prisma.MonthlyPerformanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonthlyPerformanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.MonthlyPerformanceCountArgs<ExtArgs>
            result: $Utils.Optional<MonthlyPerformanceCountAggregateOutputType> | number
          }
        }
      }
      WeeklyWinRate: {
        payload: Prisma.$WeeklyWinRatePayload<ExtArgs>
        fields: Prisma.WeeklyWinRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeeklyWinRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyWinRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeeklyWinRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyWinRatePayload>
          }
          findFirst: {
            args: Prisma.WeeklyWinRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyWinRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeeklyWinRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyWinRatePayload>
          }
          findMany: {
            args: Prisma.WeeklyWinRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyWinRatePayload>[]
          }
          create: {
            args: Prisma.WeeklyWinRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyWinRatePayload>
          }
          createMany: {
            args: Prisma.WeeklyWinRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeeklyWinRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyWinRatePayload>[]
          }
          delete: {
            args: Prisma.WeeklyWinRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyWinRatePayload>
          }
          update: {
            args: Prisma.WeeklyWinRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyWinRatePayload>
          }
          deleteMany: {
            args: Prisma.WeeklyWinRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeeklyWinRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeeklyWinRateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyWinRatePayload>[]
          }
          upsert: {
            args: Prisma.WeeklyWinRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyWinRatePayload>
          }
          aggregate: {
            args: Prisma.WeeklyWinRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeeklyWinRate>
          }
          groupBy: {
            args: Prisma.WeeklyWinRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeeklyWinRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeeklyWinRateCountArgs<ExtArgs>
            result: $Utils.Optional<WeeklyWinRateCountAggregateOutputType> | number
          }
        }
      }
      BlogPost: {
        payload: Prisma.$BlogPostPayload<ExtArgs>
        fields: Prisma.BlogPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findFirst: {
            args: Prisma.BlogPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findMany: {
            args: Prisma.BlogPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          create: {
            args: Prisma.BlogPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          createMany: {
            args: Prisma.BlogPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          delete: {
            args: Prisma.BlogPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          update: {
            args: Prisma.BlogPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          upsert: {
            args: Prisma.BlogPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          aggregate: {
            args: Prisma.BlogPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogPost>
          }
          groupBy: {
            args: Prisma.BlogPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostCountArgs<ExtArgs>
            result: $Utils.Optional<BlogPostCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verification?: VerificationOmit
    alert?: AlertOmit
    telegramIntegration?: TelegramIntegrationOmit
    monitoredWallet?: MonitoredWalletOmit
    polymarketActivity?: PolymarketActivityOmit
    monitoringJobLog?: MonitoringJobLogOmit
    notificationQueue?: NotificationQueueOmit
    notificationLog?: NotificationLogOmit
    cronJobLog?: CronJobLogOmit
    conversation?: ConversationOmit
    message?: MessageOmit
    rulesConversation?: RulesConversationOmit
    rulesMessage?: RulesMessageOmit
    watchList?: WatchListOmit
    market?: MarketOmit
    proxyWallet?: ProxyWalletOmit
    syncHistory?: SyncHistoryOmit
    userAnalytics?: UserAnalyticsOmit
    marketDistribution?: MarketDistributionOmit
    buySellData?: BuySellDataOmit
    tradeSizeData?: TradeSizeDataOmit
    priceStats?: PriceStatsOmit
    monthlyPerformance?: MonthlyPerformanceOmit
    weeklyWinRate?: WeeklyWinRateOmit
    blogPost?: BlogPostOmit
    notification?: NotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    blogPost: number
    watchLists: number
    conversations: number
    rulesConversations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    blogPost?: boolean | UserCountOutputTypeCountBlogPostArgs
    watchLists?: boolean | UserCountOutputTypeCountWatchListsArgs
    conversations?: boolean | UserCountOutputTypeCountConversationsArgs
    rulesConversations?: boolean | UserCountOutputTypeCountRulesConversationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWatchListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchListWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRulesConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RulesConversationWhereInput
  }


  /**
   * Count Type AlertCountOutputType
   */

  export type AlertCountOutputType = {
    notifications: number
  }

  export type AlertCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | AlertCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * AlertCountOutputType without action
   */
  export type AlertCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertCountOutputType
     */
    select?: AlertCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlertCountOutputType without action
   */
  export type AlertCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type RulesConversationCountOutputType
   */

  export type RulesConversationCountOutputType = {
    messages: number
  }

  export type RulesConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | RulesConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * RulesConversationCountOutputType without action
   */
  export type RulesConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesConversationCountOutputType
     */
    select?: RulesConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RulesConversationCountOutputType without action
   */
  export type RulesConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RulesMessageWhereInput
  }


  /**
   * Count Type UserAnalyticsCountOutputType
   */

  export type UserAnalyticsCountOutputType = {
    marketDistribution: number
    monthlyPerformance: number
    weeklyWinRate: number
  }

  export type UserAnalyticsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marketDistribution?: boolean | UserAnalyticsCountOutputTypeCountMarketDistributionArgs
    monthlyPerformance?: boolean | UserAnalyticsCountOutputTypeCountMonthlyPerformanceArgs
    weeklyWinRate?: boolean | UserAnalyticsCountOutputTypeCountWeeklyWinRateArgs
  }

  // Custom InputTypes
  /**
   * UserAnalyticsCountOutputType without action
   */
  export type UserAnalyticsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalyticsCountOutputType
     */
    select?: UserAnalyticsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserAnalyticsCountOutputType without action
   */
  export type UserAnalyticsCountOutputTypeCountMarketDistributionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketDistributionWhereInput
  }

  /**
   * UserAnalyticsCountOutputType without action
   */
  export type UserAnalyticsCountOutputTypeCountMonthlyPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthlyPerformanceWhereInput
  }

  /**
   * UserAnalyticsCountOutputType without action
   */
  export type UserAnalyticsCountOutputTypeCountWeeklyWinRateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyWinRateWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    password: string | null
    verifyToken: string | null
    verifyTokenExpiry: Date | null
    walletAddress: string | null
    clobApiKey: string | null
    clobSecret: string | null
    clobPassphrase: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    accessToken: string | null
    telegramIntegrationId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    password: string | null
    verifyToken: string | null
    verifyTokenExpiry: Date | null
    walletAddress: string | null
    clobApiKey: string | null
    clobSecret: string | null
    clobPassphrase: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    accessToken: string | null
    telegramIntegrationId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    password: number
    verifyToken: number
    verifyTokenExpiry: number
    walletAddress: number
    clobApiKey: number
    clobSecret: number
    clobPassphrase: number
    image: number
    createdAt: number
    updatedAt: number
    accessToken: number
    telegramIntegrationId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    verifyToken?: true
    verifyTokenExpiry?: true
    walletAddress?: true
    clobApiKey?: true
    clobSecret?: true
    clobPassphrase?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    accessToken?: true
    telegramIntegrationId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    verifyToken?: true
    verifyTokenExpiry?: true
    walletAddress?: true
    clobApiKey?: true
    clobSecret?: true
    clobPassphrase?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    accessToken?: true
    telegramIntegrationId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    verifyToken?: true
    verifyTokenExpiry?: true
    walletAddress?: true
    clobApiKey?: true
    clobSecret?: true
    clobPassphrase?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    accessToken?: true
    telegramIntegrationId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string
    emailVerified: boolean | null
    password: string | null
    verifyToken: string | null
    verifyTokenExpiry: Date | null
    walletAddress: string | null
    clobApiKey: string | null
    clobSecret: string | null
    clobPassphrase: string | null
    image: string | null
    createdAt: Date
    updatedAt: Date
    accessToken: string | null
    telegramIntegrationId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    verifyToken?: boolean
    verifyTokenExpiry?: boolean
    walletAddress?: boolean
    clobApiKey?: boolean
    clobSecret?: boolean
    clobPassphrase?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accessToken?: boolean
    telegramIntegrationId?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    blogPost?: boolean | User$blogPostArgs<ExtArgs>
    telegramIntegration?: boolean | User$telegramIntegrationArgs<ExtArgs>
    watchLists?: boolean | User$watchListsArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    rulesConversations?: boolean | User$rulesConversationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    verifyToken?: boolean
    verifyTokenExpiry?: boolean
    walletAddress?: boolean
    clobApiKey?: boolean
    clobSecret?: boolean
    clobPassphrase?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accessToken?: boolean
    telegramIntegrationId?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    verifyToken?: boolean
    verifyTokenExpiry?: boolean
    walletAddress?: boolean
    clobApiKey?: boolean
    clobSecret?: boolean
    clobPassphrase?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accessToken?: boolean
    telegramIntegrationId?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    verifyToken?: boolean
    verifyTokenExpiry?: boolean
    walletAddress?: boolean
    clobApiKey?: boolean
    clobSecret?: boolean
    clobPassphrase?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accessToken?: boolean
    telegramIntegrationId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "password" | "verifyToken" | "verifyTokenExpiry" | "walletAddress" | "clobApiKey" | "clobSecret" | "clobPassphrase" | "image" | "createdAt" | "updatedAt" | "accessToken" | "telegramIntegrationId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    blogPost?: boolean | User$blogPostArgs<ExtArgs>
    telegramIntegration?: boolean | User$telegramIntegrationArgs<ExtArgs>
    watchLists?: boolean | User$watchListsArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    rulesConversations?: boolean | User$rulesConversationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      blogPost: Prisma.$BlogPostPayload<ExtArgs>[]
      telegramIntegration: Prisma.$TelegramIntegrationPayload<ExtArgs> | null
      watchLists: Prisma.$WatchListPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      rulesConversations: Prisma.$RulesConversationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string
      emailVerified: boolean | null
      password: string | null
      verifyToken: string | null
      verifyTokenExpiry: Date | null
      walletAddress: string | null
      clobApiKey: string | null
      clobSecret: string | null
      clobPassphrase: string | null
      image: string | null
      createdAt: Date
      updatedAt: Date
      accessToken: string | null
      telegramIntegrationId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blogPost<T extends User$blogPostArgs<ExtArgs> = {}>(args?: Subset<T, User$blogPostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    telegramIntegration<T extends User$telegramIntegrationArgs<ExtArgs> = {}>(args?: Subset<T, User$telegramIntegrationArgs<ExtArgs>>): Prisma__TelegramIntegrationClient<$Result.GetResult<Prisma.$TelegramIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    watchLists<T extends User$watchListsArgs<ExtArgs> = {}>(args?: Subset<T, User$watchListsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends User$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rulesConversations<T extends User$rulesConversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$rulesConversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RulesConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly password: FieldRef<"User", 'String'>
    readonly verifyToken: FieldRef<"User", 'String'>
    readonly verifyTokenExpiry: FieldRef<"User", 'DateTime'>
    readonly walletAddress: FieldRef<"User", 'String'>
    readonly clobApiKey: FieldRef<"User", 'String'>
    readonly clobSecret: FieldRef<"User", 'String'>
    readonly clobPassphrase: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly accessToken: FieldRef<"User", 'String'>
    readonly telegramIntegrationId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.blogPost
   */
  export type User$blogPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * User.telegramIntegration
   */
  export type User$telegramIntegrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramIntegration
     */
    select?: TelegramIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramIntegration
     */
    omit?: TelegramIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramIntegrationInclude<ExtArgs> | null
    where?: TelegramIntegrationWhereInput
  }

  /**
   * User.watchLists
   */
  export type User$watchListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchList
     */
    select?: WatchListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchList
     */
    omit?: WatchListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchListInclude<ExtArgs> | null
    where?: WatchListWhereInput
    orderBy?: WatchListOrderByWithRelationInput | WatchListOrderByWithRelationInput[]
    cursor?: WatchListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WatchListScalarFieldEnum | WatchListScalarFieldEnum[]
  }

  /**
   * User.conversations
   */
  export type User$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.rulesConversations
   */
  export type User$rulesConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesConversation
     */
    select?: RulesConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesConversation
     */
    omit?: RulesConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesConversationInclude<ExtArgs> | null
    where?: RulesConversationWhereInput
    orderBy?: RulesConversationOrderByWithRelationInput | RulesConversationOrderByWithRelationInput[]
    cursor?: RulesConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RulesConversationScalarFieldEnum | RulesConversationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    userId: string | null
    type: string | null
    providerId: string | null
    providerAccountId: string | null
    refresh_token: string | null
    refreshToken: string | null
    access_token: string | null
    accessToken: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    idToken: string | null
    session_state: string | null
    accessTokenExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    sessionToken: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    userId: string | null
    type: string | null
    providerId: string | null
    providerAccountId: string | null
    refresh_token: string | null
    refreshToken: string | null
    access_token: string | null
    accessToken: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    idToken: string | null
    session_state: string | null
    accessTokenExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    sessionToken: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    userId: number
    type: number
    providerId: number
    providerAccountId: number
    refresh_token: number
    refreshToken: number
    access_token: number
    accessToken: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    idToken: number
    session_state: number
    accessTokenExpiresAt: number
    createdAt: number
    updatedAt: number
    sessionToken: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    userId?: true
    type?: true
    providerId?: true
    providerAccountId?: true
    refresh_token?: true
    refreshToken?: true
    access_token?: true
    accessToken?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    idToken?: true
    session_state?: true
    accessTokenExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    sessionToken?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    userId?: true
    type?: true
    providerId?: true
    providerAccountId?: true
    refresh_token?: true
    refreshToken?: true
    access_token?: true
    accessToken?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    idToken?: true
    session_state?: true
    accessTokenExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    sessionToken?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    userId?: true
    type?: true
    providerId?: true
    providerAccountId?: true
    refresh_token?: true
    refreshToken?: true
    access_token?: true
    accessToken?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    idToken?: true
    session_state?: true
    accessTokenExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    sessionToken?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string | null
    userId: string
    type: string | null
    providerId: string | null
    providerAccountId: string | null
    refresh_token: string | null
    refreshToken: string | null
    access_token: string | null
    accessToken: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    idToken: string | null
    session_state: string | null
    accessTokenExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    sessionToken: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    userId?: boolean
    type?: boolean
    providerId?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    refreshToken?: boolean
    access_token?: boolean
    accessToken?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    idToken?: boolean
    session_state?: boolean
    accessTokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessionToken?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    userId?: boolean
    type?: boolean
    providerId?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    refreshToken?: boolean
    access_token?: boolean
    accessToken?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    idToken?: boolean
    session_state?: boolean
    accessTokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessionToken?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    userId?: boolean
    type?: boolean
    providerId?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    refreshToken?: boolean
    access_token?: boolean
    accessToken?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    idToken?: boolean
    session_state?: boolean
    accessTokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessionToken?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    userId?: boolean
    type?: boolean
    providerId?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    refreshToken?: boolean
    access_token?: boolean
    accessToken?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    idToken?: boolean
    session_state?: boolean
    accessTokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessionToken?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "userId" | "type" | "providerId" | "providerAccountId" | "refresh_token" | "refreshToken" | "access_token" | "accessToken" | "expires_at" | "token_type" | "scope" | "id_token" | "idToken" | "session_state" | "accessTokenExpiresAt" | "createdAt" | "updatedAt" | "sessionToken", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string | null
      userId: string
      type: string | null
      providerId: string | null
      providerAccountId: string | null
      refresh_token: string | null
      refreshToken: string | null
      access_token: string | null
      accessToken: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      idToken: string | null
      session_state: string | null
      accessTokenExpiresAt: Date | null
      createdAt: Date | null
      updatedAt: Date | null
      sessionToken: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
    readonly sessionToken: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    token: number
    userId: number
    expiresAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    token?: true
    userId?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    token?: true
    userId?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    token?: true
    userId?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string | null
    token: string | null
    userId: string
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "token" | "userId" | "expiresAt" | "ipAddress" | "userAgent" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string | null
      token: string | null
      userId: string
      expiresAt: Date | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model Alert
   */

  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userEmail: string | null
    walletAddress: string | null
    tradeType: string | null
    minAmount: string | null
    market: string | null
    notifyVia: string | null
    telegramNotify: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userEmail: string | null
    walletAddress: string | null
    tradeType: string | null
    minAmount: string | null
    market: string | null
    notifyVia: string | null
    telegramNotify: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    userId: number
    userEmail: number
    walletAddress: number
    tradeType: number
    minAmount: number
    market: number
    notifyVia: number
    telegramNotify: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AlertMinAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    walletAddress?: true
    tradeType?: true
    minAmount?: true
    market?: true
    notifyVia?: true
    telegramNotify?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    walletAddress?: true
    tradeType?: true
    minAmount?: true
    market?: true
    notifyVia?: true
    telegramNotify?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    walletAddress?: true
    tradeType?: true
    minAmount?: true
    market?: true
    notifyVia?: true
    telegramNotify?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithAggregationInput | AlertOrderByWithAggregationInput[]
    by: AlertScalarFieldEnum[] | AlertScalarFieldEnum
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }

  export type AlertGroupByOutputType = {
    id: string
    userId: string
    userEmail: string
    walletAddress: string
    tradeType: string
    minAmount: string | null
    market: string
    notifyVia: string
    telegramNotify: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    walletAddress?: boolean
    tradeType?: boolean
    minAmount?: boolean
    market?: boolean
    notifyVia?: boolean
    telegramNotify?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notifications?: boolean | Alert$notificationsArgs<ExtArgs>
    monitoredWallet?: boolean | Alert$monitoredWalletArgs<ExtArgs>
    _count?: boolean | AlertCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    walletAddress?: boolean
    tradeType?: boolean
    minAmount?: boolean
    market?: boolean
    notifyVia?: boolean
    telegramNotify?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    walletAddress?: boolean
    tradeType?: boolean
    minAmount?: boolean
    market?: boolean
    notifyVia?: boolean
    telegramNotify?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectScalar = {
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    walletAddress?: boolean
    tradeType?: boolean
    minAmount?: boolean
    market?: boolean
    notifyVia?: boolean
    telegramNotify?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "userEmail" | "walletAddress" | "tradeType" | "minAmount" | "market" | "notifyVia" | "telegramNotify" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["alert"]>
  export type AlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | Alert$notificationsArgs<ExtArgs>
    monitoredWallet?: boolean | Alert$monitoredWalletArgs<ExtArgs>
    _count?: boolean | AlertCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AlertIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alert"
    objects: {
      notifications: Prisma.$NotificationLogPayload<ExtArgs>[]
      monitoredWallet: Prisma.$MonitoredWalletPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      userEmail: string
      walletAddress: string
      tradeType: string
      minAmount: string | null
      market: string
      notifyVia: string
      telegramNotify: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["alert"]>
    composites: {}
  }

  type AlertGetPayload<S extends boolean | null | undefined | AlertDefaultArgs> = $Result.GetResult<Prisma.$AlertPayload, S>

  type AlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alert'], meta: { name: 'Alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertFindUniqueArgs>(args: SelectSubset<T, AlertFindUniqueArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Alert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertFindFirstArgs>(args?: SelectSubset<T, AlertFindFirstArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertFindManyArgs>(args?: SelectSubset<T, AlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
     */
    create<T extends AlertCreateArgs>(args: SelectSubset<T, AlertCreateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Alerts.
     * @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertCreateManyArgs>(args?: SelectSubset<T, AlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alerts and returns the data saved in the database.
     * @param {AlertCreateManyAndReturnArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
     */
    delete<T extends AlertDeleteArgs>(args: SelectSubset<T, AlertDeleteArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertUpdateArgs>(args: SelectSubset<T, AlertUpdateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertDeleteManyArgs>(args?: SelectSubset<T, AlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertUpdateManyArgs>(args: SelectSubset<T, AlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts and returns the data updated in the database.
     * @param {AlertUpdateManyAndReturnArgs} args - Arguments to update many Alerts.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlertUpdateManyAndReturnArgs>(args: SelectSubset<T, AlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
     */
    upsert<T extends AlertUpsertArgs>(args: SelectSubset<T, AlertUpsertArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alert model
   */
  readonly fields: AlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notifications<T extends Alert$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Alert$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    monitoredWallet<T extends Alert$monitoredWalletArgs<ExtArgs> = {}>(args?: Subset<T, Alert$monitoredWalletArgs<ExtArgs>>): Prisma__MonitoredWalletClient<$Result.GetResult<Prisma.$MonitoredWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alert model
   */
  interface AlertFieldRefs {
    readonly id: FieldRef<"Alert", 'String'>
    readonly userId: FieldRef<"Alert", 'String'>
    readonly userEmail: FieldRef<"Alert", 'String'>
    readonly walletAddress: FieldRef<"Alert", 'String'>
    readonly tradeType: FieldRef<"Alert", 'String'>
    readonly minAmount: FieldRef<"Alert", 'String'>
    readonly market: FieldRef<"Alert", 'String'>
    readonly notifyVia: FieldRef<"Alert", 'String'>
    readonly telegramNotify: FieldRef<"Alert", 'Boolean'>
    readonly isActive: FieldRef<"Alert", 'Boolean'>
    readonly createdAt: FieldRef<"Alert", 'DateTime'>
    readonly updatedAt: FieldRef<"Alert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Alert findUnique
   */
  export type AlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findFirst
   */
  export type AlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findMany
   */
  export type AlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert create
   */
  export type AlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }

  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert createManyAndReturn
   */
  export type AlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert update
   */
  export type AlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to update.
     */
    limit?: number
  }

  /**
   * Alert updateManyAndReturn
   */
  export type AlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to update.
     */
    limit?: number
  }

  /**
   * Alert upsert
   */
  export type AlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }

  /**
   * Alert delete
   */
  export type AlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to delete.
     */
    limit?: number
  }

  /**
   * Alert.notifications
   */
  export type Alert$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    cursor?: NotificationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * Alert.monitoredWallet
   */
  export type Alert$monitoredWalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredWallet
     */
    select?: MonitoredWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoredWallet
     */
    omit?: MonitoredWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredWalletInclude<ExtArgs> | null
    where?: MonitoredWalletWhereInput
  }

  /**
   * Alert without action
   */
  export type AlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
  }


  /**
   * Model TelegramIntegration
   */

  export type AggregateTelegramIntegration = {
    _count: TelegramIntegrationCountAggregateOutputType | null
    _min: TelegramIntegrationMinAggregateOutputType | null
    _max: TelegramIntegrationMaxAggregateOutputType | null
  }

  export type TelegramIntegrationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    chatId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type TelegramIntegrationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    chatId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type TelegramIntegrationCountAggregateOutputType = {
    id: number
    userId: number
    userName: number
    chatId: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type TelegramIntegrationMinAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    chatId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type TelegramIntegrationMaxAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    chatId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type TelegramIntegrationCountAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    chatId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type TelegramIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelegramIntegration to aggregate.
     */
    where?: TelegramIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramIntegrations to fetch.
     */
    orderBy?: TelegramIntegrationOrderByWithRelationInput | TelegramIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TelegramIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TelegramIntegrations
    **/
    _count?: true | TelegramIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TelegramIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TelegramIntegrationMaxAggregateInputType
  }

  export type GetTelegramIntegrationAggregateType<T extends TelegramIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateTelegramIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTelegramIntegration[P]>
      : GetScalarType<T[P], AggregateTelegramIntegration[P]>
  }




  export type TelegramIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelegramIntegrationWhereInput
    orderBy?: TelegramIntegrationOrderByWithAggregationInput | TelegramIntegrationOrderByWithAggregationInput[]
    by: TelegramIntegrationScalarFieldEnum[] | TelegramIntegrationScalarFieldEnum
    having?: TelegramIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TelegramIntegrationCountAggregateInputType | true
    _min?: TelegramIntegrationMinAggregateInputType
    _max?: TelegramIntegrationMaxAggregateInputType
  }

  export type TelegramIntegrationGroupByOutputType = {
    id: string
    userId: string
    userName: string
    chatId: string
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: TelegramIntegrationCountAggregateOutputType | null
    _min: TelegramIntegrationMinAggregateOutputType | null
    _max: TelegramIntegrationMaxAggregateOutputType | null
  }

  type GetTelegramIntegrationGroupByPayload<T extends TelegramIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TelegramIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TelegramIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TelegramIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], TelegramIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type TelegramIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    chatId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramIntegration"]>

  export type TelegramIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    chatId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramIntegration"]>

  export type TelegramIntegrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    chatId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramIntegration"]>

  export type TelegramIntegrationSelectScalar = {
    id?: boolean
    userId?: boolean
    userName?: boolean
    chatId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type TelegramIntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "userName" | "chatId" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["telegramIntegration"]>
  export type TelegramIntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TelegramIntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TelegramIntegrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TelegramIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TelegramIntegration"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      userName: string
      chatId: string
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["telegramIntegration"]>
    composites: {}
  }

  type TelegramIntegrationGetPayload<S extends boolean | null | undefined | TelegramIntegrationDefaultArgs> = $Result.GetResult<Prisma.$TelegramIntegrationPayload, S>

  type TelegramIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TelegramIntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TelegramIntegrationCountAggregateInputType | true
    }

  export interface TelegramIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TelegramIntegration'], meta: { name: 'TelegramIntegration' } }
    /**
     * Find zero or one TelegramIntegration that matches the filter.
     * @param {TelegramIntegrationFindUniqueArgs} args - Arguments to find a TelegramIntegration
     * @example
     * // Get one TelegramIntegration
     * const telegramIntegration = await prisma.telegramIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TelegramIntegrationFindUniqueArgs>(args: SelectSubset<T, TelegramIntegrationFindUniqueArgs<ExtArgs>>): Prisma__TelegramIntegrationClient<$Result.GetResult<Prisma.$TelegramIntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TelegramIntegration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TelegramIntegrationFindUniqueOrThrowArgs} args - Arguments to find a TelegramIntegration
     * @example
     * // Get one TelegramIntegration
     * const telegramIntegration = await prisma.telegramIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TelegramIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, TelegramIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TelegramIntegrationClient<$Result.GetResult<Prisma.$TelegramIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelegramIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramIntegrationFindFirstArgs} args - Arguments to find a TelegramIntegration
     * @example
     * // Get one TelegramIntegration
     * const telegramIntegration = await prisma.telegramIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TelegramIntegrationFindFirstArgs>(args?: SelectSubset<T, TelegramIntegrationFindFirstArgs<ExtArgs>>): Prisma__TelegramIntegrationClient<$Result.GetResult<Prisma.$TelegramIntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelegramIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramIntegrationFindFirstOrThrowArgs} args - Arguments to find a TelegramIntegration
     * @example
     * // Get one TelegramIntegration
     * const telegramIntegration = await prisma.telegramIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TelegramIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, TelegramIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TelegramIntegrationClient<$Result.GetResult<Prisma.$TelegramIntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TelegramIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TelegramIntegrations
     * const telegramIntegrations = await prisma.telegramIntegration.findMany()
     * 
     * // Get first 10 TelegramIntegrations
     * const telegramIntegrations = await prisma.telegramIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const telegramIntegrationWithIdOnly = await prisma.telegramIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TelegramIntegrationFindManyArgs>(args?: SelectSubset<T, TelegramIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramIntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TelegramIntegration.
     * @param {TelegramIntegrationCreateArgs} args - Arguments to create a TelegramIntegration.
     * @example
     * // Create one TelegramIntegration
     * const TelegramIntegration = await prisma.telegramIntegration.create({
     *   data: {
     *     // ... data to create a TelegramIntegration
     *   }
     * })
     * 
     */
    create<T extends TelegramIntegrationCreateArgs>(args: SelectSubset<T, TelegramIntegrationCreateArgs<ExtArgs>>): Prisma__TelegramIntegrationClient<$Result.GetResult<Prisma.$TelegramIntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TelegramIntegrations.
     * @param {TelegramIntegrationCreateManyArgs} args - Arguments to create many TelegramIntegrations.
     * @example
     * // Create many TelegramIntegrations
     * const telegramIntegration = await prisma.telegramIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TelegramIntegrationCreateManyArgs>(args?: SelectSubset<T, TelegramIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TelegramIntegrations and returns the data saved in the database.
     * @param {TelegramIntegrationCreateManyAndReturnArgs} args - Arguments to create many TelegramIntegrations.
     * @example
     * // Create many TelegramIntegrations
     * const telegramIntegration = await prisma.telegramIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TelegramIntegrations and only return the `id`
     * const telegramIntegrationWithIdOnly = await prisma.telegramIntegration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TelegramIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, TelegramIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramIntegrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TelegramIntegration.
     * @param {TelegramIntegrationDeleteArgs} args - Arguments to delete one TelegramIntegration.
     * @example
     * // Delete one TelegramIntegration
     * const TelegramIntegration = await prisma.telegramIntegration.delete({
     *   where: {
     *     // ... filter to delete one TelegramIntegration
     *   }
     * })
     * 
     */
    delete<T extends TelegramIntegrationDeleteArgs>(args: SelectSubset<T, TelegramIntegrationDeleteArgs<ExtArgs>>): Prisma__TelegramIntegrationClient<$Result.GetResult<Prisma.$TelegramIntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TelegramIntegration.
     * @param {TelegramIntegrationUpdateArgs} args - Arguments to update one TelegramIntegration.
     * @example
     * // Update one TelegramIntegration
     * const telegramIntegration = await prisma.telegramIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TelegramIntegrationUpdateArgs>(args: SelectSubset<T, TelegramIntegrationUpdateArgs<ExtArgs>>): Prisma__TelegramIntegrationClient<$Result.GetResult<Prisma.$TelegramIntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TelegramIntegrations.
     * @param {TelegramIntegrationDeleteManyArgs} args - Arguments to filter TelegramIntegrations to delete.
     * @example
     * // Delete a few TelegramIntegrations
     * const { count } = await prisma.telegramIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TelegramIntegrationDeleteManyArgs>(args?: SelectSubset<T, TelegramIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelegramIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TelegramIntegrations
     * const telegramIntegration = await prisma.telegramIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TelegramIntegrationUpdateManyArgs>(args: SelectSubset<T, TelegramIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelegramIntegrations and returns the data updated in the database.
     * @param {TelegramIntegrationUpdateManyAndReturnArgs} args - Arguments to update many TelegramIntegrations.
     * @example
     * // Update many TelegramIntegrations
     * const telegramIntegration = await prisma.telegramIntegration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TelegramIntegrations and only return the `id`
     * const telegramIntegrationWithIdOnly = await prisma.telegramIntegration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TelegramIntegrationUpdateManyAndReturnArgs>(args: SelectSubset<T, TelegramIntegrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramIntegrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TelegramIntegration.
     * @param {TelegramIntegrationUpsertArgs} args - Arguments to update or create a TelegramIntegration.
     * @example
     * // Update or create a TelegramIntegration
     * const telegramIntegration = await prisma.telegramIntegration.upsert({
     *   create: {
     *     // ... data to create a TelegramIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TelegramIntegration we want to update
     *   }
     * })
     */
    upsert<T extends TelegramIntegrationUpsertArgs>(args: SelectSubset<T, TelegramIntegrationUpsertArgs<ExtArgs>>): Prisma__TelegramIntegrationClient<$Result.GetResult<Prisma.$TelegramIntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TelegramIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramIntegrationCountArgs} args - Arguments to filter TelegramIntegrations to count.
     * @example
     * // Count the number of TelegramIntegrations
     * const count = await prisma.telegramIntegration.count({
     *   where: {
     *     // ... the filter for the TelegramIntegrations we want to count
     *   }
     * })
    **/
    count<T extends TelegramIntegrationCountArgs>(
      args?: Subset<T, TelegramIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TelegramIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TelegramIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TelegramIntegrationAggregateArgs>(args: Subset<T, TelegramIntegrationAggregateArgs>): Prisma.PrismaPromise<GetTelegramIntegrationAggregateType<T>>

    /**
     * Group by TelegramIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TelegramIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TelegramIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: TelegramIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TelegramIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTelegramIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TelegramIntegration model
   */
  readonly fields: TelegramIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TelegramIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TelegramIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TelegramIntegration model
   */
  interface TelegramIntegrationFieldRefs {
    readonly id: FieldRef<"TelegramIntegration", 'String'>
    readonly userId: FieldRef<"TelegramIntegration", 'String'>
    readonly userName: FieldRef<"TelegramIntegration", 'String'>
    readonly chatId: FieldRef<"TelegramIntegration", 'String'>
    readonly createdAt: FieldRef<"TelegramIntegration", 'DateTime'>
    readonly updatedAt: FieldRef<"TelegramIntegration", 'DateTime'>
    readonly createdById: FieldRef<"TelegramIntegration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TelegramIntegration findUnique
   */
  export type TelegramIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramIntegration
     */
    select?: TelegramIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramIntegration
     */
    omit?: TelegramIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which TelegramIntegration to fetch.
     */
    where: TelegramIntegrationWhereUniqueInput
  }

  /**
   * TelegramIntegration findUniqueOrThrow
   */
  export type TelegramIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramIntegration
     */
    select?: TelegramIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramIntegration
     */
    omit?: TelegramIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which TelegramIntegration to fetch.
     */
    where: TelegramIntegrationWhereUniqueInput
  }

  /**
   * TelegramIntegration findFirst
   */
  export type TelegramIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramIntegration
     */
    select?: TelegramIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramIntegration
     */
    omit?: TelegramIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which TelegramIntegration to fetch.
     */
    where?: TelegramIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramIntegrations to fetch.
     */
    orderBy?: TelegramIntegrationOrderByWithRelationInput | TelegramIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelegramIntegrations.
     */
    cursor?: TelegramIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelegramIntegrations.
     */
    distinct?: TelegramIntegrationScalarFieldEnum | TelegramIntegrationScalarFieldEnum[]
  }

  /**
   * TelegramIntegration findFirstOrThrow
   */
  export type TelegramIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramIntegration
     */
    select?: TelegramIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramIntegration
     */
    omit?: TelegramIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which TelegramIntegration to fetch.
     */
    where?: TelegramIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramIntegrations to fetch.
     */
    orderBy?: TelegramIntegrationOrderByWithRelationInput | TelegramIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelegramIntegrations.
     */
    cursor?: TelegramIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelegramIntegrations.
     */
    distinct?: TelegramIntegrationScalarFieldEnum | TelegramIntegrationScalarFieldEnum[]
  }

  /**
   * TelegramIntegration findMany
   */
  export type TelegramIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramIntegration
     */
    select?: TelegramIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramIntegration
     */
    omit?: TelegramIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which TelegramIntegrations to fetch.
     */
    where?: TelegramIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramIntegrations to fetch.
     */
    orderBy?: TelegramIntegrationOrderByWithRelationInput | TelegramIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TelegramIntegrations.
     */
    cursor?: TelegramIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramIntegrations.
     */
    skip?: number
    distinct?: TelegramIntegrationScalarFieldEnum | TelegramIntegrationScalarFieldEnum[]
  }

  /**
   * TelegramIntegration create
   */
  export type TelegramIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramIntegration
     */
    select?: TelegramIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramIntegration
     */
    omit?: TelegramIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a TelegramIntegration.
     */
    data: XOR<TelegramIntegrationCreateInput, TelegramIntegrationUncheckedCreateInput>
  }

  /**
   * TelegramIntegration createMany
   */
  export type TelegramIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TelegramIntegrations.
     */
    data: TelegramIntegrationCreateManyInput | TelegramIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TelegramIntegration createManyAndReturn
   */
  export type TelegramIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramIntegration
     */
    select?: TelegramIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramIntegration
     */
    omit?: TelegramIntegrationOmit<ExtArgs> | null
    /**
     * The data used to create many TelegramIntegrations.
     */
    data: TelegramIntegrationCreateManyInput | TelegramIntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramIntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TelegramIntegration update
   */
  export type TelegramIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramIntegration
     */
    select?: TelegramIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramIntegration
     */
    omit?: TelegramIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a TelegramIntegration.
     */
    data: XOR<TelegramIntegrationUpdateInput, TelegramIntegrationUncheckedUpdateInput>
    /**
     * Choose, which TelegramIntegration to update.
     */
    where: TelegramIntegrationWhereUniqueInput
  }

  /**
   * TelegramIntegration updateMany
   */
  export type TelegramIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TelegramIntegrations.
     */
    data: XOR<TelegramIntegrationUpdateManyMutationInput, TelegramIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which TelegramIntegrations to update
     */
    where?: TelegramIntegrationWhereInput
    /**
     * Limit how many TelegramIntegrations to update.
     */
    limit?: number
  }

  /**
   * TelegramIntegration updateManyAndReturn
   */
  export type TelegramIntegrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramIntegration
     */
    select?: TelegramIntegrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramIntegration
     */
    omit?: TelegramIntegrationOmit<ExtArgs> | null
    /**
     * The data used to update TelegramIntegrations.
     */
    data: XOR<TelegramIntegrationUpdateManyMutationInput, TelegramIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which TelegramIntegrations to update
     */
    where?: TelegramIntegrationWhereInput
    /**
     * Limit how many TelegramIntegrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramIntegrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TelegramIntegration upsert
   */
  export type TelegramIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramIntegration
     */
    select?: TelegramIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramIntegration
     */
    omit?: TelegramIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramIntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the TelegramIntegration to update in case it exists.
     */
    where: TelegramIntegrationWhereUniqueInput
    /**
     * In case the TelegramIntegration found by the `where` argument doesn't exist, create a new TelegramIntegration with this data.
     */
    create: XOR<TelegramIntegrationCreateInput, TelegramIntegrationUncheckedCreateInput>
    /**
     * In case the TelegramIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TelegramIntegrationUpdateInput, TelegramIntegrationUncheckedUpdateInput>
  }

  /**
   * TelegramIntegration delete
   */
  export type TelegramIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramIntegration
     */
    select?: TelegramIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramIntegration
     */
    omit?: TelegramIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramIntegrationInclude<ExtArgs> | null
    /**
     * Filter which TelegramIntegration to delete.
     */
    where: TelegramIntegrationWhereUniqueInput
  }

  /**
   * TelegramIntegration deleteMany
   */
  export type TelegramIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelegramIntegrations to delete
     */
    where?: TelegramIntegrationWhereInput
    /**
     * Limit how many TelegramIntegrations to delete.
     */
    limit?: number
  }

  /**
   * TelegramIntegration without action
   */
  export type TelegramIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramIntegration
     */
    select?: TelegramIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramIntegration
     */
    omit?: TelegramIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramIntegrationInclude<ExtArgs> | null
  }


  /**
   * Model MonitoredWallet
   */

  export type AggregateMonitoredWallet = {
    _count: MonitoredWalletCountAggregateOutputType | null
    _avg: MonitoredWalletAvgAggregateOutputType | null
    _sum: MonitoredWalletSumAggregateOutputType | null
    _min: MonitoredWalletMinAggregateOutputType | null
    _max: MonitoredWalletMaxAggregateOutputType | null
  }

  export type MonitoredWalletAvgAggregateOutputType = {
    lastActivityTimestamp: number | null
    totalActivities: number | null
  }

  export type MonitoredWalletSumAggregateOutputType = {
    lastActivityTimestamp: number | null
    totalActivities: number | null
  }

  export type MonitoredWalletMinAggregateOutputType = {
    id: string | null
    proxyWallet: string | null
    alertId: string | null
    lastActivityTimestamp: number | null
    lastActivityHash: string | null
    totalActivities: number | null
    lastCheckedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MonitoredWalletMaxAggregateOutputType = {
    id: string | null
    proxyWallet: string | null
    alertId: string | null
    lastActivityTimestamp: number | null
    lastActivityHash: string | null
    totalActivities: number | null
    lastCheckedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MonitoredWalletCountAggregateOutputType = {
    id: number
    proxyWallet: number
    alertId: number
    lastActivityTimestamp: number
    lastActivityHash: number
    totalActivities: number
    lastCheckedAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MonitoredWalletAvgAggregateInputType = {
    lastActivityTimestamp?: true
    totalActivities?: true
  }

  export type MonitoredWalletSumAggregateInputType = {
    lastActivityTimestamp?: true
    totalActivities?: true
  }

  export type MonitoredWalletMinAggregateInputType = {
    id?: true
    proxyWallet?: true
    alertId?: true
    lastActivityTimestamp?: true
    lastActivityHash?: true
    totalActivities?: true
    lastCheckedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MonitoredWalletMaxAggregateInputType = {
    id?: true
    proxyWallet?: true
    alertId?: true
    lastActivityTimestamp?: true
    lastActivityHash?: true
    totalActivities?: true
    lastCheckedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MonitoredWalletCountAggregateInputType = {
    id?: true
    proxyWallet?: true
    alertId?: true
    lastActivityTimestamp?: true
    lastActivityHash?: true
    totalActivities?: true
    lastCheckedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MonitoredWalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonitoredWallet to aggregate.
     */
    where?: MonitoredWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitoredWallets to fetch.
     */
    orderBy?: MonitoredWalletOrderByWithRelationInput | MonitoredWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MonitoredWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitoredWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitoredWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MonitoredWallets
    **/
    _count?: true | MonitoredWalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonitoredWalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonitoredWalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonitoredWalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonitoredWalletMaxAggregateInputType
  }

  export type GetMonitoredWalletAggregateType<T extends MonitoredWalletAggregateArgs> = {
        [P in keyof T & keyof AggregateMonitoredWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonitoredWallet[P]>
      : GetScalarType<T[P], AggregateMonitoredWallet[P]>
  }




  export type MonitoredWalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonitoredWalletWhereInput
    orderBy?: MonitoredWalletOrderByWithAggregationInput | MonitoredWalletOrderByWithAggregationInput[]
    by: MonitoredWalletScalarFieldEnum[] | MonitoredWalletScalarFieldEnum
    having?: MonitoredWalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonitoredWalletCountAggregateInputType | true
    _avg?: MonitoredWalletAvgAggregateInputType
    _sum?: MonitoredWalletSumAggregateInputType
    _min?: MonitoredWalletMinAggregateInputType
    _max?: MonitoredWalletMaxAggregateInputType
  }

  export type MonitoredWalletGroupByOutputType = {
    id: string
    proxyWallet: string
    alertId: string
    lastActivityTimestamp: number | null
    lastActivityHash: string | null
    totalActivities: number
    lastCheckedAt: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: MonitoredWalletCountAggregateOutputType | null
    _avg: MonitoredWalletAvgAggregateOutputType | null
    _sum: MonitoredWalletSumAggregateOutputType | null
    _min: MonitoredWalletMinAggregateOutputType | null
    _max: MonitoredWalletMaxAggregateOutputType | null
  }

  type GetMonitoredWalletGroupByPayload<T extends MonitoredWalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonitoredWalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonitoredWalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonitoredWalletGroupByOutputType[P]>
            : GetScalarType<T[P], MonitoredWalletGroupByOutputType[P]>
        }
      >
    >


  export type MonitoredWalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proxyWallet?: boolean
    alertId?: boolean
    lastActivityTimestamp?: boolean
    lastActivityHash?: boolean
    totalActivities?: boolean
    lastCheckedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alert?: boolean | AlertDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monitoredWallet"]>

  export type MonitoredWalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proxyWallet?: boolean
    alertId?: boolean
    lastActivityTimestamp?: boolean
    lastActivityHash?: boolean
    totalActivities?: boolean
    lastCheckedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alert?: boolean | AlertDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monitoredWallet"]>

  export type MonitoredWalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proxyWallet?: boolean
    alertId?: boolean
    lastActivityTimestamp?: boolean
    lastActivityHash?: boolean
    totalActivities?: boolean
    lastCheckedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alert?: boolean | AlertDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monitoredWallet"]>

  export type MonitoredWalletSelectScalar = {
    id?: boolean
    proxyWallet?: boolean
    alertId?: boolean
    lastActivityTimestamp?: boolean
    lastActivityHash?: boolean
    totalActivities?: boolean
    lastCheckedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MonitoredWalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "proxyWallet" | "alertId" | "lastActivityTimestamp" | "lastActivityHash" | "totalActivities" | "lastCheckedAt" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["monitoredWallet"]>
  export type MonitoredWalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | AlertDefaultArgs<ExtArgs>
  }
  export type MonitoredWalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | AlertDefaultArgs<ExtArgs>
  }
  export type MonitoredWalletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | AlertDefaultArgs<ExtArgs>
  }

  export type $MonitoredWalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MonitoredWallet"
    objects: {
      alert: Prisma.$AlertPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      proxyWallet: string
      alertId: string
      lastActivityTimestamp: number | null
      lastActivityHash: string | null
      totalActivities: number
      lastCheckedAt: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["monitoredWallet"]>
    composites: {}
  }

  type MonitoredWalletGetPayload<S extends boolean | null | undefined | MonitoredWalletDefaultArgs> = $Result.GetResult<Prisma.$MonitoredWalletPayload, S>

  type MonitoredWalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MonitoredWalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MonitoredWalletCountAggregateInputType | true
    }

  export interface MonitoredWalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MonitoredWallet'], meta: { name: 'MonitoredWallet' } }
    /**
     * Find zero or one MonitoredWallet that matches the filter.
     * @param {MonitoredWalletFindUniqueArgs} args - Arguments to find a MonitoredWallet
     * @example
     * // Get one MonitoredWallet
     * const monitoredWallet = await prisma.monitoredWallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MonitoredWalletFindUniqueArgs>(args: SelectSubset<T, MonitoredWalletFindUniqueArgs<ExtArgs>>): Prisma__MonitoredWalletClient<$Result.GetResult<Prisma.$MonitoredWalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MonitoredWallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MonitoredWalletFindUniqueOrThrowArgs} args - Arguments to find a MonitoredWallet
     * @example
     * // Get one MonitoredWallet
     * const monitoredWallet = await prisma.monitoredWallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MonitoredWalletFindUniqueOrThrowArgs>(args: SelectSubset<T, MonitoredWalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MonitoredWalletClient<$Result.GetResult<Prisma.$MonitoredWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MonitoredWallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoredWalletFindFirstArgs} args - Arguments to find a MonitoredWallet
     * @example
     * // Get one MonitoredWallet
     * const monitoredWallet = await prisma.monitoredWallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MonitoredWalletFindFirstArgs>(args?: SelectSubset<T, MonitoredWalletFindFirstArgs<ExtArgs>>): Prisma__MonitoredWalletClient<$Result.GetResult<Prisma.$MonitoredWalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MonitoredWallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoredWalletFindFirstOrThrowArgs} args - Arguments to find a MonitoredWallet
     * @example
     * // Get one MonitoredWallet
     * const monitoredWallet = await prisma.monitoredWallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MonitoredWalletFindFirstOrThrowArgs>(args?: SelectSubset<T, MonitoredWalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__MonitoredWalletClient<$Result.GetResult<Prisma.$MonitoredWalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MonitoredWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoredWalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MonitoredWallets
     * const monitoredWallets = await prisma.monitoredWallet.findMany()
     * 
     * // Get first 10 MonitoredWallets
     * const monitoredWallets = await prisma.monitoredWallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monitoredWalletWithIdOnly = await prisma.monitoredWallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MonitoredWalletFindManyArgs>(args?: SelectSubset<T, MonitoredWalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitoredWalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MonitoredWallet.
     * @param {MonitoredWalletCreateArgs} args - Arguments to create a MonitoredWallet.
     * @example
     * // Create one MonitoredWallet
     * const MonitoredWallet = await prisma.monitoredWallet.create({
     *   data: {
     *     // ... data to create a MonitoredWallet
     *   }
     * })
     * 
     */
    create<T extends MonitoredWalletCreateArgs>(args: SelectSubset<T, MonitoredWalletCreateArgs<ExtArgs>>): Prisma__MonitoredWalletClient<$Result.GetResult<Prisma.$MonitoredWalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MonitoredWallets.
     * @param {MonitoredWalletCreateManyArgs} args - Arguments to create many MonitoredWallets.
     * @example
     * // Create many MonitoredWallets
     * const monitoredWallet = await prisma.monitoredWallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MonitoredWalletCreateManyArgs>(args?: SelectSubset<T, MonitoredWalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MonitoredWallets and returns the data saved in the database.
     * @param {MonitoredWalletCreateManyAndReturnArgs} args - Arguments to create many MonitoredWallets.
     * @example
     * // Create many MonitoredWallets
     * const monitoredWallet = await prisma.monitoredWallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MonitoredWallets and only return the `id`
     * const monitoredWalletWithIdOnly = await prisma.monitoredWallet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MonitoredWalletCreateManyAndReturnArgs>(args?: SelectSubset<T, MonitoredWalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitoredWalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MonitoredWallet.
     * @param {MonitoredWalletDeleteArgs} args - Arguments to delete one MonitoredWallet.
     * @example
     * // Delete one MonitoredWallet
     * const MonitoredWallet = await prisma.monitoredWallet.delete({
     *   where: {
     *     // ... filter to delete one MonitoredWallet
     *   }
     * })
     * 
     */
    delete<T extends MonitoredWalletDeleteArgs>(args: SelectSubset<T, MonitoredWalletDeleteArgs<ExtArgs>>): Prisma__MonitoredWalletClient<$Result.GetResult<Prisma.$MonitoredWalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MonitoredWallet.
     * @param {MonitoredWalletUpdateArgs} args - Arguments to update one MonitoredWallet.
     * @example
     * // Update one MonitoredWallet
     * const monitoredWallet = await prisma.monitoredWallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MonitoredWalletUpdateArgs>(args: SelectSubset<T, MonitoredWalletUpdateArgs<ExtArgs>>): Prisma__MonitoredWalletClient<$Result.GetResult<Prisma.$MonitoredWalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MonitoredWallets.
     * @param {MonitoredWalletDeleteManyArgs} args - Arguments to filter MonitoredWallets to delete.
     * @example
     * // Delete a few MonitoredWallets
     * const { count } = await prisma.monitoredWallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MonitoredWalletDeleteManyArgs>(args?: SelectSubset<T, MonitoredWalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonitoredWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoredWalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MonitoredWallets
     * const monitoredWallet = await prisma.monitoredWallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MonitoredWalletUpdateManyArgs>(args: SelectSubset<T, MonitoredWalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonitoredWallets and returns the data updated in the database.
     * @param {MonitoredWalletUpdateManyAndReturnArgs} args - Arguments to update many MonitoredWallets.
     * @example
     * // Update many MonitoredWallets
     * const monitoredWallet = await prisma.monitoredWallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MonitoredWallets and only return the `id`
     * const monitoredWalletWithIdOnly = await prisma.monitoredWallet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MonitoredWalletUpdateManyAndReturnArgs>(args: SelectSubset<T, MonitoredWalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitoredWalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MonitoredWallet.
     * @param {MonitoredWalletUpsertArgs} args - Arguments to update or create a MonitoredWallet.
     * @example
     * // Update or create a MonitoredWallet
     * const monitoredWallet = await prisma.monitoredWallet.upsert({
     *   create: {
     *     // ... data to create a MonitoredWallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MonitoredWallet we want to update
     *   }
     * })
     */
    upsert<T extends MonitoredWalletUpsertArgs>(args: SelectSubset<T, MonitoredWalletUpsertArgs<ExtArgs>>): Prisma__MonitoredWalletClient<$Result.GetResult<Prisma.$MonitoredWalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MonitoredWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoredWalletCountArgs} args - Arguments to filter MonitoredWallets to count.
     * @example
     * // Count the number of MonitoredWallets
     * const count = await prisma.monitoredWallet.count({
     *   where: {
     *     // ... the filter for the MonitoredWallets we want to count
     *   }
     * })
    **/
    count<T extends MonitoredWalletCountArgs>(
      args?: Subset<T, MonitoredWalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonitoredWalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MonitoredWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoredWalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonitoredWalletAggregateArgs>(args: Subset<T, MonitoredWalletAggregateArgs>): Prisma.PrismaPromise<GetMonitoredWalletAggregateType<T>>

    /**
     * Group by MonitoredWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoredWalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MonitoredWalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MonitoredWalletGroupByArgs['orderBy'] }
        : { orderBy?: MonitoredWalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MonitoredWalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonitoredWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MonitoredWallet model
   */
  readonly fields: MonitoredWalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MonitoredWallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MonitoredWalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alert<T extends AlertDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlertDefaultArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MonitoredWallet model
   */
  interface MonitoredWalletFieldRefs {
    readonly id: FieldRef<"MonitoredWallet", 'String'>
    readonly proxyWallet: FieldRef<"MonitoredWallet", 'String'>
    readonly alertId: FieldRef<"MonitoredWallet", 'String'>
    readonly lastActivityTimestamp: FieldRef<"MonitoredWallet", 'Int'>
    readonly lastActivityHash: FieldRef<"MonitoredWallet", 'String'>
    readonly totalActivities: FieldRef<"MonitoredWallet", 'Int'>
    readonly lastCheckedAt: FieldRef<"MonitoredWallet", 'DateTime'>
    readonly isActive: FieldRef<"MonitoredWallet", 'Boolean'>
    readonly createdAt: FieldRef<"MonitoredWallet", 'DateTime'>
    readonly updatedAt: FieldRef<"MonitoredWallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MonitoredWallet findUnique
   */
  export type MonitoredWalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredWallet
     */
    select?: MonitoredWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoredWallet
     */
    omit?: MonitoredWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredWalletInclude<ExtArgs> | null
    /**
     * Filter, which MonitoredWallet to fetch.
     */
    where: MonitoredWalletWhereUniqueInput
  }

  /**
   * MonitoredWallet findUniqueOrThrow
   */
  export type MonitoredWalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredWallet
     */
    select?: MonitoredWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoredWallet
     */
    omit?: MonitoredWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredWalletInclude<ExtArgs> | null
    /**
     * Filter, which MonitoredWallet to fetch.
     */
    where: MonitoredWalletWhereUniqueInput
  }

  /**
   * MonitoredWallet findFirst
   */
  export type MonitoredWalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredWallet
     */
    select?: MonitoredWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoredWallet
     */
    omit?: MonitoredWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredWalletInclude<ExtArgs> | null
    /**
     * Filter, which MonitoredWallet to fetch.
     */
    where?: MonitoredWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitoredWallets to fetch.
     */
    orderBy?: MonitoredWalletOrderByWithRelationInput | MonitoredWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonitoredWallets.
     */
    cursor?: MonitoredWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitoredWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitoredWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonitoredWallets.
     */
    distinct?: MonitoredWalletScalarFieldEnum | MonitoredWalletScalarFieldEnum[]
  }

  /**
   * MonitoredWallet findFirstOrThrow
   */
  export type MonitoredWalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredWallet
     */
    select?: MonitoredWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoredWallet
     */
    omit?: MonitoredWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredWalletInclude<ExtArgs> | null
    /**
     * Filter, which MonitoredWallet to fetch.
     */
    where?: MonitoredWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitoredWallets to fetch.
     */
    orderBy?: MonitoredWalletOrderByWithRelationInput | MonitoredWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonitoredWallets.
     */
    cursor?: MonitoredWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitoredWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitoredWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonitoredWallets.
     */
    distinct?: MonitoredWalletScalarFieldEnum | MonitoredWalletScalarFieldEnum[]
  }

  /**
   * MonitoredWallet findMany
   */
  export type MonitoredWalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredWallet
     */
    select?: MonitoredWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoredWallet
     */
    omit?: MonitoredWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredWalletInclude<ExtArgs> | null
    /**
     * Filter, which MonitoredWallets to fetch.
     */
    where?: MonitoredWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitoredWallets to fetch.
     */
    orderBy?: MonitoredWalletOrderByWithRelationInput | MonitoredWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MonitoredWallets.
     */
    cursor?: MonitoredWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitoredWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitoredWallets.
     */
    skip?: number
    distinct?: MonitoredWalletScalarFieldEnum | MonitoredWalletScalarFieldEnum[]
  }

  /**
   * MonitoredWallet create
   */
  export type MonitoredWalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredWallet
     */
    select?: MonitoredWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoredWallet
     */
    omit?: MonitoredWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredWalletInclude<ExtArgs> | null
    /**
     * The data needed to create a MonitoredWallet.
     */
    data: XOR<MonitoredWalletCreateInput, MonitoredWalletUncheckedCreateInput>
  }

  /**
   * MonitoredWallet createMany
   */
  export type MonitoredWalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MonitoredWallets.
     */
    data: MonitoredWalletCreateManyInput | MonitoredWalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MonitoredWallet createManyAndReturn
   */
  export type MonitoredWalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredWallet
     */
    select?: MonitoredWalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoredWallet
     */
    omit?: MonitoredWalletOmit<ExtArgs> | null
    /**
     * The data used to create many MonitoredWallets.
     */
    data: MonitoredWalletCreateManyInput | MonitoredWalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredWalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MonitoredWallet update
   */
  export type MonitoredWalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredWallet
     */
    select?: MonitoredWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoredWallet
     */
    omit?: MonitoredWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredWalletInclude<ExtArgs> | null
    /**
     * The data needed to update a MonitoredWallet.
     */
    data: XOR<MonitoredWalletUpdateInput, MonitoredWalletUncheckedUpdateInput>
    /**
     * Choose, which MonitoredWallet to update.
     */
    where: MonitoredWalletWhereUniqueInput
  }

  /**
   * MonitoredWallet updateMany
   */
  export type MonitoredWalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MonitoredWallets.
     */
    data: XOR<MonitoredWalletUpdateManyMutationInput, MonitoredWalletUncheckedUpdateManyInput>
    /**
     * Filter which MonitoredWallets to update
     */
    where?: MonitoredWalletWhereInput
    /**
     * Limit how many MonitoredWallets to update.
     */
    limit?: number
  }

  /**
   * MonitoredWallet updateManyAndReturn
   */
  export type MonitoredWalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredWallet
     */
    select?: MonitoredWalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoredWallet
     */
    omit?: MonitoredWalletOmit<ExtArgs> | null
    /**
     * The data used to update MonitoredWallets.
     */
    data: XOR<MonitoredWalletUpdateManyMutationInput, MonitoredWalletUncheckedUpdateManyInput>
    /**
     * Filter which MonitoredWallets to update
     */
    where?: MonitoredWalletWhereInput
    /**
     * Limit how many MonitoredWallets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredWalletIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MonitoredWallet upsert
   */
  export type MonitoredWalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredWallet
     */
    select?: MonitoredWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoredWallet
     */
    omit?: MonitoredWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredWalletInclude<ExtArgs> | null
    /**
     * The filter to search for the MonitoredWallet to update in case it exists.
     */
    where: MonitoredWalletWhereUniqueInput
    /**
     * In case the MonitoredWallet found by the `where` argument doesn't exist, create a new MonitoredWallet with this data.
     */
    create: XOR<MonitoredWalletCreateInput, MonitoredWalletUncheckedCreateInput>
    /**
     * In case the MonitoredWallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MonitoredWalletUpdateInput, MonitoredWalletUncheckedUpdateInput>
  }

  /**
   * MonitoredWallet delete
   */
  export type MonitoredWalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredWallet
     */
    select?: MonitoredWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoredWallet
     */
    omit?: MonitoredWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredWalletInclude<ExtArgs> | null
    /**
     * Filter which MonitoredWallet to delete.
     */
    where: MonitoredWalletWhereUniqueInput
  }

  /**
   * MonitoredWallet deleteMany
   */
  export type MonitoredWalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonitoredWallets to delete
     */
    where?: MonitoredWalletWhereInput
    /**
     * Limit how many MonitoredWallets to delete.
     */
    limit?: number
  }

  /**
   * MonitoredWallet without action
   */
  export type MonitoredWalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredWallet
     */
    select?: MonitoredWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoredWallet
     */
    omit?: MonitoredWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredWalletInclude<ExtArgs> | null
  }


  /**
   * Model PolymarketActivity
   */

  export type AggregatePolymarketActivity = {
    _count: PolymarketActivityCountAggregateOutputType | null
    _avg: PolymarketActivityAvgAggregateOutputType | null
    _sum: PolymarketActivitySumAggregateOutputType | null
    _min: PolymarketActivityMinAggregateOutputType | null
    _max: PolymarketActivityMaxAggregateOutputType | null
  }

  export type PolymarketActivityAvgAggregateOutputType = {
    timestamp: number | null
    size: number | null
    usdcSize: number | null
    price: number | null
    outcomeIndex: number | null
  }

  export type PolymarketActivitySumAggregateOutputType = {
    timestamp: number | null
    size: number | null
    usdcSize: number | null
    price: number | null
    outcomeIndex: number | null
  }

  export type PolymarketActivityMinAggregateOutputType = {
    id: string | null
    proxyWallet: string | null
    timestamp: number | null
    conditionId: string | null
    type: string | null
    size: number | null
    usdcSize: number | null
    transactionHash: string | null
    price: number | null
    asset: string | null
    side: string | null
    outcomeIndex: number | null
    title: string | null
    slug: string | null
    icon: string | null
    eventSlug: string | null
    outcome: string | null
    processed: boolean | null
    notificationSent: boolean | null
    createdAt: Date | null
  }

  export type PolymarketActivityMaxAggregateOutputType = {
    id: string | null
    proxyWallet: string | null
    timestamp: number | null
    conditionId: string | null
    type: string | null
    size: number | null
    usdcSize: number | null
    transactionHash: string | null
    price: number | null
    asset: string | null
    side: string | null
    outcomeIndex: number | null
    title: string | null
    slug: string | null
    icon: string | null
    eventSlug: string | null
    outcome: string | null
    processed: boolean | null
    notificationSent: boolean | null
    createdAt: Date | null
  }

  export type PolymarketActivityCountAggregateOutputType = {
    id: number
    proxyWallet: number
    timestamp: number
    conditionId: number
    type: number
    size: number
    usdcSize: number
    transactionHash: number
    price: number
    asset: number
    side: number
    outcomeIndex: number
    title: number
    slug: number
    icon: number
    eventSlug: number
    outcome: number
    processed: number
    notificationSent: number
    createdAt: number
    _all: number
  }


  export type PolymarketActivityAvgAggregateInputType = {
    timestamp?: true
    size?: true
    usdcSize?: true
    price?: true
    outcomeIndex?: true
  }

  export type PolymarketActivitySumAggregateInputType = {
    timestamp?: true
    size?: true
    usdcSize?: true
    price?: true
    outcomeIndex?: true
  }

  export type PolymarketActivityMinAggregateInputType = {
    id?: true
    proxyWallet?: true
    timestamp?: true
    conditionId?: true
    type?: true
    size?: true
    usdcSize?: true
    transactionHash?: true
    price?: true
    asset?: true
    side?: true
    outcomeIndex?: true
    title?: true
    slug?: true
    icon?: true
    eventSlug?: true
    outcome?: true
    processed?: true
    notificationSent?: true
    createdAt?: true
  }

  export type PolymarketActivityMaxAggregateInputType = {
    id?: true
    proxyWallet?: true
    timestamp?: true
    conditionId?: true
    type?: true
    size?: true
    usdcSize?: true
    transactionHash?: true
    price?: true
    asset?: true
    side?: true
    outcomeIndex?: true
    title?: true
    slug?: true
    icon?: true
    eventSlug?: true
    outcome?: true
    processed?: true
    notificationSent?: true
    createdAt?: true
  }

  export type PolymarketActivityCountAggregateInputType = {
    id?: true
    proxyWallet?: true
    timestamp?: true
    conditionId?: true
    type?: true
    size?: true
    usdcSize?: true
    transactionHash?: true
    price?: true
    asset?: true
    side?: true
    outcomeIndex?: true
    title?: true
    slug?: true
    icon?: true
    eventSlug?: true
    outcome?: true
    processed?: true
    notificationSent?: true
    createdAt?: true
    _all?: true
  }

  export type PolymarketActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PolymarketActivity to aggregate.
     */
    where?: PolymarketActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolymarketActivities to fetch.
     */
    orderBy?: PolymarketActivityOrderByWithRelationInput | PolymarketActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PolymarketActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolymarketActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolymarketActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PolymarketActivities
    **/
    _count?: true | PolymarketActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PolymarketActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PolymarketActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolymarketActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolymarketActivityMaxAggregateInputType
  }

  export type GetPolymarketActivityAggregateType<T extends PolymarketActivityAggregateArgs> = {
        [P in keyof T & keyof AggregatePolymarketActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolymarketActivity[P]>
      : GetScalarType<T[P], AggregatePolymarketActivity[P]>
  }




  export type PolymarketActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolymarketActivityWhereInput
    orderBy?: PolymarketActivityOrderByWithAggregationInput | PolymarketActivityOrderByWithAggregationInput[]
    by: PolymarketActivityScalarFieldEnum[] | PolymarketActivityScalarFieldEnum
    having?: PolymarketActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolymarketActivityCountAggregateInputType | true
    _avg?: PolymarketActivityAvgAggregateInputType
    _sum?: PolymarketActivitySumAggregateInputType
    _min?: PolymarketActivityMinAggregateInputType
    _max?: PolymarketActivityMaxAggregateInputType
  }

  export type PolymarketActivityGroupByOutputType = {
    id: string
    proxyWallet: string
    timestamp: number
    conditionId: string
    type: string
    size: number
    usdcSize: number
    transactionHash: string
    price: number | null
    asset: string | null
    side: string | null
    outcomeIndex: number | null
    title: string
    slug: string
    icon: string | null
    eventSlug: string | null
    outcome: string | null
    processed: boolean
    notificationSent: boolean
    createdAt: Date
    _count: PolymarketActivityCountAggregateOutputType | null
    _avg: PolymarketActivityAvgAggregateOutputType | null
    _sum: PolymarketActivitySumAggregateOutputType | null
    _min: PolymarketActivityMinAggregateOutputType | null
    _max: PolymarketActivityMaxAggregateOutputType | null
  }

  type GetPolymarketActivityGroupByPayload<T extends PolymarketActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PolymarketActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolymarketActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolymarketActivityGroupByOutputType[P]>
            : GetScalarType<T[P], PolymarketActivityGroupByOutputType[P]>
        }
      >
    >


  export type PolymarketActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proxyWallet?: boolean
    timestamp?: boolean
    conditionId?: boolean
    type?: boolean
    size?: boolean
    usdcSize?: boolean
    transactionHash?: boolean
    price?: boolean
    asset?: boolean
    side?: boolean
    outcomeIndex?: boolean
    title?: boolean
    slug?: boolean
    icon?: boolean
    eventSlug?: boolean
    outcome?: boolean
    processed?: boolean
    notificationSent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["polymarketActivity"]>

  export type PolymarketActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proxyWallet?: boolean
    timestamp?: boolean
    conditionId?: boolean
    type?: boolean
    size?: boolean
    usdcSize?: boolean
    transactionHash?: boolean
    price?: boolean
    asset?: boolean
    side?: boolean
    outcomeIndex?: boolean
    title?: boolean
    slug?: boolean
    icon?: boolean
    eventSlug?: boolean
    outcome?: boolean
    processed?: boolean
    notificationSent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["polymarketActivity"]>

  export type PolymarketActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proxyWallet?: boolean
    timestamp?: boolean
    conditionId?: boolean
    type?: boolean
    size?: boolean
    usdcSize?: boolean
    transactionHash?: boolean
    price?: boolean
    asset?: boolean
    side?: boolean
    outcomeIndex?: boolean
    title?: boolean
    slug?: boolean
    icon?: boolean
    eventSlug?: boolean
    outcome?: boolean
    processed?: boolean
    notificationSent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["polymarketActivity"]>

  export type PolymarketActivitySelectScalar = {
    id?: boolean
    proxyWallet?: boolean
    timestamp?: boolean
    conditionId?: boolean
    type?: boolean
    size?: boolean
    usdcSize?: boolean
    transactionHash?: boolean
    price?: boolean
    asset?: boolean
    side?: boolean
    outcomeIndex?: boolean
    title?: boolean
    slug?: boolean
    icon?: boolean
    eventSlug?: boolean
    outcome?: boolean
    processed?: boolean
    notificationSent?: boolean
    createdAt?: boolean
  }

  export type PolymarketActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "proxyWallet" | "timestamp" | "conditionId" | "type" | "size" | "usdcSize" | "transactionHash" | "price" | "asset" | "side" | "outcomeIndex" | "title" | "slug" | "icon" | "eventSlug" | "outcome" | "processed" | "notificationSent" | "createdAt", ExtArgs["result"]["polymarketActivity"]>

  export type $PolymarketActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PolymarketActivity"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      proxyWallet: string
      timestamp: number
      conditionId: string
      type: string
      size: number
      usdcSize: number
      transactionHash: string
      price: number | null
      asset: string | null
      side: string | null
      outcomeIndex: number | null
      title: string
      slug: string
      icon: string | null
      eventSlug: string | null
      outcome: string | null
      processed: boolean
      notificationSent: boolean
      createdAt: Date
    }, ExtArgs["result"]["polymarketActivity"]>
    composites: {}
  }

  type PolymarketActivityGetPayload<S extends boolean | null | undefined | PolymarketActivityDefaultArgs> = $Result.GetResult<Prisma.$PolymarketActivityPayload, S>

  type PolymarketActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PolymarketActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PolymarketActivityCountAggregateInputType | true
    }

  export interface PolymarketActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PolymarketActivity'], meta: { name: 'PolymarketActivity' } }
    /**
     * Find zero or one PolymarketActivity that matches the filter.
     * @param {PolymarketActivityFindUniqueArgs} args - Arguments to find a PolymarketActivity
     * @example
     * // Get one PolymarketActivity
     * const polymarketActivity = await prisma.polymarketActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PolymarketActivityFindUniqueArgs>(args: SelectSubset<T, PolymarketActivityFindUniqueArgs<ExtArgs>>): Prisma__PolymarketActivityClient<$Result.GetResult<Prisma.$PolymarketActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PolymarketActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PolymarketActivityFindUniqueOrThrowArgs} args - Arguments to find a PolymarketActivity
     * @example
     * // Get one PolymarketActivity
     * const polymarketActivity = await prisma.polymarketActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PolymarketActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, PolymarketActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PolymarketActivityClient<$Result.GetResult<Prisma.$PolymarketActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PolymarketActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolymarketActivityFindFirstArgs} args - Arguments to find a PolymarketActivity
     * @example
     * // Get one PolymarketActivity
     * const polymarketActivity = await prisma.polymarketActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PolymarketActivityFindFirstArgs>(args?: SelectSubset<T, PolymarketActivityFindFirstArgs<ExtArgs>>): Prisma__PolymarketActivityClient<$Result.GetResult<Prisma.$PolymarketActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PolymarketActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolymarketActivityFindFirstOrThrowArgs} args - Arguments to find a PolymarketActivity
     * @example
     * // Get one PolymarketActivity
     * const polymarketActivity = await prisma.polymarketActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PolymarketActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, PolymarketActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__PolymarketActivityClient<$Result.GetResult<Prisma.$PolymarketActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PolymarketActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolymarketActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PolymarketActivities
     * const polymarketActivities = await prisma.polymarketActivity.findMany()
     * 
     * // Get first 10 PolymarketActivities
     * const polymarketActivities = await prisma.polymarketActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const polymarketActivityWithIdOnly = await prisma.polymarketActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PolymarketActivityFindManyArgs>(args?: SelectSubset<T, PolymarketActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolymarketActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PolymarketActivity.
     * @param {PolymarketActivityCreateArgs} args - Arguments to create a PolymarketActivity.
     * @example
     * // Create one PolymarketActivity
     * const PolymarketActivity = await prisma.polymarketActivity.create({
     *   data: {
     *     // ... data to create a PolymarketActivity
     *   }
     * })
     * 
     */
    create<T extends PolymarketActivityCreateArgs>(args: SelectSubset<T, PolymarketActivityCreateArgs<ExtArgs>>): Prisma__PolymarketActivityClient<$Result.GetResult<Prisma.$PolymarketActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PolymarketActivities.
     * @param {PolymarketActivityCreateManyArgs} args - Arguments to create many PolymarketActivities.
     * @example
     * // Create many PolymarketActivities
     * const polymarketActivity = await prisma.polymarketActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PolymarketActivityCreateManyArgs>(args?: SelectSubset<T, PolymarketActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PolymarketActivities and returns the data saved in the database.
     * @param {PolymarketActivityCreateManyAndReturnArgs} args - Arguments to create many PolymarketActivities.
     * @example
     * // Create many PolymarketActivities
     * const polymarketActivity = await prisma.polymarketActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PolymarketActivities and only return the `id`
     * const polymarketActivityWithIdOnly = await prisma.polymarketActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PolymarketActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, PolymarketActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolymarketActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PolymarketActivity.
     * @param {PolymarketActivityDeleteArgs} args - Arguments to delete one PolymarketActivity.
     * @example
     * // Delete one PolymarketActivity
     * const PolymarketActivity = await prisma.polymarketActivity.delete({
     *   where: {
     *     // ... filter to delete one PolymarketActivity
     *   }
     * })
     * 
     */
    delete<T extends PolymarketActivityDeleteArgs>(args: SelectSubset<T, PolymarketActivityDeleteArgs<ExtArgs>>): Prisma__PolymarketActivityClient<$Result.GetResult<Prisma.$PolymarketActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PolymarketActivity.
     * @param {PolymarketActivityUpdateArgs} args - Arguments to update one PolymarketActivity.
     * @example
     * // Update one PolymarketActivity
     * const polymarketActivity = await prisma.polymarketActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PolymarketActivityUpdateArgs>(args: SelectSubset<T, PolymarketActivityUpdateArgs<ExtArgs>>): Prisma__PolymarketActivityClient<$Result.GetResult<Prisma.$PolymarketActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PolymarketActivities.
     * @param {PolymarketActivityDeleteManyArgs} args - Arguments to filter PolymarketActivities to delete.
     * @example
     * // Delete a few PolymarketActivities
     * const { count } = await prisma.polymarketActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PolymarketActivityDeleteManyArgs>(args?: SelectSubset<T, PolymarketActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PolymarketActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolymarketActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PolymarketActivities
     * const polymarketActivity = await prisma.polymarketActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PolymarketActivityUpdateManyArgs>(args: SelectSubset<T, PolymarketActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PolymarketActivities and returns the data updated in the database.
     * @param {PolymarketActivityUpdateManyAndReturnArgs} args - Arguments to update many PolymarketActivities.
     * @example
     * // Update many PolymarketActivities
     * const polymarketActivity = await prisma.polymarketActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PolymarketActivities and only return the `id`
     * const polymarketActivityWithIdOnly = await prisma.polymarketActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PolymarketActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, PolymarketActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolymarketActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PolymarketActivity.
     * @param {PolymarketActivityUpsertArgs} args - Arguments to update or create a PolymarketActivity.
     * @example
     * // Update or create a PolymarketActivity
     * const polymarketActivity = await prisma.polymarketActivity.upsert({
     *   create: {
     *     // ... data to create a PolymarketActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PolymarketActivity we want to update
     *   }
     * })
     */
    upsert<T extends PolymarketActivityUpsertArgs>(args: SelectSubset<T, PolymarketActivityUpsertArgs<ExtArgs>>): Prisma__PolymarketActivityClient<$Result.GetResult<Prisma.$PolymarketActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PolymarketActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolymarketActivityCountArgs} args - Arguments to filter PolymarketActivities to count.
     * @example
     * // Count the number of PolymarketActivities
     * const count = await prisma.polymarketActivity.count({
     *   where: {
     *     // ... the filter for the PolymarketActivities we want to count
     *   }
     * })
    **/
    count<T extends PolymarketActivityCountArgs>(
      args?: Subset<T, PolymarketActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolymarketActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PolymarketActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolymarketActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolymarketActivityAggregateArgs>(args: Subset<T, PolymarketActivityAggregateArgs>): Prisma.PrismaPromise<GetPolymarketActivityAggregateType<T>>

    /**
     * Group by PolymarketActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolymarketActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PolymarketActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PolymarketActivityGroupByArgs['orderBy'] }
        : { orderBy?: PolymarketActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PolymarketActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolymarketActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PolymarketActivity model
   */
  readonly fields: PolymarketActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PolymarketActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PolymarketActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PolymarketActivity model
   */
  interface PolymarketActivityFieldRefs {
    readonly id: FieldRef<"PolymarketActivity", 'String'>
    readonly proxyWallet: FieldRef<"PolymarketActivity", 'String'>
    readonly timestamp: FieldRef<"PolymarketActivity", 'Int'>
    readonly conditionId: FieldRef<"PolymarketActivity", 'String'>
    readonly type: FieldRef<"PolymarketActivity", 'String'>
    readonly size: FieldRef<"PolymarketActivity", 'Float'>
    readonly usdcSize: FieldRef<"PolymarketActivity", 'Float'>
    readonly transactionHash: FieldRef<"PolymarketActivity", 'String'>
    readonly price: FieldRef<"PolymarketActivity", 'Float'>
    readonly asset: FieldRef<"PolymarketActivity", 'String'>
    readonly side: FieldRef<"PolymarketActivity", 'String'>
    readonly outcomeIndex: FieldRef<"PolymarketActivity", 'Int'>
    readonly title: FieldRef<"PolymarketActivity", 'String'>
    readonly slug: FieldRef<"PolymarketActivity", 'String'>
    readonly icon: FieldRef<"PolymarketActivity", 'String'>
    readonly eventSlug: FieldRef<"PolymarketActivity", 'String'>
    readonly outcome: FieldRef<"PolymarketActivity", 'String'>
    readonly processed: FieldRef<"PolymarketActivity", 'Boolean'>
    readonly notificationSent: FieldRef<"PolymarketActivity", 'Boolean'>
    readonly createdAt: FieldRef<"PolymarketActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PolymarketActivity findUnique
   */
  export type PolymarketActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolymarketActivity
     */
    select?: PolymarketActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolymarketActivity
     */
    omit?: PolymarketActivityOmit<ExtArgs> | null
    /**
     * Filter, which PolymarketActivity to fetch.
     */
    where: PolymarketActivityWhereUniqueInput
  }

  /**
   * PolymarketActivity findUniqueOrThrow
   */
  export type PolymarketActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolymarketActivity
     */
    select?: PolymarketActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolymarketActivity
     */
    omit?: PolymarketActivityOmit<ExtArgs> | null
    /**
     * Filter, which PolymarketActivity to fetch.
     */
    where: PolymarketActivityWhereUniqueInput
  }

  /**
   * PolymarketActivity findFirst
   */
  export type PolymarketActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolymarketActivity
     */
    select?: PolymarketActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolymarketActivity
     */
    omit?: PolymarketActivityOmit<ExtArgs> | null
    /**
     * Filter, which PolymarketActivity to fetch.
     */
    where?: PolymarketActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolymarketActivities to fetch.
     */
    orderBy?: PolymarketActivityOrderByWithRelationInput | PolymarketActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PolymarketActivities.
     */
    cursor?: PolymarketActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolymarketActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolymarketActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PolymarketActivities.
     */
    distinct?: PolymarketActivityScalarFieldEnum | PolymarketActivityScalarFieldEnum[]
  }

  /**
   * PolymarketActivity findFirstOrThrow
   */
  export type PolymarketActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolymarketActivity
     */
    select?: PolymarketActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolymarketActivity
     */
    omit?: PolymarketActivityOmit<ExtArgs> | null
    /**
     * Filter, which PolymarketActivity to fetch.
     */
    where?: PolymarketActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolymarketActivities to fetch.
     */
    orderBy?: PolymarketActivityOrderByWithRelationInput | PolymarketActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PolymarketActivities.
     */
    cursor?: PolymarketActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolymarketActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolymarketActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PolymarketActivities.
     */
    distinct?: PolymarketActivityScalarFieldEnum | PolymarketActivityScalarFieldEnum[]
  }

  /**
   * PolymarketActivity findMany
   */
  export type PolymarketActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolymarketActivity
     */
    select?: PolymarketActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolymarketActivity
     */
    omit?: PolymarketActivityOmit<ExtArgs> | null
    /**
     * Filter, which PolymarketActivities to fetch.
     */
    where?: PolymarketActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolymarketActivities to fetch.
     */
    orderBy?: PolymarketActivityOrderByWithRelationInput | PolymarketActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PolymarketActivities.
     */
    cursor?: PolymarketActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolymarketActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolymarketActivities.
     */
    skip?: number
    distinct?: PolymarketActivityScalarFieldEnum | PolymarketActivityScalarFieldEnum[]
  }

  /**
   * PolymarketActivity create
   */
  export type PolymarketActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolymarketActivity
     */
    select?: PolymarketActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolymarketActivity
     */
    omit?: PolymarketActivityOmit<ExtArgs> | null
    /**
     * The data needed to create a PolymarketActivity.
     */
    data: XOR<PolymarketActivityCreateInput, PolymarketActivityUncheckedCreateInput>
  }

  /**
   * PolymarketActivity createMany
   */
  export type PolymarketActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PolymarketActivities.
     */
    data: PolymarketActivityCreateManyInput | PolymarketActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PolymarketActivity createManyAndReturn
   */
  export type PolymarketActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolymarketActivity
     */
    select?: PolymarketActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PolymarketActivity
     */
    omit?: PolymarketActivityOmit<ExtArgs> | null
    /**
     * The data used to create many PolymarketActivities.
     */
    data: PolymarketActivityCreateManyInput | PolymarketActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PolymarketActivity update
   */
  export type PolymarketActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolymarketActivity
     */
    select?: PolymarketActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolymarketActivity
     */
    omit?: PolymarketActivityOmit<ExtArgs> | null
    /**
     * The data needed to update a PolymarketActivity.
     */
    data: XOR<PolymarketActivityUpdateInput, PolymarketActivityUncheckedUpdateInput>
    /**
     * Choose, which PolymarketActivity to update.
     */
    where: PolymarketActivityWhereUniqueInput
  }

  /**
   * PolymarketActivity updateMany
   */
  export type PolymarketActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PolymarketActivities.
     */
    data: XOR<PolymarketActivityUpdateManyMutationInput, PolymarketActivityUncheckedUpdateManyInput>
    /**
     * Filter which PolymarketActivities to update
     */
    where?: PolymarketActivityWhereInput
    /**
     * Limit how many PolymarketActivities to update.
     */
    limit?: number
  }

  /**
   * PolymarketActivity updateManyAndReturn
   */
  export type PolymarketActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolymarketActivity
     */
    select?: PolymarketActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PolymarketActivity
     */
    omit?: PolymarketActivityOmit<ExtArgs> | null
    /**
     * The data used to update PolymarketActivities.
     */
    data: XOR<PolymarketActivityUpdateManyMutationInput, PolymarketActivityUncheckedUpdateManyInput>
    /**
     * Filter which PolymarketActivities to update
     */
    where?: PolymarketActivityWhereInput
    /**
     * Limit how many PolymarketActivities to update.
     */
    limit?: number
  }

  /**
   * PolymarketActivity upsert
   */
  export type PolymarketActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolymarketActivity
     */
    select?: PolymarketActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolymarketActivity
     */
    omit?: PolymarketActivityOmit<ExtArgs> | null
    /**
     * The filter to search for the PolymarketActivity to update in case it exists.
     */
    where: PolymarketActivityWhereUniqueInput
    /**
     * In case the PolymarketActivity found by the `where` argument doesn't exist, create a new PolymarketActivity with this data.
     */
    create: XOR<PolymarketActivityCreateInput, PolymarketActivityUncheckedCreateInput>
    /**
     * In case the PolymarketActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PolymarketActivityUpdateInput, PolymarketActivityUncheckedUpdateInput>
  }

  /**
   * PolymarketActivity delete
   */
  export type PolymarketActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolymarketActivity
     */
    select?: PolymarketActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolymarketActivity
     */
    omit?: PolymarketActivityOmit<ExtArgs> | null
    /**
     * Filter which PolymarketActivity to delete.
     */
    where: PolymarketActivityWhereUniqueInput
  }

  /**
   * PolymarketActivity deleteMany
   */
  export type PolymarketActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PolymarketActivities to delete
     */
    where?: PolymarketActivityWhereInput
    /**
     * Limit how many PolymarketActivities to delete.
     */
    limit?: number
  }

  /**
   * PolymarketActivity without action
   */
  export type PolymarketActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolymarketActivity
     */
    select?: PolymarketActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolymarketActivity
     */
    omit?: PolymarketActivityOmit<ExtArgs> | null
  }


  /**
   * Model MonitoringJobLog
   */

  export type AggregateMonitoringJobLog = {
    _count: MonitoringJobLogCountAggregateOutputType | null
    _avg: MonitoringJobLogAvgAggregateOutputType | null
    _sum: MonitoringJobLogSumAggregateOutputType | null
    _min: MonitoringJobLogMinAggregateOutputType | null
    _max: MonitoringJobLogMaxAggregateOutputType | null
  }

  export type MonitoringJobLogAvgAggregateOutputType = {
    walletsChecked: number | null
    activitiesFound: number | null
    activitiesProcessed: number | null
    notificationsQueued: number | null
    duration: number | null
  }

  export type MonitoringJobLogSumAggregateOutputType = {
    walletsChecked: number | null
    activitiesFound: number | null
    activitiesProcessed: number | null
    notificationsQueued: number | null
    duration: number | null
  }

  export type MonitoringJobLogMinAggregateOutputType = {
    id: string | null
    jobType: string | null
    status: string | null
    walletsChecked: number | null
    activitiesFound: number | null
    activitiesProcessed: number | null
    notificationsQueued: number | null
    duration: number | null
    error: string | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type MonitoringJobLogMaxAggregateOutputType = {
    id: string | null
    jobType: string | null
    status: string | null
    walletsChecked: number | null
    activitiesFound: number | null
    activitiesProcessed: number | null
    notificationsQueued: number | null
    duration: number | null
    error: string | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type MonitoringJobLogCountAggregateOutputType = {
    id: number
    jobType: number
    status: number
    walletsChecked: number
    activitiesFound: number
    activitiesProcessed: number
    notificationsQueued: number
    duration: number
    error: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type MonitoringJobLogAvgAggregateInputType = {
    walletsChecked?: true
    activitiesFound?: true
    activitiesProcessed?: true
    notificationsQueued?: true
    duration?: true
  }

  export type MonitoringJobLogSumAggregateInputType = {
    walletsChecked?: true
    activitiesFound?: true
    activitiesProcessed?: true
    notificationsQueued?: true
    duration?: true
  }

  export type MonitoringJobLogMinAggregateInputType = {
    id?: true
    jobType?: true
    status?: true
    walletsChecked?: true
    activitiesFound?: true
    activitiesProcessed?: true
    notificationsQueued?: true
    duration?: true
    error?: true
    startedAt?: true
    completedAt?: true
  }

  export type MonitoringJobLogMaxAggregateInputType = {
    id?: true
    jobType?: true
    status?: true
    walletsChecked?: true
    activitiesFound?: true
    activitiesProcessed?: true
    notificationsQueued?: true
    duration?: true
    error?: true
    startedAt?: true
    completedAt?: true
  }

  export type MonitoringJobLogCountAggregateInputType = {
    id?: true
    jobType?: true
    status?: true
    walletsChecked?: true
    activitiesFound?: true
    activitiesProcessed?: true
    notificationsQueued?: true
    duration?: true
    error?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type MonitoringJobLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonitoringJobLog to aggregate.
     */
    where?: MonitoringJobLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitoringJobLogs to fetch.
     */
    orderBy?: MonitoringJobLogOrderByWithRelationInput | MonitoringJobLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MonitoringJobLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitoringJobLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitoringJobLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MonitoringJobLogs
    **/
    _count?: true | MonitoringJobLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonitoringJobLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonitoringJobLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonitoringJobLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonitoringJobLogMaxAggregateInputType
  }

  export type GetMonitoringJobLogAggregateType<T extends MonitoringJobLogAggregateArgs> = {
        [P in keyof T & keyof AggregateMonitoringJobLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonitoringJobLog[P]>
      : GetScalarType<T[P], AggregateMonitoringJobLog[P]>
  }




  export type MonitoringJobLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonitoringJobLogWhereInput
    orderBy?: MonitoringJobLogOrderByWithAggregationInput | MonitoringJobLogOrderByWithAggregationInput[]
    by: MonitoringJobLogScalarFieldEnum[] | MonitoringJobLogScalarFieldEnum
    having?: MonitoringJobLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonitoringJobLogCountAggregateInputType | true
    _avg?: MonitoringJobLogAvgAggregateInputType
    _sum?: MonitoringJobLogSumAggregateInputType
    _min?: MonitoringJobLogMinAggregateInputType
    _max?: MonitoringJobLogMaxAggregateInputType
  }

  export type MonitoringJobLogGroupByOutputType = {
    id: string
    jobType: string
    status: string
    walletsChecked: number
    activitiesFound: number
    activitiesProcessed: number
    notificationsQueued: number
    duration: number | null
    error: string | null
    startedAt: Date
    completedAt: Date | null
    _count: MonitoringJobLogCountAggregateOutputType | null
    _avg: MonitoringJobLogAvgAggregateOutputType | null
    _sum: MonitoringJobLogSumAggregateOutputType | null
    _min: MonitoringJobLogMinAggregateOutputType | null
    _max: MonitoringJobLogMaxAggregateOutputType | null
  }

  type GetMonitoringJobLogGroupByPayload<T extends MonitoringJobLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonitoringJobLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonitoringJobLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonitoringJobLogGroupByOutputType[P]>
            : GetScalarType<T[P], MonitoringJobLogGroupByOutputType[P]>
        }
      >
    >


  export type MonitoringJobLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobType?: boolean
    status?: boolean
    walletsChecked?: boolean
    activitiesFound?: boolean
    activitiesProcessed?: boolean
    notificationsQueued?: boolean
    duration?: boolean
    error?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["monitoringJobLog"]>

  export type MonitoringJobLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobType?: boolean
    status?: boolean
    walletsChecked?: boolean
    activitiesFound?: boolean
    activitiesProcessed?: boolean
    notificationsQueued?: boolean
    duration?: boolean
    error?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["monitoringJobLog"]>

  export type MonitoringJobLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobType?: boolean
    status?: boolean
    walletsChecked?: boolean
    activitiesFound?: boolean
    activitiesProcessed?: boolean
    notificationsQueued?: boolean
    duration?: boolean
    error?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["monitoringJobLog"]>

  export type MonitoringJobLogSelectScalar = {
    id?: boolean
    jobType?: boolean
    status?: boolean
    walletsChecked?: boolean
    activitiesFound?: boolean
    activitiesProcessed?: boolean
    notificationsQueued?: boolean
    duration?: boolean
    error?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type MonitoringJobLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobType" | "status" | "walletsChecked" | "activitiesFound" | "activitiesProcessed" | "notificationsQueued" | "duration" | "error" | "startedAt" | "completedAt", ExtArgs["result"]["monitoringJobLog"]>

  export type $MonitoringJobLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MonitoringJobLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobType: string
      status: string
      walletsChecked: number
      activitiesFound: number
      activitiesProcessed: number
      notificationsQueued: number
      duration: number | null
      error: string | null
      startedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["monitoringJobLog"]>
    composites: {}
  }

  type MonitoringJobLogGetPayload<S extends boolean | null | undefined | MonitoringJobLogDefaultArgs> = $Result.GetResult<Prisma.$MonitoringJobLogPayload, S>

  type MonitoringJobLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MonitoringJobLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MonitoringJobLogCountAggregateInputType | true
    }

  export interface MonitoringJobLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MonitoringJobLog'], meta: { name: 'MonitoringJobLog' } }
    /**
     * Find zero or one MonitoringJobLog that matches the filter.
     * @param {MonitoringJobLogFindUniqueArgs} args - Arguments to find a MonitoringJobLog
     * @example
     * // Get one MonitoringJobLog
     * const monitoringJobLog = await prisma.monitoringJobLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MonitoringJobLogFindUniqueArgs>(args: SelectSubset<T, MonitoringJobLogFindUniqueArgs<ExtArgs>>): Prisma__MonitoringJobLogClient<$Result.GetResult<Prisma.$MonitoringJobLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MonitoringJobLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MonitoringJobLogFindUniqueOrThrowArgs} args - Arguments to find a MonitoringJobLog
     * @example
     * // Get one MonitoringJobLog
     * const monitoringJobLog = await prisma.monitoringJobLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MonitoringJobLogFindUniqueOrThrowArgs>(args: SelectSubset<T, MonitoringJobLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MonitoringJobLogClient<$Result.GetResult<Prisma.$MonitoringJobLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MonitoringJobLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoringJobLogFindFirstArgs} args - Arguments to find a MonitoringJobLog
     * @example
     * // Get one MonitoringJobLog
     * const monitoringJobLog = await prisma.monitoringJobLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MonitoringJobLogFindFirstArgs>(args?: SelectSubset<T, MonitoringJobLogFindFirstArgs<ExtArgs>>): Prisma__MonitoringJobLogClient<$Result.GetResult<Prisma.$MonitoringJobLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MonitoringJobLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoringJobLogFindFirstOrThrowArgs} args - Arguments to find a MonitoringJobLog
     * @example
     * // Get one MonitoringJobLog
     * const monitoringJobLog = await prisma.monitoringJobLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MonitoringJobLogFindFirstOrThrowArgs>(args?: SelectSubset<T, MonitoringJobLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__MonitoringJobLogClient<$Result.GetResult<Prisma.$MonitoringJobLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MonitoringJobLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoringJobLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MonitoringJobLogs
     * const monitoringJobLogs = await prisma.monitoringJobLog.findMany()
     * 
     * // Get first 10 MonitoringJobLogs
     * const monitoringJobLogs = await prisma.monitoringJobLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monitoringJobLogWithIdOnly = await prisma.monitoringJobLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MonitoringJobLogFindManyArgs>(args?: SelectSubset<T, MonitoringJobLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitoringJobLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MonitoringJobLog.
     * @param {MonitoringJobLogCreateArgs} args - Arguments to create a MonitoringJobLog.
     * @example
     * // Create one MonitoringJobLog
     * const MonitoringJobLog = await prisma.monitoringJobLog.create({
     *   data: {
     *     // ... data to create a MonitoringJobLog
     *   }
     * })
     * 
     */
    create<T extends MonitoringJobLogCreateArgs>(args: SelectSubset<T, MonitoringJobLogCreateArgs<ExtArgs>>): Prisma__MonitoringJobLogClient<$Result.GetResult<Prisma.$MonitoringJobLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MonitoringJobLogs.
     * @param {MonitoringJobLogCreateManyArgs} args - Arguments to create many MonitoringJobLogs.
     * @example
     * // Create many MonitoringJobLogs
     * const monitoringJobLog = await prisma.monitoringJobLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MonitoringJobLogCreateManyArgs>(args?: SelectSubset<T, MonitoringJobLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MonitoringJobLogs and returns the data saved in the database.
     * @param {MonitoringJobLogCreateManyAndReturnArgs} args - Arguments to create many MonitoringJobLogs.
     * @example
     * // Create many MonitoringJobLogs
     * const monitoringJobLog = await prisma.monitoringJobLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MonitoringJobLogs and only return the `id`
     * const monitoringJobLogWithIdOnly = await prisma.monitoringJobLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MonitoringJobLogCreateManyAndReturnArgs>(args?: SelectSubset<T, MonitoringJobLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitoringJobLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MonitoringJobLog.
     * @param {MonitoringJobLogDeleteArgs} args - Arguments to delete one MonitoringJobLog.
     * @example
     * // Delete one MonitoringJobLog
     * const MonitoringJobLog = await prisma.monitoringJobLog.delete({
     *   where: {
     *     // ... filter to delete one MonitoringJobLog
     *   }
     * })
     * 
     */
    delete<T extends MonitoringJobLogDeleteArgs>(args: SelectSubset<T, MonitoringJobLogDeleteArgs<ExtArgs>>): Prisma__MonitoringJobLogClient<$Result.GetResult<Prisma.$MonitoringJobLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MonitoringJobLog.
     * @param {MonitoringJobLogUpdateArgs} args - Arguments to update one MonitoringJobLog.
     * @example
     * // Update one MonitoringJobLog
     * const monitoringJobLog = await prisma.monitoringJobLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MonitoringJobLogUpdateArgs>(args: SelectSubset<T, MonitoringJobLogUpdateArgs<ExtArgs>>): Prisma__MonitoringJobLogClient<$Result.GetResult<Prisma.$MonitoringJobLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MonitoringJobLogs.
     * @param {MonitoringJobLogDeleteManyArgs} args - Arguments to filter MonitoringJobLogs to delete.
     * @example
     * // Delete a few MonitoringJobLogs
     * const { count } = await prisma.monitoringJobLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MonitoringJobLogDeleteManyArgs>(args?: SelectSubset<T, MonitoringJobLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonitoringJobLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoringJobLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MonitoringJobLogs
     * const monitoringJobLog = await prisma.monitoringJobLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MonitoringJobLogUpdateManyArgs>(args: SelectSubset<T, MonitoringJobLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonitoringJobLogs and returns the data updated in the database.
     * @param {MonitoringJobLogUpdateManyAndReturnArgs} args - Arguments to update many MonitoringJobLogs.
     * @example
     * // Update many MonitoringJobLogs
     * const monitoringJobLog = await prisma.monitoringJobLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MonitoringJobLogs and only return the `id`
     * const monitoringJobLogWithIdOnly = await prisma.monitoringJobLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MonitoringJobLogUpdateManyAndReturnArgs>(args: SelectSubset<T, MonitoringJobLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitoringJobLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MonitoringJobLog.
     * @param {MonitoringJobLogUpsertArgs} args - Arguments to update or create a MonitoringJobLog.
     * @example
     * // Update or create a MonitoringJobLog
     * const monitoringJobLog = await prisma.monitoringJobLog.upsert({
     *   create: {
     *     // ... data to create a MonitoringJobLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MonitoringJobLog we want to update
     *   }
     * })
     */
    upsert<T extends MonitoringJobLogUpsertArgs>(args: SelectSubset<T, MonitoringJobLogUpsertArgs<ExtArgs>>): Prisma__MonitoringJobLogClient<$Result.GetResult<Prisma.$MonitoringJobLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MonitoringJobLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoringJobLogCountArgs} args - Arguments to filter MonitoringJobLogs to count.
     * @example
     * // Count the number of MonitoringJobLogs
     * const count = await prisma.monitoringJobLog.count({
     *   where: {
     *     // ... the filter for the MonitoringJobLogs we want to count
     *   }
     * })
    **/
    count<T extends MonitoringJobLogCountArgs>(
      args?: Subset<T, MonitoringJobLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonitoringJobLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MonitoringJobLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoringJobLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonitoringJobLogAggregateArgs>(args: Subset<T, MonitoringJobLogAggregateArgs>): Prisma.PrismaPromise<GetMonitoringJobLogAggregateType<T>>

    /**
     * Group by MonitoringJobLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoringJobLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MonitoringJobLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MonitoringJobLogGroupByArgs['orderBy'] }
        : { orderBy?: MonitoringJobLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MonitoringJobLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonitoringJobLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MonitoringJobLog model
   */
  readonly fields: MonitoringJobLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MonitoringJobLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MonitoringJobLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MonitoringJobLog model
   */
  interface MonitoringJobLogFieldRefs {
    readonly id: FieldRef<"MonitoringJobLog", 'String'>
    readonly jobType: FieldRef<"MonitoringJobLog", 'String'>
    readonly status: FieldRef<"MonitoringJobLog", 'String'>
    readonly walletsChecked: FieldRef<"MonitoringJobLog", 'Int'>
    readonly activitiesFound: FieldRef<"MonitoringJobLog", 'Int'>
    readonly activitiesProcessed: FieldRef<"MonitoringJobLog", 'Int'>
    readonly notificationsQueued: FieldRef<"MonitoringJobLog", 'Int'>
    readonly duration: FieldRef<"MonitoringJobLog", 'Int'>
    readonly error: FieldRef<"MonitoringJobLog", 'String'>
    readonly startedAt: FieldRef<"MonitoringJobLog", 'DateTime'>
    readonly completedAt: FieldRef<"MonitoringJobLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MonitoringJobLog findUnique
   */
  export type MonitoringJobLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoringJobLog
     */
    select?: MonitoringJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoringJobLog
     */
    omit?: MonitoringJobLogOmit<ExtArgs> | null
    /**
     * Filter, which MonitoringJobLog to fetch.
     */
    where: MonitoringJobLogWhereUniqueInput
  }

  /**
   * MonitoringJobLog findUniqueOrThrow
   */
  export type MonitoringJobLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoringJobLog
     */
    select?: MonitoringJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoringJobLog
     */
    omit?: MonitoringJobLogOmit<ExtArgs> | null
    /**
     * Filter, which MonitoringJobLog to fetch.
     */
    where: MonitoringJobLogWhereUniqueInput
  }

  /**
   * MonitoringJobLog findFirst
   */
  export type MonitoringJobLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoringJobLog
     */
    select?: MonitoringJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoringJobLog
     */
    omit?: MonitoringJobLogOmit<ExtArgs> | null
    /**
     * Filter, which MonitoringJobLog to fetch.
     */
    where?: MonitoringJobLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitoringJobLogs to fetch.
     */
    orderBy?: MonitoringJobLogOrderByWithRelationInput | MonitoringJobLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonitoringJobLogs.
     */
    cursor?: MonitoringJobLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitoringJobLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitoringJobLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonitoringJobLogs.
     */
    distinct?: MonitoringJobLogScalarFieldEnum | MonitoringJobLogScalarFieldEnum[]
  }

  /**
   * MonitoringJobLog findFirstOrThrow
   */
  export type MonitoringJobLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoringJobLog
     */
    select?: MonitoringJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoringJobLog
     */
    omit?: MonitoringJobLogOmit<ExtArgs> | null
    /**
     * Filter, which MonitoringJobLog to fetch.
     */
    where?: MonitoringJobLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitoringJobLogs to fetch.
     */
    orderBy?: MonitoringJobLogOrderByWithRelationInput | MonitoringJobLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonitoringJobLogs.
     */
    cursor?: MonitoringJobLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitoringJobLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitoringJobLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonitoringJobLogs.
     */
    distinct?: MonitoringJobLogScalarFieldEnum | MonitoringJobLogScalarFieldEnum[]
  }

  /**
   * MonitoringJobLog findMany
   */
  export type MonitoringJobLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoringJobLog
     */
    select?: MonitoringJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoringJobLog
     */
    omit?: MonitoringJobLogOmit<ExtArgs> | null
    /**
     * Filter, which MonitoringJobLogs to fetch.
     */
    where?: MonitoringJobLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitoringJobLogs to fetch.
     */
    orderBy?: MonitoringJobLogOrderByWithRelationInput | MonitoringJobLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MonitoringJobLogs.
     */
    cursor?: MonitoringJobLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitoringJobLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitoringJobLogs.
     */
    skip?: number
    distinct?: MonitoringJobLogScalarFieldEnum | MonitoringJobLogScalarFieldEnum[]
  }

  /**
   * MonitoringJobLog create
   */
  export type MonitoringJobLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoringJobLog
     */
    select?: MonitoringJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoringJobLog
     */
    omit?: MonitoringJobLogOmit<ExtArgs> | null
    /**
     * The data needed to create a MonitoringJobLog.
     */
    data: XOR<MonitoringJobLogCreateInput, MonitoringJobLogUncheckedCreateInput>
  }

  /**
   * MonitoringJobLog createMany
   */
  export type MonitoringJobLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MonitoringJobLogs.
     */
    data: MonitoringJobLogCreateManyInput | MonitoringJobLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MonitoringJobLog createManyAndReturn
   */
  export type MonitoringJobLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoringJobLog
     */
    select?: MonitoringJobLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoringJobLog
     */
    omit?: MonitoringJobLogOmit<ExtArgs> | null
    /**
     * The data used to create many MonitoringJobLogs.
     */
    data: MonitoringJobLogCreateManyInput | MonitoringJobLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MonitoringJobLog update
   */
  export type MonitoringJobLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoringJobLog
     */
    select?: MonitoringJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoringJobLog
     */
    omit?: MonitoringJobLogOmit<ExtArgs> | null
    /**
     * The data needed to update a MonitoringJobLog.
     */
    data: XOR<MonitoringJobLogUpdateInput, MonitoringJobLogUncheckedUpdateInput>
    /**
     * Choose, which MonitoringJobLog to update.
     */
    where: MonitoringJobLogWhereUniqueInput
  }

  /**
   * MonitoringJobLog updateMany
   */
  export type MonitoringJobLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MonitoringJobLogs.
     */
    data: XOR<MonitoringJobLogUpdateManyMutationInput, MonitoringJobLogUncheckedUpdateManyInput>
    /**
     * Filter which MonitoringJobLogs to update
     */
    where?: MonitoringJobLogWhereInput
    /**
     * Limit how many MonitoringJobLogs to update.
     */
    limit?: number
  }

  /**
   * MonitoringJobLog updateManyAndReturn
   */
  export type MonitoringJobLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoringJobLog
     */
    select?: MonitoringJobLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoringJobLog
     */
    omit?: MonitoringJobLogOmit<ExtArgs> | null
    /**
     * The data used to update MonitoringJobLogs.
     */
    data: XOR<MonitoringJobLogUpdateManyMutationInput, MonitoringJobLogUncheckedUpdateManyInput>
    /**
     * Filter which MonitoringJobLogs to update
     */
    where?: MonitoringJobLogWhereInput
    /**
     * Limit how many MonitoringJobLogs to update.
     */
    limit?: number
  }

  /**
   * MonitoringJobLog upsert
   */
  export type MonitoringJobLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoringJobLog
     */
    select?: MonitoringJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoringJobLog
     */
    omit?: MonitoringJobLogOmit<ExtArgs> | null
    /**
     * The filter to search for the MonitoringJobLog to update in case it exists.
     */
    where: MonitoringJobLogWhereUniqueInput
    /**
     * In case the MonitoringJobLog found by the `where` argument doesn't exist, create a new MonitoringJobLog with this data.
     */
    create: XOR<MonitoringJobLogCreateInput, MonitoringJobLogUncheckedCreateInput>
    /**
     * In case the MonitoringJobLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MonitoringJobLogUpdateInput, MonitoringJobLogUncheckedUpdateInput>
  }

  /**
   * MonitoringJobLog delete
   */
  export type MonitoringJobLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoringJobLog
     */
    select?: MonitoringJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoringJobLog
     */
    omit?: MonitoringJobLogOmit<ExtArgs> | null
    /**
     * Filter which MonitoringJobLog to delete.
     */
    where: MonitoringJobLogWhereUniqueInput
  }

  /**
   * MonitoringJobLog deleteMany
   */
  export type MonitoringJobLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonitoringJobLogs to delete
     */
    where?: MonitoringJobLogWhereInput
    /**
     * Limit how many MonitoringJobLogs to delete.
     */
    limit?: number
  }

  /**
   * MonitoringJobLog without action
   */
  export type MonitoringJobLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoringJobLog
     */
    select?: MonitoringJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonitoringJobLog
     */
    omit?: MonitoringJobLogOmit<ExtArgs> | null
  }


  /**
   * Model NotificationQueue
   */

  export type AggregateNotificationQueue = {
    _count: NotificationQueueCountAggregateOutputType | null
    _avg: NotificationQueueAvgAggregateOutputType | null
    _sum: NotificationQueueSumAggregateOutputType | null
    _min: NotificationQueueMinAggregateOutputType | null
    _max: NotificationQueueMaxAggregateOutputType | null
  }

  export type NotificationQueueAvgAggregateOutputType = {
    attempts: number | null
    maxAttempts: number | null
  }

  export type NotificationQueueSumAggregateOutputType = {
    attempts: number | null
    maxAttempts: number | null
  }

  export type NotificationQueueMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userEmail: string | null
    alertId: string | null
    walletAddress: string | null
    activityId: string | null
    tradeType: string | null
    amount: string | null
    market: string | null
    marketId: string | null
    marketUrl: string | null
    marketIcon: string | null
    notifyVia: string | null
    status: $Enums.NotificationStatus | null
    attempts: number | null
    maxAttempts: number | null
    error: string | null
    scheduledFor: Date | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type NotificationQueueMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userEmail: string | null
    alertId: string | null
    walletAddress: string | null
    activityId: string | null
    tradeType: string | null
    amount: string | null
    market: string | null
    marketId: string | null
    marketUrl: string | null
    marketIcon: string | null
    notifyVia: string | null
    status: $Enums.NotificationStatus | null
    attempts: number | null
    maxAttempts: number | null
    error: string | null
    scheduledFor: Date | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type NotificationQueueCountAggregateOutputType = {
    id: number
    userId: number
    userEmail: number
    alertId: number
    walletAddress: number
    activityId: number
    tradeType: number
    amount: number
    market: number
    marketId: number
    marketUrl: number
    marketIcon: number
    notifyVia: number
    status: number
    attempts: number
    maxAttempts: number
    error: number
    scheduledFor: number
    processedAt: number
    createdAt: number
    _all: number
  }


  export type NotificationQueueAvgAggregateInputType = {
    attempts?: true
    maxAttempts?: true
  }

  export type NotificationQueueSumAggregateInputType = {
    attempts?: true
    maxAttempts?: true
  }

  export type NotificationQueueMinAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    alertId?: true
    walletAddress?: true
    activityId?: true
    tradeType?: true
    amount?: true
    market?: true
    marketId?: true
    marketUrl?: true
    marketIcon?: true
    notifyVia?: true
    status?: true
    attempts?: true
    maxAttempts?: true
    error?: true
    scheduledFor?: true
    processedAt?: true
    createdAt?: true
  }

  export type NotificationQueueMaxAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    alertId?: true
    walletAddress?: true
    activityId?: true
    tradeType?: true
    amount?: true
    market?: true
    marketId?: true
    marketUrl?: true
    marketIcon?: true
    notifyVia?: true
    status?: true
    attempts?: true
    maxAttempts?: true
    error?: true
    scheduledFor?: true
    processedAt?: true
    createdAt?: true
  }

  export type NotificationQueueCountAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    alertId?: true
    walletAddress?: true
    activityId?: true
    tradeType?: true
    amount?: true
    market?: true
    marketId?: true
    marketUrl?: true
    marketIcon?: true
    notifyVia?: true
    status?: true
    attempts?: true
    maxAttempts?: true
    error?: true
    scheduledFor?: true
    processedAt?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationQueue to aggregate.
     */
    where?: NotificationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationQueues to fetch.
     */
    orderBy?: NotificationQueueOrderByWithRelationInput | NotificationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationQueues
    **/
    _count?: true | NotificationQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationQueueMaxAggregateInputType
  }

  export type GetNotificationQueueAggregateType<T extends NotificationQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationQueue[P]>
      : GetScalarType<T[P], AggregateNotificationQueue[P]>
  }




  export type NotificationQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationQueueWhereInput
    orderBy?: NotificationQueueOrderByWithAggregationInput | NotificationQueueOrderByWithAggregationInput[]
    by: NotificationQueueScalarFieldEnum[] | NotificationQueueScalarFieldEnum
    having?: NotificationQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationQueueCountAggregateInputType | true
    _avg?: NotificationQueueAvgAggregateInputType
    _sum?: NotificationQueueSumAggregateInputType
    _min?: NotificationQueueMinAggregateInputType
    _max?: NotificationQueueMaxAggregateInputType
  }

  export type NotificationQueueGroupByOutputType = {
    id: string
    userId: string
    userEmail: string
    alertId: string
    walletAddress: string
    activityId: string | null
    tradeType: string
    amount: string
    market: string
    marketId: string | null
    marketUrl: string | null
    marketIcon: string | null
    notifyVia: string
    status: $Enums.NotificationStatus
    attempts: number
    maxAttempts: number
    error: string | null
    scheduledFor: Date
    processedAt: Date | null
    createdAt: Date
    _count: NotificationQueueCountAggregateOutputType | null
    _avg: NotificationQueueAvgAggregateOutputType | null
    _sum: NotificationQueueSumAggregateOutputType | null
    _min: NotificationQueueMinAggregateOutputType | null
    _max: NotificationQueueMaxAggregateOutputType | null
  }

  type GetNotificationQueueGroupByPayload<T extends NotificationQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationQueueGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationQueueGroupByOutputType[P]>
        }
      >
    >


  export type NotificationQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    alertId?: boolean
    walletAddress?: boolean
    activityId?: boolean
    tradeType?: boolean
    amount?: boolean
    market?: boolean
    marketId?: boolean
    marketUrl?: boolean
    marketIcon?: boolean
    notifyVia?: boolean
    status?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    error?: boolean
    scheduledFor?: boolean
    processedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notificationQueue"]>

  export type NotificationQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    alertId?: boolean
    walletAddress?: boolean
    activityId?: boolean
    tradeType?: boolean
    amount?: boolean
    market?: boolean
    marketId?: boolean
    marketUrl?: boolean
    marketIcon?: boolean
    notifyVia?: boolean
    status?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    error?: boolean
    scheduledFor?: boolean
    processedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notificationQueue"]>

  export type NotificationQueueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    alertId?: boolean
    walletAddress?: boolean
    activityId?: boolean
    tradeType?: boolean
    amount?: boolean
    market?: boolean
    marketId?: boolean
    marketUrl?: boolean
    marketIcon?: boolean
    notifyVia?: boolean
    status?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    error?: boolean
    scheduledFor?: boolean
    processedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notificationQueue"]>

  export type NotificationQueueSelectScalar = {
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    alertId?: boolean
    walletAddress?: boolean
    activityId?: boolean
    tradeType?: boolean
    amount?: boolean
    market?: boolean
    marketId?: boolean
    marketUrl?: boolean
    marketIcon?: boolean
    notifyVia?: boolean
    status?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    error?: boolean
    scheduledFor?: boolean
    processedAt?: boolean
    createdAt?: boolean
  }

  export type NotificationQueueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "userEmail" | "alertId" | "walletAddress" | "activityId" | "tradeType" | "amount" | "market" | "marketId" | "marketUrl" | "marketIcon" | "notifyVia" | "status" | "attempts" | "maxAttempts" | "error" | "scheduledFor" | "processedAt" | "createdAt", ExtArgs["result"]["notificationQueue"]>

  export type $NotificationQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationQueue"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      userEmail: string
      alertId: string
      walletAddress: string
      activityId: string | null
      tradeType: string
      amount: string
      market: string
      marketId: string | null
      marketUrl: string | null
      marketIcon: string | null
      notifyVia: string
      status: $Enums.NotificationStatus
      attempts: number
      maxAttempts: number
      error: string | null
      scheduledFor: Date
      processedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["notificationQueue"]>
    composites: {}
  }

  type NotificationQueueGetPayload<S extends boolean | null | undefined | NotificationQueueDefaultArgs> = $Result.GetResult<Prisma.$NotificationQueuePayload, S>

  type NotificationQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationQueueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationQueueCountAggregateInputType | true
    }

  export interface NotificationQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationQueue'], meta: { name: 'NotificationQueue' } }
    /**
     * Find zero or one NotificationQueue that matches the filter.
     * @param {NotificationQueueFindUniqueArgs} args - Arguments to find a NotificationQueue
     * @example
     * // Get one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationQueueFindUniqueArgs>(args: SelectSubset<T, NotificationQueueFindUniqueArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationQueue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationQueueFindUniqueOrThrowArgs} args - Arguments to find a NotificationQueue
     * @example
     * // Get one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueFindFirstArgs} args - Arguments to find a NotificationQueue
     * @example
     * // Get one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationQueueFindFirstArgs>(args?: SelectSubset<T, NotificationQueueFindFirstArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueFindFirstOrThrowArgs} args - Arguments to find a NotificationQueue
     * @example
     * // Get one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationQueues
     * const notificationQueues = await prisma.notificationQueue.findMany()
     * 
     * // Get first 10 NotificationQueues
     * const notificationQueues = await prisma.notificationQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationQueueWithIdOnly = await prisma.notificationQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationQueueFindManyArgs>(args?: SelectSubset<T, NotificationQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationQueue.
     * @param {NotificationQueueCreateArgs} args - Arguments to create a NotificationQueue.
     * @example
     * // Create one NotificationQueue
     * const NotificationQueue = await prisma.notificationQueue.create({
     *   data: {
     *     // ... data to create a NotificationQueue
     *   }
     * })
     * 
     */
    create<T extends NotificationQueueCreateArgs>(args: SelectSubset<T, NotificationQueueCreateArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationQueues.
     * @param {NotificationQueueCreateManyArgs} args - Arguments to create many NotificationQueues.
     * @example
     * // Create many NotificationQueues
     * const notificationQueue = await prisma.notificationQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationQueueCreateManyArgs>(args?: SelectSubset<T, NotificationQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationQueues and returns the data saved in the database.
     * @param {NotificationQueueCreateManyAndReturnArgs} args - Arguments to create many NotificationQueues.
     * @example
     * // Create many NotificationQueues
     * const notificationQueue = await prisma.notificationQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationQueues and only return the `id`
     * const notificationQueueWithIdOnly = await prisma.notificationQueue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationQueue.
     * @param {NotificationQueueDeleteArgs} args - Arguments to delete one NotificationQueue.
     * @example
     * // Delete one NotificationQueue
     * const NotificationQueue = await prisma.notificationQueue.delete({
     *   where: {
     *     // ... filter to delete one NotificationQueue
     *   }
     * })
     * 
     */
    delete<T extends NotificationQueueDeleteArgs>(args: SelectSubset<T, NotificationQueueDeleteArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationQueue.
     * @param {NotificationQueueUpdateArgs} args - Arguments to update one NotificationQueue.
     * @example
     * // Update one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationQueueUpdateArgs>(args: SelectSubset<T, NotificationQueueUpdateArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationQueues.
     * @param {NotificationQueueDeleteManyArgs} args - Arguments to filter NotificationQueues to delete.
     * @example
     * // Delete a few NotificationQueues
     * const { count } = await prisma.notificationQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationQueueDeleteManyArgs>(args?: SelectSubset<T, NotificationQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationQueues
     * const notificationQueue = await prisma.notificationQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationQueueUpdateManyArgs>(args: SelectSubset<T, NotificationQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationQueues and returns the data updated in the database.
     * @param {NotificationQueueUpdateManyAndReturnArgs} args - Arguments to update many NotificationQueues.
     * @example
     * // Update many NotificationQueues
     * const notificationQueue = await prisma.notificationQueue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationQueues and only return the `id`
     * const notificationQueueWithIdOnly = await prisma.notificationQueue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationQueueUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationQueueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationQueue.
     * @param {NotificationQueueUpsertArgs} args - Arguments to update or create a NotificationQueue.
     * @example
     * // Update or create a NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.upsert({
     *   create: {
     *     // ... data to create a NotificationQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationQueue we want to update
     *   }
     * })
     */
    upsert<T extends NotificationQueueUpsertArgs>(args: SelectSubset<T, NotificationQueueUpsertArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueCountArgs} args - Arguments to filter NotificationQueues to count.
     * @example
     * // Count the number of NotificationQueues
     * const count = await prisma.notificationQueue.count({
     *   where: {
     *     // ... the filter for the NotificationQueues we want to count
     *   }
     * })
    **/
    count<T extends NotificationQueueCountArgs>(
      args?: Subset<T, NotificationQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationQueueAggregateArgs>(args: Subset<T, NotificationQueueAggregateArgs>): Prisma.PrismaPromise<GetNotificationQueueAggregateType<T>>

    /**
     * Group by NotificationQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationQueueGroupByArgs['orderBy'] }
        : { orderBy?: NotificationQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationQueue model
   */
  readonly fields: NotificationQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationQueue model
   */
  interface NotificationQueueFieldRefs {
    readonly id: FieldRef<"NotificationQueue", 'String'>
    readonly userId: FieldRef<"NotificationQueue", 'String'>
    readonly userEmail: FieldRef<"NotificationQueue", 'String'>
    readonly alertId: FieldRef<"NotificationQueue", 'String'>
    readonly walletAddress: FieldRef<"NotificationQueue", 'String'>
    readonly activityId: FieldRef<"NotificationQueue", 'String'>
    readonly tradeType: FieldRef<"NotificationQueue", 'String'>
    readonly amount: FieldRef<"NotificationQueue", 'String'>
    readonly market: FieldRef<"NotificationQueue", 'String'>
    readonly marketId: FieldRef<"NotificationQueue", 'String'>
    readonly marketUrl: FieldRef<"NotificationQueue", 'String'>
    readonly marketIcon: FieldRef<"NotificationQueue", 'String'>
    readonly notifyVia: FieldRef<"NotificationQueue", 'String'>
    readonly status: FieldRef<"NotificationQueue", 'NotificationStatus'>
    readonly attempts: FieldRef<"NotificationQueue", 'Int'>
    readonly maxAttempts: FieldRef<"NotificationQueue", 'Int'>
    readonly error: FieldRef<"NotificationQueue", 'String'>
    readonly scheduledFor: FieldRef<"NotificationQueue", 'DateTime'>
    readonly processedAt: FieldRef<"NotificationQueue", 'DateTime'>
    readonly createdAt: FieldRef<"NotificationQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationQueue findUnique
   */
  export type NotificationQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * Filter, which NotificationQueue to fetch.
     */
    where: NotificationQueueWhereUniqueInput
  }

  /**
   * NotificationQueue findUniqueOrThrow
   */
  export type NotificationQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * Filter, which NotificationQueue to fetch.
     */
    where: NotificationQueueWhereUniqueInput
  }

  /**
   * NotificationQueue findFirst
   */
  export type NotificationQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * Filter, which NotificationQueue to fetch.
     */
    where?: NotificationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationQueues to fetch.
     */
    orderBy?: NotificationQueueOrderByWithRelationInput | NotificationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationQueues.
     */
    cursor?: NotificationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationQueues.
     */
    distinct?: NotificationQueueScalarFieldEnum | NotificationQueueScalarFieldEnum[]
  }

  /**
   * NotificationQueue findFirstOrThrow
   */
  export type NotificationQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * Filter, which NotificationQueue to fetch.
     */
    where?: NotificationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationQueues to fetch.
     */
    orderBy?: NotificationQueueOrderByWithRelationInput | NotificationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationQueues.
     */
    cursor?: NotificationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationQueues.
     */
    distinct?: NotificationQueueScalarFieldEnum | NotificationQueueScalarFieldEnum[]
  }

  /**
   * NotificationQueue findMany
   */
  export type NotificationQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * Filter, which NotificationQueues to fetch.
     */
    where?: NotificationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationQueues to fetch.
     */
    orderBy?: NotificationQueueOrderByWithRelationInput | NotificationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationQueues.
     */
    cursor?: NotificationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationQueues.
     */
    skip?: number
    distinct?: NotificationQueueScalarFieldEnum | NotificationQueueScalarFieldEnum[]
  }

  /**
   * NotificationQueue create
   */
  export type NotificationQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * The data needed to create a NotificationQueue.
     */
    data: XOR<NotificationQueueCreateInput, NotificationQueueUncheckedCreateInput>
  }

  /**
   * NotificationQueue createMany
   */
  export type NotificationQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationQueues.
     */
    data: NotificationQueueCreateManyInput | NotificationQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationQueue createManyAndReturn
   */
  export type NotificationQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationQueues.
     */
    data: NotificationQueueCreateManyInput | NotificationQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationQueue update
   */
  export type NotificationQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * The data needed to update a NotificationQueue.
     */
    data: XOR<NotificationQueueUpdateInput, NotificationQueueUncheckedUpdateInput>
    /**
     * Choose, which NotificationQueue to update.
     */
    where: NotificationQueueWhereUniqueInput
  }

  /**
   * NotificationQueue updateMany
   */
  export type NotificationQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationQueues.
     */
    data: XOR<NotificationQueueUpdateManyMutationInput, NotificationQueueUncheckedUpdateManyInput>
    /**
     * Filter which NotificationQueues to update
     */
    where?: NotificationQueueWhereInput
    /**
     * Limit how many NotificationQueues to update.
     */
    limit?: number
  }

  /**
   * NotificationQueue updateManyAndReturn
   */
  export type NotificationQueueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * The data used to update NotificationQueues.
     */
    data: XOR<NotificationQueueUpdateManyMutationInput, NotificationQueueUncheckedUpdateManyInput>
    /**
     * Filter which NotificationQueues to update
     */
    where?: NotificationQueueWhereInput
    /**
     * Limit how many NotificationQueues to update.
     */
    limit?: number
  }

  /**
   * NotificationQueue upsert
   */
  export type NotificationQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * The filter to search for the NotificationQueue to update in case it exists.
     */
    where: NotificationQueueWhereUniqueInput
    /**
     * In case the NotificationQueue found by the `where` argument doesn't exist, create a new NotificationQueue with this data.
     */
    create: XOR<NotificationQueueCreateInput, NotificationQueueUncheckedCreateInput>
    /**
     * In case the NotificationQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationQueueUpdateInput, NotificationQueueUncheckedUpdateInput>
  }

  /**
   * NotificationQueue delete
   */
  export type NotificationQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * Filter which NotificationQueue to delete.
     */
    where: NotificationQueueWhereUniqueInput
  }

  /**
   * NotificationQueue deleteMany
   */
  export type NotificationQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationQueues to delete
     */
    where?: NotificationQueueWhereInput
    /**
     * Limit how many NotificationQueues to delete.
     */
    limit?: number
  }

  /**
   * NotificationQueue without action
   */
  export type NotificationQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
  }


  /**
   * Model NotificationLog
   */

  export type AggregateNotificationLog = {
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  export type NotificationLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userEmail: string | null
    alertId: string | null
    walletAddress: string | null
    activityId: string | null
    tradeType: string | null
    amount: string | null
    market: string | null
    notifyVia: string | null
    status: string | null
    error: string | null
    sentAt: Date | null
  }

  export type NotificationLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userEmail: string | null
    alertId: string | null
    walletAddress: string | null
    activityId: string | null
    tradeType: string | null
    amount: string | null
    market: string | null
    notifyVia: string | null
    status: string | null
    error: string | null
    sentAt: Date | null
  }

  export type NotificationLogCountAggregateOutputType = {
    id: number
    userId: number
    userEmail: number
    alertId: number
    walletAddress: number
    activityId: number
    tradeType: number
    amount: number
    market: number
    notifyVia: number
    status: number
    error: number
    sentAt: number
    _all: number
  }


  export type NotificationLogMinAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    alertId?: true
    walletAddress?: true
    activityId?: true
    tradeType?: true
    amount?: true
    market?: true
    notifyVia?: true
    status?: true
    error?: true
    sentAt?: true
  }

  export type NotificationLogMaxAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    alertId?: true
    walletAddress?: true
    activityId?: true
    tradeType?: true
    amount?: true
    market?: true
    notifyVia?: true
    status?: true
    error?: true
    sentAt?: true
  }

  export type NotificationLogCountAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    alertId?: true
    walletAddress?: true
    activityId?: true
    tradeType?: true
    amount?: true
    market?: true
    notifyVia?: true
    status?: true
    error?: true
    sentAt?: true
    _all?: true
  }

  export type NotificationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLog to aggregate.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationLogs
    **/
    _count?: true | NotificationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationLogMaxAggregateInputType
  }

  export type GetNotificationLogAggregateType<T extends NotificationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationLog[P]>
      : GetScalarType<T[P], AggregateNotificationLog[P]>
  }




  export type NotificationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithAggregationInput | NotificationLogOrderByWithAggregationInput[]
    by: NotificationLogScalarFieldEnum[] | NotificationLogScalarFieldEnum
    having?: NotificationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationLogCountAggregateInputType | true
    _min?: NotificationLogMinAggregateInputType
    _max?: NotificationLogMaxAggregateInputType
  }

  export type NotificationLogGroupByOutputType = {
    id: string
    userId: string
    userEmail: string
    alertId: string
    walletAddress: string
    activityId: string | null
    tradeType: string
    amount: string
    market: string
    notifyVia: string
    status: string
    error: string | null
    sentAt: Date
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  type GetNotificationLogGroupByPayload<T extends NotificationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
        }
      >
    >


  export type NotificationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    alertId?: boolean
    walletAddress?: boolean
    activityId?: boolean
    tradeType?: boolean
    amount?: boolean
    market?: boolean
    notifyVia?: boolean
    status?: boolean
    error?: boolean
    sentAt?: boolean
    alert?: boolean | AlertDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    alertId?: boolean
    walletAddress?: boolean
    activityId?: boolean
    tradeType?: boolean
    amount?: boolean
    market?: boolean
    notifyVia?: boolean
    status?: boolean
    error?: boolean
    sentAt?: boolean
    alert?: boolean | AlertDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    alertId?: boolean
    walletAddress?: boolean
    activityId?: boolean
    tradeType?: boolean
    amount?: boolean
    market?: boolean
    notifyVia?: boolean
    status?: boolean
    error?: boolean
    sentAt?: boolean
    alert?: boolean | AlertDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectScalar = {
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    alertId?: boolean
    walletAddress?: boolean
    activityId?: boolean
    tradeType?: boolean
    amount?: boolean
    market?: boolean
    notifyVia?: boolean
    status?: boolean
    error?: boolean
    sentAt?: boolean
  }

  export type NotificationLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "userEmail" | "alertId" | "walletAddress" | "activityId" | "tradeType" | "amount" | "market" | "notifyVia" | "status" | "error" | "sentAt", ExtArgs["result"]["notificationLog"]>
  export type NotificationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | AlertDefaultArgs<ExtArgs>
  }
  export type NotificationLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | AlertDefaultArgs<ExtArgs>
  }
  export type NotificationLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | AlertDefaultArgs<ExtArgs>
  }

  export type $NotificationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationLog"
    objects: {
      alert: Prisma.$AlertPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      userEmail: string
      alertId: string
      walletAddress: string
      activityId: string | null
      tradeType: string
      amount: string
      market: string
      notifyVia: string
      status: string
      error: string | null
      sentAt: Date
    }, ExtArgs["result"]["notificationLog"]>
    composites: {}
  }

  type NotificationLogGetPayload<S extends boolean | null | undefined | NotificationLogDefaultArgs> = $Result.GetResult<Prisma.$NotificationLogPayload, S>

  type NotificationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationLogCountAggregateInputType | true
    }

  export interface NotificationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationLog'], meta: { name: 'NotificationLog' } }
    /**
     * Find zero or one NotificationLog that matches the filter.
     * @param {NotificationLogFindUniqueArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationLogFindUniqueArgs>(args: SelectSubset<T, NotificationLogFindUniqueArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationLogFindUniqueOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationLogFindFirstArgs>(args?: SelectSubset<T, NotificationLogFindFirstArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany()
     * 
     * // Get first 10 NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationLogFindManyArgs>(args?: SelectSubset<T, NotificationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationLog.
     * @param {NotificationLogCreateArgs} args - Arguments to create a NotificationLog.
     * @example
     * // Create one NotificationLog
     * const NotificationLog = await prisma.notificationLog.create({
     *   data: {
     *     // ... data to create a NotificationLog
     *   }
     * })
     * 
     */
    create<T extends NotificationLogCreateArgs>(args: SelectSubset<T, NotificationLogCreateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationLogs.
     * @param {NotificationLogCreateManyArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationLogCreateManyArgs>(args?: SelectSubset<T, NotificationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationLogs and returns the data saved in the database.
     * @param {NotificationLogCreateManyAndReturnArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationLogs and only return the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationLog.
     * @param {NotificationLogDeleteArgs} args - Arguments to delete one NotificationLog.
     * @example
     * // Delete one NotificationLog
     * const NotificationLog = await prisma.notificationLog.delete({
     *   where: {
     *     // ... filter to delete one NotificationLog
     *   }
     * })
     * 
     */
    delete<T extends NotificationLogDeleteArgs>(args: SelectSubset<T, NotificationLogDeleteArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationLog.
     * @param {NotificationLogUpdateArgs} args - Arguments to update one NotificationLog.
     * @example
     * // Update one NotificationLog
     * const notificationLog = await prisma.notificationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationLogUpdateArgs>(args: SelectSubset<T, NotificationLogUpdateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationLogs.
     * @param {NotificationLogDeleteManyArgs} args - Arguments to filter NotificationLogs to delete.
     * @example
     * // Delete a few NotificationLogs
     * const { count } = await prisma.notificationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationLogDeleteManyArgs>(args?: SelectSubset<T, NotificationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationLogs
     * const notificationLog = await prisma.notificationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationLogUpdateManyArgs>(args: SelectSubset<T, NotificationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationLogs and returns the data updated in the database.
     * @param {NotificationLogUpdateManyAndReturnArgs} args - Arguments to update many NotificationLogs.
     * @example
     * // Update many NotificationLogs
     * const notificationLog = await prisma.notificationLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationLogs and only return the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationLogUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationLog.
     * @param {NotificationLogUpsertArgs} args - Arguments to update or create a NotificationLog.
     * @example
     * // Update or create a NotificationLog
     * const notificationLog = await prisma.notificationLog.upsert({
     *   create: {
     *     // ... data to create a NotificationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationLog we want to update
     *   }
     * })
     */
    upsert<T extends NotificationLogUpsertArgs>(args: SelectSubset<T, NotificationLogUpsertArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogCountArgs} args - Arguments to filter NotificationLogs to count.
     * @example
     * // Count the number of NotificationLogs
     * const count = await prisma.notificationLog.count({
     *   where: {
     *     // ... the filter for the NotificationLogs we want to count
     *   }
     * })
    **/
    count<T extends NotificationLogCountArgs>(
      args?: Subset<T, NotificationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationLogAggregateArgs>(args: Subset<T, NotificationLogAggregateArgs>): Prisma.PrismaPromise<GetNotificationLogAggregateType<T>>

    /**
     * Group by NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationLogGroupByArgs['orderBy'] }
        : { orderBy?: NotificationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationLog model
   */
  readonly fields: NotificationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alert<T extends AlertDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlertDefaultArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationLog model
   */
  interface NotificationLogFieldRefs {
    readonly id: FieldRef<"NotificationLog", 'String'>
    readonly userId: FieldRef<"NotificationLog", 'String'>
    readonly userEmail: FieldRef<"NotificationLog", 'String'>
    readonly alertId: FieldRef<"NotificationLog", 'String'>
    readonly walletAddress: FieldRef<"NotificationLog", 'String'>
    readonly activityId: FieldRef<"NotificationLog", 'String'>
    readonly tradeType: FieldRef<"NotificationLog", 'String'>
    readonly amount: FieldRef<"NotificationLog", 'String'>
    readonly market: FieldRef<"NotificationLog", 'String'>
    readonly notifyVia: FieldRef<"NotificationLog", 'String'>
    readonly status: FieldRef<"NotificationLog", 'String'>
    readonly error: FieldRef<"NotificationLog", 'String'>
    readonly sentAt: FieldRef<"NotificationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationLog findUnique
   */
  export type NotificationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findUniqueOrThrow
   */
  export type NotificationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findFirst
   */
  export type NotificationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findFirstOrThrow
   */
  export type NotificationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findMany
   */
  export type NotificationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLogs to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog create
   */
  export type NotificationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationLog.
     */
    data: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
  }

  /**
   * NotificationLog createMany
   */
  export type NotificationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationLog createManyAndReturn
   */
  export type NotificationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationLog update
   */
  export type NotificationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationLog.
     */
    data: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
    /**
     * Choose, which NotificationLog to update.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog updateMany
   */
  export type NotificationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationLogs.
     */
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyInput>
    /**
     * Filter which NotificationLogs to update
     */
    where?: NotificationLogWhereInput
    /**
     * Limit how many NotificationLogs to update.
     */
    limit?: number
  }

  /**
   * NotificationLog updateManyAndReturn
   */
  export type NotificationLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * The data used to update NotificationLogs.
     */
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyInput>
    /**
     * Filter which NotificationLogs to update
     */
    where?: NotificationLogWhereInput
    /**
     * Limit how many NotificationLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationLog upsert
   */
  export type NotificationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationLog to update in case it exists.
     */
    where: NotificationLogWhereUniqueInput
    /**
     * In case the NotificationLog found by the `where` argument doesn't exist, create a new NotificationLog with this data.
     */
    create: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
    /**
     * In case the NotificationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
  }

  /**
   * NotificationLog delete
   */
  export type NotificationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter which NotificationLog to delete.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog deleteMany
   */
  export type NotificationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLogs to delete
     */
    where?: NotificationLogWhereInput
    /**
     * Limit how many NotificationLogs to delete.
     */
    limit?: number
  }

  /**
   * NotificationLog without action
   */
  export type NotificationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
  }


  /**
   * Model CronJobLog
   */

  export type AggregateCronJobLog = {
    _count: CronJobLogCountAggregateOutputType | null
    _avg: CronJobLogAvgAggregateOutputType | null
    _sum: CronJobLogSumAggregateOutputType | null
    _min: CronJobLogMinAggregateOutputType | null
    _max: CronJobLogMaxAggregateOutputType | null
  }

  export type CronJobLogAvgAggregateOutputType = {
    processed: number | null
    failed: number | null
    duration: number | null
  }

  export type CronJobLogSumAggregateOutputType = {
    processed: number | null
    failed: number | null
    duration: number | null
  }

  export type CronJobLogMinAggregateOutputType = {
    id: string | null
    jobType: string | null
    status: string | null
    processed: number | null
    failed: number | null
    duration: number | null
    error: string | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type CronJobLogMaxAggregateOutputType = {
    id: string | null
    jobType: string | null
    status: string | null
    processed: number | null
    failed: number | null
    duration: number | null
    error: string | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type CronJobLogCountAggregateOutputType = {
    id: number
    jobType: number
    status: number
    processed: number
    failed: number
    duration: number
    error: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type CronJobLogAvgAggregateInputType = {
    processed?: true
    failed?: true
    duration?: true
  }

  export type CronJobLogSumAggregateInputType = {
    processed?: true
    failed?: true
    duration?: true
  }

  export type CronJobLogMinAggregateInputType = {
    id?: true
    jobType?: true
    status?: true
    processed?: true
    failed?: true
    duration?: true
    error?: true
    startedAt?: true
    completedAt?: true
  }

  export type CronJobLogMaxAggregateInputType = {
    id?: true
    jobType?: true
    status?: true
    processed?: true
    failed?: true
    duration?: true
    error?: true
    startedAt?: true
    completedAt?: true
  }

  export type CronJobLogCountAggregateInputType = {
    id?: true
    jobType?: true
    status?: true
    processed?: true
    failed?: true
    duration?: true
    error?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type CronJobLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CronJobLog to aggregate.
     */
    where?: CronJobLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CronJobLogs to fetch.
     */
    orderBy?: CronJobLogOrderByWithRelationInput | CronJobLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CronJobLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CronJobLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CronJobLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CronJobLogs
    **/
    _count?: true | CronJobLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CronJobLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CronJobLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CronJobLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CronJobLogMaxAggregateInputType
  }

  export type GetCronJobLogAggregateType<T extends CronJobLogAggregateArgs> = {
        [P in keyof T & keyof AggregateCronJobLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCronJobLog[P]>
      : GetScalarType<T[P], AggregateCronJobLog[P]>
  }




  export type CronJobLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CronJobLogWhereInput
    orderBy?: CronJobLogOrderByWithAggregationInput | CronJobLogOrderByWithAggregationInput[]
    by: CronJobLogScalarFieldEnum[] | CronJobLogScalarFieldEnum
    having?: CronJobLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CronJobLogCountAggregateInputType | true
    _avg?: CronJobLogAvgAggregateInputType
    _sum?: CronJobLogSumAggregateInputType
    _min?: CronJobLogMinAggregateInputType
    _max?: CronJobLogMaxAggregateInputType
  }

  export type CronJobLogGroupByOutputType = {
    id: string
    jobType: string
    status: string
    processed: number
    failed: number
    duration: number | null
    error: string | null
    startedAt: Date
    completedAt: Date | null
    _count: CronJobLogCountAggregateOutputType | null
    _avg: CronJobLogAvgAggregateOutputType | null
    _sum: CronJobLogSumAggregateOutputType | null
    _min: CronJobLogMinAggregateOutputType | null
    _max: CronJobLogMaxAggregateOutputType | null
  }

  type GetCronJobLogGroupByPayload<T extends CronJobLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CronJobLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CronJobLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CronJobLogGroupByOutputType[P]>
            : GetScalarType<T[P], CronJobLogGroupByOutputType[P]>
        }
      >
    >


  export type CronJobLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobType?: boolean
    status?: boolean
    processed?: boolean
    failed?: boolean
    duration?: boolean
    error?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["cronJobLog"]>

  export type CronJobLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobType?: boolean
    status?: boolean
    processed?: boolean
    failed?: boolean
    duration?: boolean
    error?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["cronJobLog"]>

  export type CronJobLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobType?: boolean
    status?: boolean
    processed?: boolean
    failed?: boolean
    duration?: boolean
    error?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["cronJobLog"]>

  export type CronJobLogSelectScalar = {
    id?: boolean
    jobType?: boolean
    status?: boolean
    processed?: boolean
    failed?: boolean
    duration?: boolean
    error?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type CronJobLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobType" | "status" | "processed" | "failed" | "duration" | "error" | "startedAt" | "completedAt", ExtArgs["result"]["cronJobLog"]>

  export type $CronJobLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CronJobLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobType: string
      status: string
      processed: number
      failed: number
      duration: number | null
      error: string | null
      startedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["cronJobLog"]>
    composites: {}
  }

  type CronJobLogGetPayload<S extends boolean | null | undefined | CronJobLogDefaultArgs> = $Result.GetResult<Prisma.$CronJobLogPayload, S>

  type CronJobLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CronJobLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CronJobLogCountAggregateInputType | true
    }

  export interface CronJobLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CronJobLog'], meta: { name: 'CronJobLog' } }
    /**
     * Find zero or one CronJobLog that matches the filter.
     * @param {CronJobLogFindUniqueArgs} args - Arguments to find a CronJobLog
     * @example
     * // Get one CronJobLog
     * const cronJobLog = await prisma.cronJobLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CronJobLogFindUniqueArgs>(args: SelectSubset<T, CronJobLogFindUniqueArgs<ExtArgs>>): Prisma__CronJobLogClient<$Result.GetResult<Prisma.$CronJobLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CronJobLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CronJobLogFindUniqueOrThrowArgs} args - Arguments to find a CronJobLog
     * @example
     * // Get one CronJobLog
     * const cronJobLog = await prisma.cronJobLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CronJobLogFindUniqueOrThrowArgs>(args: SelectSubset<T, CronJobLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CronJobLogClient<$Result.GetResult<Prisma.$CronJobLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CronJobLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronJobLogFindFirstArgs} args - Arguments to find a CronJobLog
     * @example
     * // Get one CronJobLog
     * const cronJobLog = await prisma.cronJobLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CronJobLogFindFirstArgs>(args?: SelectSubset<T, CronJobLogFindFirstArgs<ExtArgs>>): Prisma__CronJobLogClient<$Result.GetResult<Prisma.$CronJobLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CronJobLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronJobLogFindFirstOrThrowArgs} args - Arguments to find a CronJobLog
     * @example
     * // Get one CronJobLog
     * const cronJobLog = await prisma.cronJobLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CronJobLogFindFirstOrThrowArgs>(args?: SelectSubset<T, CronJobLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CronJobLogClient<$Result.GetResult<Prisma.$CronJobLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CronJobLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronJobLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CronJobLogs
     * const cronJobLogs = await prisma.cronJobLog.findMany()
     * 
     * // Get first 10 CronJobLogs
     * const cronJobLogs = await prisma.cronJobLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cronJobLogWithIdOnly = await prisma.cronJobLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CronJobLogFindManyArgs>(args?: SelectSubset<T, CronJobLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CronJobLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CronJobLog.
     * @param {CronJobLogCreateArgs} args - Arguments to create a CronJobLog.
     * @example
     * // Create one CronJobLog
     * const CronJobLog = await prisma.cronJobLog.create({
     *   data: {
     *     // ... data to create a CronJobLog
     *   }
     * })
     * 
     */
    create<T extends CronJobLogCreateArgs>(args: SelectSubset<T, CronJobLogCreateArgs<ExtArgs>>): Prisma__CronJobLogClient<$Result.GetResult<Prisma.$CronJobLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CronJobLogs.
     * @param {CronJobLogCreateManyArgs} args - Arguments to create many CronJobLogs.
     * @example
     * // Create many CronJobLogs
     * const cronJobLog = await prisma.cronJobLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CronJobLogCreateManyArgs>(args?: SelectSubset<T, CronJobLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CronJobLogs and returns the data saved in the database.
     * @param {CronJobLogCreateManyAndReturnArgs} args - Arguments to create many CronJobLogs.
     * @example
     * // Create many CronJobLogs
     * const cronJobLog = await prisma.cronJobLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CronJobLogs and only return the `id`
     * const cronJobLogWithIdOnly = await prisma.cronJobLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CronJobLogCreateManyAndReturnArgs>(args?: SelectSubset<T, CronJobLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CronJobLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CronJobLog.
     * @param {CronJobLogDeleteArgs} args - Arguments to delete one CronJobLog.
     * @example
     * // Delete one CronJobLog
     * const CronJobLog = await prisma.cronJobLog.delete({
     *   where: {
     *     // ... filter to delete one CronJobLog
     *   }
     * })
     * 
     */
    delete<T extends CronJobLogDeleteArgs>(args: SelectSubset<T, CronJobLogDeleteArgs<ExtArgs>>): Prisma__CronJobLogClient<$Result.GetResult<Prisma.$CronJobLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CronJobLog.
     * @param {CronJobLogUpdateArgs} args - Arguments to update one CronJobLog.
     * @example
     * // Update one CronJobLog
     * const cronJobLog = await prisma.cronJobLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CronJobLogUpdateArgs>(args: SelectSubset<T, CronJobLogUpdateArgs<ExtArgs>>): Prisma__CronJobLogClient<$Result.GetResult<Prisma.$CronJobLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CronJobLogs.
     * @param {CronJobLogDeleteManyArgs} args - Arguments to filter CronJobLogs to delete.
     * @example
     * // Delete a few CronJobLogs
     * const { count } = await prisma.cronJobLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CronJobLogDeleteManyArgs>(args?: SelectSubset<T, CronJobLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CronJobLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronJobLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CronJobLogs
     * const cronJobLog = await prisma.cronJobLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CronJobLogUpdateManyArgs>(args: SelectSubset<T, CronJobLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CronJobLogs and returns the data updated in the database.
     * @param {CronJobLogUpdateManyAndReturnArgs} args - Arguments to update many CronJobLogs.
     * @example
     * // Update many CronJobLogs
     * const cronJobLog = await prisma.cronJobLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CronJobLogs and only return the `id`
     * const cronJobLogWithIdOnly = await prisma.cronJobLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CronJobLogUpdateManyAndReturnArgs>(args: SelectSubset<T, CronJobLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CronJobLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CronJobLog.
     * @param {CronJobLogUpsertArgs} args - Arguments to update or create a CronJobLog.
     * @example
     * // Update or create a CronJobLog
     * const cronJobLog = await prisma.cronJobLog.upsert({
     *   create: {
     *     // ... data to create a CronJobLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CronJobLog we want to update
     *   }
     * })
     */
    upsert<T extends CronJobLogUpsertArgs>(args: SelectSubset<T, CronJobLogUpsertArgs<ExtArgs>>): Prisma__CronJobLogClient<$Result.GetResult<Prisma.$CronJobLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CronJobLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronJobLogCountArgs} args - Arguments to filter CronJobLogs to count.
     * @example
     * // Count the number of CronJobLogs
     * const count = await prisma.cronJobLog.count({
     *   where: {
     *     // ... the filter for the CronJobLogs we want to count
     *   }
     * })
    **/
    count<T extends CronJobLogCountArgs>(
      args?: Subset<T, CronJobLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CronJobLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CronJobLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronJobLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CronJobLogAggregateArgs>(args: Subset<T, CronJobLogAggregateArgs>): Prisma.PrismaPromise<GetCronJobLogAggregateType<T>>

    /**
     * Group by CronJobLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronJobLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CronJobLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CronJobLogGroupByArgs['orderBy'] }
        : { orderBy?: CronJobLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CronJobLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCronJobLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CronJobLog model
   */
  readonly fields: CronJobLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CronJobLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CronJobLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CronJobLog model
   */
  interface CronJobLogFieldRefs {
    readonly id: FieldRef<"CronJobLog", 'String'>
    readonly jobType: FieldRef<"CronJobLog", 'String'>
    readonly status: FieldRef<"CronJobLog", 'String'>
    readonly processed: FieldRef<"CronJobLog", 'Int'>
    readonly failed: FieldRef<"CronJobLog", 'Int'>
    readonly duration: FieldRef<"CronJobLog", 'Int'>
    readonly error: FieldRef<"CronJobLog", 'String'>
    readonly startedAt: FieldRef<"CronJobLog", 'DateTime'>
    readonly completedAt: FieldRef<"CronJobLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CronJobLog findUnique
   */
  export type CronJobLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobLog
     */
    select?: CronJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronJobLog
     */
    omit?: CronJobLogOmit<ExtArgs> | null
    /**
     * Filter, which CronJobLog to fetch.
     */
    where: CronJobLogWhereUniqueInput
  }

  /**
   * CronJobLog findUniqueOrThrow
   */
  export type CronJobLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobLog
     */
    select?: CronJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronJobLog
     */
    omit?: CronJobLogOmit<ExtArgs> | null
    /**
     * Filter, which CronJobLog to fetch.
     */
    where: CronJobLogWhereUniqueInput
  }

  /**
   * CronJobLog findFirst
   */
  export type CronJobLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobLog
     */
    select?: CronJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronJobLog
     */
    omit?: CronJobLogOmit<ExtArgs> | null
    /**
     * Filter, which CronJobLog to fetch.
     */
    where?: CronJobLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CronJobLogs to fetch.
     */
    orderBy?: CronJobLogOrderByWithRelationInput | CronJobLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CronJobLogs.
     */
    cursor?: CronJobLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CronJobLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CronJobLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CronJobLogs.
     */
    distinct?: CronJobLogScalarFieldEnum | CronJobLogScalarFieldEnum[]
  }

  /**
   * CronJobLog findFirstOrThrow
   */
  export type CronJobLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobLog
     */
    select?: CronJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronJobLog
     */
    omit?: CronJobLogOmit<ExtArgs> | null
    /**
     * Filter, which CronJobLog to fetch.
     */
    where?: CronJobLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CronJobLogs to fetch.
     */
    orderBy?: CronJobLogOrderByWithRelationInput | CronJobLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CronJobLogs.
     */
    cursor?: CronJobLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CronJobLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CronJobLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CronJobLogs.
     */
    distinct?: CronJobLogScalarFieldEnum | CronJobLogScalarFieldEnum[]
  }

  /**
   * CronJobLog findMany
   */
  export type CronJobLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobLog
     */
    select?: CronJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronJobLog
     */
    omit?: CronJobLogOmit<ExtArgs> | null
    /**
     * Filter, which CronJobLogs to fetch.
     */
    where?: CronJobLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CronJobLogs to fetch.
     */
    orderBy?: CronJobLogOrderByWithRelationInput | CronJobLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CronJobLogs.
     */
    cursor?: CronJobLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CronJobLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CronJobLogs.
     */
    skip?: number
    distinct?: CronJobLogScalarFieldEnum | CronJobLogScalarFieldEnum[]
  }

  /**
   * CronJobLog create
   */
  export type CronJobLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobLog
     */
    select?: CronJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronJobLog
     */
    omit?: CronJobLogOmit<ExtArgs> | null
    /**
     * The data needed to create a CronJobLog.
     */
    data: XOR<CronJobLogCreateInput, CronJobLogUncheckedCreateInput>
  }

  /**
   * CronJobLog createMany
   */
  export type CronJobLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CronJobLogs.
     */
    data: CronJobLogCreateManyInput | CronJobLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CronJobLog createManyAndReturn
   */
  export type CronJobLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobLog
     */
    select?: CronJobLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CronJobLog
     */
    omit?: CronJobLogOmit<ExtArgs> | null
    /**
     * The data used to create many CronJobLogs.
     */
    data: CronJobLogCreateManyInput | CronJobLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CronJobLog update
   */
  export type CronJobLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobLog
     */
    select?: CronJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronJobLog
     */
    omit?: CronJobLogOmit<ExtArgs> | null
    /**
     * The data needed to update a CronJobLog.
     */
    data: XOR<CronJobLogUpdateInput, CronJobLogUncheckedUpdateInput>
    /**
     * Choose, which CronJobLog to update.
     */
    where: CronJobLogWhereUniqueInput
  }

  /**
   * CronJobLog updateMany
   */
  export type CronJobLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CronJobLogs.
     */
    data: XOR<CronJobLogUpdateManyMutationInput, CronJobLogUncheckedUpdateManyInput>
    /**
     * Filter which CronJobLogs to update
     */
    where?: CronJobLogWhereInput
    /**
     * Limit how many CronJobLogs to update.
     */
    limit?: number
  }

  /**
   * CronJobLog updateManyAndReturn
   */
  export type CronJobLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobLog
     */
    select?: CronJobLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CronJobLog
     */
    omit?: CronJobLogOmit<ExtArgs> | null
    /**
     * The data used to update CronJobLogs.
     */
    data: XOR<CronJobLogUpdateManyMutationInput, CronJobLogUncheckedUpdateManyInput>
    /**
     * Filter which CronJobLogs to update
     */
    where?: CronJobLogWhereInput
    /**
     * Limit how many CronJobLogs to update.
     */
    limit?: number
  }

  /**
   * CronJobLog upsert
   */
  export type CronJobLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobLog
     */
    select?: CronJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronJobLog
     */
    omit?: CronJobLogOmit<ExtArgs> | null
    /**
     * The filter to search for the CronJobLog to update in case it exists.
     */
    where: CronJobLogWhereUniqueInput
    /**
     * In case the CronJobLog found by the `where` argument doesn't exist, create a new CronJobLog with this data.
     */
    create: XOR<CronJobLogCreateInput, CronJobLogUncheckedCreateInput>
    /**
     * In case the CronJobLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CronJobLogUpdateInput, CronJobLogUncheckedUpdateInput>
  }

  /**
   * CronJobLog delete
   */
  export type CronJobLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobLog
     */
    select?: CronJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronJobLog
     */
    omit?: CronJobLogOmit<ExtArgs> | null
    /**
     * Filter which CronJobLog to delete.
     */
    where: CronJobLogWhereUniqueInput
  }

  /**
   * CronJobLog deleteMany
   */
  export type CronJobLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CronJobLogs to delete
     */
    where?: CronJobLogWhereInput
    /**
     * Limit how many CronJobLogs to delete.
     */
    limit?: number
  }

  /**
   * CronJobLog without action
   */
  export type CronJobLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronJobLog
     */
    select?: CronJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronJobLog
     */
    omit?: CronJobLogOmit<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    createdAt: Date | null
    isFavorite: boolean | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    createdAt: Date | null
    isFavorite: boolean | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    createdAt: number
    isFavorite: number
    updatedAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    createdAt?: true
    isFavorite?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    createdAt?: true
    isFavorite?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    createdAt?: true
    isFavorite?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    userId: string
    title: string | null
    createdAt: Date
    isFavorite: boolean
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    createdAt?: boolean
    isFavorite?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    createdAt?: boolean
    isFavorite?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    createdAt?: boolean
    isFavorite?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    createdAt?: boolean
    isFavorite?: boolean
    updatedAt?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "createdAt" | "isFavorite" | "updatedAt", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string | null
      createdAt: Date
      isFavorite: boolean
      updatedAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly userId: FieldRef<"Conversation", 'String'>
    readonly title: FieldRef<"Conversation", 'String'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly isFavorite: FieldRef<"Conversation", 'Boolean'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    type: string | null
    content: string | null
    completed: boolean | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    type: string | null
    content: string | null
    completed: boolean | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    type: number
    content: number
    images: number
    completed: number
    marketData: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    type?: true
    content?: true
    completed?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    type?: true
    content?: true
    completed?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    type?: true
    content?: true
    images?: true
    completed?: true
    marketData?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    type: string
    content: string
    images: string[]
    completed: boolean
    marketData: JsonValue | null
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    type?: boolean
    content?: boolean
    images?: boolean
    completed?: boolean
    marketData?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    type?: boolean
    content?: boolean
    images?: boolean
    completed?: boolean
    marketData?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    type?: boolean
    content?: boolean
    images?: boolean
    completed?: boolean
    marketData?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    type?: boolean
    content?: boolean
    images?: boolean
    completed?: boolean
    marketData?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "type" | "content" | "images" | "completed" | "marketData" | "createdAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      type: string
      content: string
      images: string[]
      completed: boolean
      marketData: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly type: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly images: FieldRef<"Message", 'String[]'>
    readonly completed: FieldRef<"Message", 'Boolean'>
    readonly marketData: FieldRef<"Message", 'Json'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model RulesConversation
   */

  export type AggregateRulesConversation = {
    _count: RulesConversationCountAggregateOutputType | null
    _min: RulesConversationMinAggregateOutputType | null
    _max: RulesConversationMaxAggregateOutputType | null
  }

  export type RulesConversationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    createdAt: Date | null
    isFavorite: boolean | null
    updatedAt: Date | null
  }

  export type RulesConversationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    createdAt: Date | null
    isFavorite: boolean | null
    updatedAt: Date | null
  }

  export type RulesConversationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    createdAt: number
    isFavorite: number
    updatedAt: number
    _all: number
  }


  export type RulesConversationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    createdAt?: true
    isFavorite?: true
    updatedAt?: true
  }

  export type RulesConversationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    createdAt?: true
    isFavorite?: true
    updatedAt?: true
  }

  export type RulesConversationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    createdAt?: true
    isFavorite?: true
    updatedAt?: true
    _all?: true
  }

  export type RulesConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RulesConversation to aggregate.
     */
    where?: RulesConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RulesConversations to fetch.
     */
    orderBy?: RulesConversationOrderByWithRelationInput | RulesConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RulesConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RulesConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RulesConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RulesConversations
    **/
    _count?: true | RulesConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RulesConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RulesConversationMaxAggregateInputType
  }

  export type GetRulesConversationAggregateType<T extends RulesConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateRulesConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRulesConversation[P]>
      : GetScalarType<T[P], AggregateRulesConversation[P]>
  }




  export type RulesConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RulesConversationWhereInput
    orderBy?: RulesConversationOrderByWithAggregationInput | RulesConversationOrderByWithAggregationInput[]
    by: RulesConversationScalarFieldEnum[] | RulesConversationScalarFieldEnum
    having?: RulesConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RulesConversationCountAggregateInputType | true
    _min?: RulesConversationMinAggregateInputType
    _max?: RulesConversationMaxAggregateInputType
  }

  export type RulesConversationGroupByOutputType = {
    id: string
    userId: string
    title: string | null
    createdAt: Date
    isFavorite: boolean
    updatedAt: Date
    _count: RulesConversationCountAggregateOutputType | null
    _min: RulesConversationMinAggregateOutputType | null
    _max: RulesConversationMaxAggregateOutputType | null
  }

  type GetRulesConversationGroupByPayload<T extends RulesConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RulesConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RulesConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RulesConversationGroupByOutputType[P]>
            : GetScalarType<T[P], RulesConversationGroupByOutputType[P]>
        }
      >
    >


  export type RulesConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    createdAt?: boolean
    isFavorite?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | RulesConversation$messagesArgs<ExtArgs>
    _count?: boolean | RulesConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rulesConversation"]>

  export type RulesConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    createdAt?: boolean
    isFavorite?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rulesConversation"]>

  export type RulesConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    createdAt?: boolean
    isFavorite?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rulesConversation"]>

  export type RulesConversationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    createdAt?: boolean
    isFavorite?: boolean
    updatedAt?: boolean
  }

  export type RulesConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "createdAt" | "isFavorite" | "updatedAt", ExtArgs["result"]["rulesConversation"]>
  export type RulesConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | RulesConversation$messagesArgs<ExtArgs>
    _count?: boolean | RulesConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RulesConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RulesConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RulesConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RulesConversation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$RulesMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string | null
      createdAt: Date
      isFavorite: boolean
      updatedAt: Date
    }, ExtArgs["result"]["rulesConversation"]>
    composites: {}
  }

  type RulesConversationGetPayload<S extends boolean | null | undefined | RulesConversationDefaultArgs> = $Result.GetResult<Prisma.$RulesConversationPayload, S>

  type RulesConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RulesConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RulesConversationCountAggregateInputType | true
    }

  export interface RulesConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RulesConversation'], meta: { name: 'RulesConversation' } }
    /**
     * Find zero or one RulesConversation that matches the filter.
     * @param {RulesConversationFindUniqueArgs} args - Arguments to find a RulesConversation
     * @example
     * // Get one RulesConversation
     * const rulesConversation = await prisma.rulesConversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RulesConversationFindUniqueArgs>(args: SelectSubset<T, RulesConversationFindUniqueArgs<ExtArgs>>): Prisma__RulesConversationClient<$Result.GetResult<Prisma.$RulesConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RulesConversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RulesConversationFindUniqueOrThrowArgs} args - Arguments to find a RulesConversation
     * @example
     * // Get one RulesConversation
     * const rulesConversation = await prisma.rulesConversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RulesConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, RulesConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RulesConversationClient<$Result.GetResult<Prisma.$RulesConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RulesConversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RulesConversationFindFirstArgs} args - Arguments to find a RulesConversation
     * @example
     * // Get one RulesConversation
     * const rulesConversation = await prisma.rulesConversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RulesConversationFindFirstArgs>(args?: SelectSubset<T, RulesConversationFindFirstArgs<ExtArgs>>): Prisma__RulesConversationClient<$Result.GetResult<Prisma.$RulesConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RulesConversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RulesConversationFindFirstOrThrowArgs} args - Arguments to find a RulesConversation
     * @example
     * // Get one RulesConversation
     * const rulesConversation = await prisma.rulesConversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RulesConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, RulesConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__RulesConversationClient<$Result.GetResult<Prisma.$RulesConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RulesConversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RulesConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RulesConversations
     * const rulesConversations = await prisma.rulesConversation.findMany()
     * 
     * // Get first 10 RulesConversations
     * const rulesConversations = await prisma.rulesConversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rulesConversationWithIdOnly = await prisma.rulesConversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RulesConversationFindManyArgs>(args?: SelectSubset<T, RulesConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RulesConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RulesConversation.
     * @param {RulesConversationCreateArgs} args - Arguments to create a RulesConversation.
     * @example
     * // Create one RulesConversation
     * const RulesConversation = await prisma.rulesConversation.create({
     *   data: {
     *     // ... data to create a RulesConversation
     *   }
     * })
     * 
     */
    create<T extends RulesConversationCreateArgs>(args: SelectSubset<T, RulesConversationCreateArgs<ExtArgs>>): Prisma__RulesConversationClient<$Result.GetResult<Prisma.$RulesConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RulesConversations.
     * @param {RulesConversationCreateManyArgs} args - Arguments to create many RulesConversations.
     * @example
     * // Create many RulesConversations
     * const rulesConversation = await prisma.rulesConversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RulesConversationCreateManyArgs>(args?: SelectSubset<T, RulesConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RulesConversations and returns the data saved in the database.
     * @param {RulesConversationCreateManyAndReturnArgs} args - Arguments to create many RulesConversations.
     * @example
     * // Create many RulesConversations
     * const rulesConversation = await prisma.rulesConversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RulesConversations and only return the `id`
     * const rulesConversationWithIdOnly = await prisma.rulesConversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RulesConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, RulesConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RulesConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RulesConversation.
     * @param {RulesConversationDeleteArgs} args - Arguments to delete one RulesConversation.
     * @example
     * // Delete one RulesConversation
     * const RulesConversation = await prisma.rulesConversation.delete({
     *   where: {
     *     // ... filter to delete one RulesConversation
     *   }
     * })
     * 
     */
    delete<T extends RulesConversationDeleteArgs>(args: SelectSubset<T, RulesConversationDeleteArgs<ExtArgs>>): Prisma__RulesConversationClient<$Result.GetResult<Prisma.$RulesConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RulesConversation.
     * @param {RulesConversationUpdateArgs} args - Arguments to update one RulesConversation.
     * @example
     * // Update one RulesConversation
     * const rulesConversation = await prisma.rulesConversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RulesConversationUpdateArgs>(args: SelectSubset<T, RulesConversationUpdateArgs<ExtArgs>>): Prisma__RulesConversationClient<$Result.GetResult<Prisma.$RulesConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RulesConversations.
     * @param {RulesConversationDeleteManyArgs} args - Arguments to filter RulesConversations to delete.
     * @example
     * // Delete a few RulesConversations
     * const { count } = await prisma.rulesConversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RulesConversationDeleteManyArgs>(args?: SelectSubset<T, RulesConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RulesConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RulesConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RulesConversations
     * const rulesConversation = await prisma.rulesConversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RulesConversationUpdateManyArgs>(args: SelectSubset<T, RulesConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RulesConversations and returns the data updated in the database.
     * @param {RulesConversationUpdateManyAndReturnArgs} args - Arguments to update many RulesConversations.
     * @example
     * // Update many RulesConversations
     * const rulesConversation = await prisma.rulesConversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RulesConversations and only return the `id`
     * const rulesConversationWithIdOnly = await prisma.rulesConversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RulesConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, RulesConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RulesConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RulesConversation.
     * @param {RulesConversationUpsertArgs} args - Arguments to update or create a RulesConversation.
     * @example
     * // Update or create a RulesConversation
     * const rulesConversation = await prisma.rulesConversation.upsert({
     *   create: {
     *     // ... data to create a RulesConversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RulesConversation we want to update
     *   }
     * })
     */
    upsert<T extends RulesConversationUpsertArgs>(args: SelectSubset<T, RulesConversationUpsertArgs<ExtArgs>>): Prisma__RulesConversationClient<$Result.GetResult<Prisma.$RulesConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RulesConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RulesConversationCountArgs} args - Arguments to filter RulesConversations to count.
     * @example
     * // Count the number of RulesConversations
     * const count = await prisma.rulesConversation.count({
     *   where: {
     *     // ... the filter for the RulesConversations we want to count
     *   }
     * })
    **/
    count<T extends RulesConversationCountArgs>(
      args?: Subset<T, RulesConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RulesConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RulesConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RulesConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RulesConversationAggregateArgs>(args: Subset<T, RulesConversationAggregateArgs>): Prisma.PrismaPromise<GetRulesConversationAggregateType<T>>

    /**
     * Group by RulesConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RulesConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RulesConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RulesConversationGroupByArgs['orderBy'] }
        : { orderBy?: RulesConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RulesConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRulesConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RulesConversation model
   */
  readonly fields: RulesConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RulesConversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RulesConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends RulesConversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, RulesConversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RulesMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RulesConversation model
   */
  interface RulesConversationFieldRefs {
    readonly id: FieldRef<"RulesConversation", 'String'>
    readonly userId: FieldRef<"RulesConversation", 'String'>
    readonly title: FieldRef<"RulesConversation", 'String'>
    readonly createdAt: FieldRef<"RulesConversation", 'DateTime'>
    readonly isFavorite: FieldRef<"RulesConversation", 'Boolean'>
    readonly updatedAt: FieldRef<"RulesConversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RulesConversation findUnique
   */
  export type RulesConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesConversation
     */
    select?: RulesConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesConversation
     */
    omit?: RulesConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesConversationInclude<ExtArgs> | null
    /**
     * Filter, which RulesConversation to fetch.
     */
    where: RulesConversationWhereUniqueInput
  }

  /**
   * RulesConversation findUniqueOrThrow
   */
  export type RulesConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesConversation
     */
    select?: RulesConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesConversation
     */
    omit?: RulesConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesConversationInclude<ExtArgs> | null
    /**
     * Filter, which RulesConversation to fetch.
     */
    where: RulesConversationWhereUniqueInput
  }

  /**
   * RulesConversation findFirst
   */
  export type RulesConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesConversation
     */
    select?: RulesConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesConversation
     */
    omit?: RulesConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesConversationInclude<ExtArgs> | null
    /**
     * Filter, which RulesConversation to fetch.
     */
    where?: RulesConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RulesConversations to fetch.
     */
    orderBy?: RulesConversationOrderByWithRelationInput | RulesConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RulesConversations.
     */
    cursor?: RulesConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RulesConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RulesConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RulesConversations.
     */
    distinct?: RulesConversationScalarFieldEnum | RulesConversationScalarFieldEnum[]
  }

  /**
   * RulesConversation findFirstOrThrow
   */
  export type RulesConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesConversation
     */
    select?: RulesConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesConversation
     */
    omit?: RulesConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesConversationInclude<ExtArgs> | null
    /**
     * Filter, which RulesConversation to fetch.
     */
    where?: RulesConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RulesConversations to fetch.
     */
    orderBy?: RulesConversationOrderByWithRelationInput | RulesConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RulesConversations.
     */
    cursor?: RulesConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RulesConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RulesConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RulesConversations.
     */
    distinct?: RulesConversationScalarFieldEnum | RulesConversationScalarFieldEnum[]
  }

  /**
   * RulesConversation findMany
   */
  export type RulesConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesConversation
     */
    select?: RulesConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesConversation
     */
    omit?: RulesConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesConversationInclude<ExtArgs> | null
    /**
     * Filter, which RulesConversations to fetch.
     */
    where?: RulesConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RulesConversations to fetch.
     */
    orderBy?: RulesConversationOrderByWithRelationInput | RulesConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RulesConversations.
     */
    cursor?: RulesConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RulesConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RulesConversations.
     */
    skip?: number
    distinct?: RulesConversationScalarFieldEnum | RulesConversationScalarFieldEnum[]
  }

  /**
   * RulesConversation create
   */
  export type RulesConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesConversation
     */
    select?: RulesConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesConversation
     */
    omit?: RulesConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a RulesConversation.
     */
    data: XOR<RulesConversationCreateInput, RulesConversationUncheckedCreateInput>
  }

  /**
   * RulesConversation createMany
   */
  export type RulesConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RulesConversations.
     */
    data: RulesConversationCreateManyInput | RulesConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RulesConversation createManyAndReturn
   */
  export type RulesConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesConversation
     */
    select?: RulesConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RulesConversation
     */
    omit?: RulesConversationOmit<ExtArgs> | null
    /**
     * The data used to create many RulesConversations.
     */
    data: RulesConversationCreateManyInput | RulesConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RulesConversation update
   */
  export type RulesConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesConversation
     */
    select?: RulesConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesConversation
     */
    omit?: RulesConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a RulesConversation.
     */
    data: XOR<RulesConversationUpdateInput, RulesConversationUncheckedUpdateInput>
    /**
     * Choose, which RulesConversation to update.
     */
    where: RulesConversationWhereUniqueInput
  }

  /**
   * RulesConversation updateMany
   */
  export type RulesConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RulesConversations.
     */
    data: XOR<RulesConversationUpdateManyMutationInput, RulesConversationUncheckedUpdateManyInput>
    /**
     * Filter which RulesConversations to update
     */
    where?: RulesConversationWhereInput
    /**
     * Limit how many RulesConversations to update.
     */
    limit?: number
  }

  /**
   * RulesConversation updateManyAndReturn
   */
  export type RulesConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesConversation
     */
    select?: RulesConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RulesConversation
     */
    omit?: RulesConversationOmit<ExtArgs> | null
    /**
     * The data used to update RulesConversations.
     */
    data: XOR<RulesConversationUpdateManyMutationInput, RulesConversationUncheckedUpdateManyInput>
    /**
     * Filter which RulesConversations to update
     */
    where?: RulesConversationWhereInput
    /**
     * Limit how many RulesConversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RulesConversation upsert
   */
  export type RulesConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesConversation
     */
    select?: RulesConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesConversation
     */
    omit?: RulesConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the RulesConversation to update in case it exists.
     */
    where: RulesConversationWhereUniqueInput
    /**
     * In case the RulesConversation found by the `where` argument doesn't exist, create a new RulesConversation with this data.
     */
    create: XOR<RulesConversationCreateInput, RulesConversationUncheckedCreateInput>
    /**
     * In case the RulesConversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RulesConversationUpdateInput, RulesConversationUncheckedUpdateInput>
  }

  /**
   * RulesConversation delete
   */
  export type RulesConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesConversation
     */
    select?: RulesConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesConversation
     */
    omit?: RulesConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesConversationInclude<ExtArgs> | null
    /**
     * Filter which RulesConversation to delete.
     */
    where: RulesConversationWhereUniqueInput
  }

  /**
   * RulesConversation deleteMany
   */
  export type RulesConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RulesConversations to delete
     */
    where?: RulesConversationWhereInput
    /**
     * Limit how many RulesConversations to delete.
     */
    limit?: number
  }

  /**
   * RulesConversation.messages
   */
  export type RulesConversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesMessage
     */
    select?: RulesMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesMessage
     */
    omit?: RulesMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesMessageInclude<ExtArgs> | null
    where?: RulesMessageWhereInput
    orderBy?: RulesMessageOrderByWithRelationInput | RulesMessageOrderByWithRelationInput[]
    cursor?: RulesMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RulesMessageScalarFieldEnum | RulesMessageScalarFieldEnum[]
  }

  /**
   * RulesConversation without action
   */
  export type RulesConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesConversation
     */
    select?: RulesConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesConversation
     */
    omit?: RulesConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesConversationInclude<ExtArgs> | null
  }


  /**
   * Model RulesMessage
   */

  export type AggregateRulesMessage = {
    _count: RulesMessageCountAggregateOutputType | null
    _min: RulesMessageMinAggregateOutputType | null
    _max: RulesMessageMaxAggregateOutputType | null
  }

  export type RulesMessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    type: string | null
    content: string | null
    completed: boolean | null
    createdAt: Date | null
  }

  export type RulesMessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    type: string | null
    content: string | null
    completed: boolean | null
    createdAt: Date | null
  }

  export type RulesMessageCountAggregateOutputType = {
    id: number
    conversationId: number
    type: number
    content: number
    images: number
    completed: number
    marketData: number
    createdAt: number
    _all: number
  }


  export type RulesMessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    type?: true
    content?: true
    completed?: true
    createdAt?: true
  }

  export type RulesMessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    type?: true
    content?: true
    completed?: true
    createdAt?: true
  }

  export type RulesMessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    type?: true
    content?: true
    images?: true
    completed?: true
    marketData?: true
    createdAt?: true
    _all?: true
  }

  export type RulesMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RulesMessage to aggregate.
     */
    where?: RulesMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RulesMessages to fetch.
     */
    orderBy?: RulesMessageOrderByWithRelationInput | RulesMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RulesMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RulesMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RulesMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RulesMessages
    **/
    _count?: true | RulesMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RulesMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RulesMessageMaxAggregateInputType
  }

  export type GetRulesMessageAggregateType<T extends RulesMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateRulesMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRulesMessage[P]>
      : GetScalarType<T[P], AggregateRulesMessage[P]>
  }




  export type RulesMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RulesMessageWhereInput
    orderBy?: RulesMessageOrderByWithAggregationInput | RulesMessageOrderByWithAggregationInput[]
    by: RulesMessageScalarFieldEnum[] | RulesMessageScalarFieldEnum
    having?: RulesMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RulesMessageCountAggregateInputType | true
    _min?: RulesMessageMinAggregateInputType
    _max?: RulesMessageMaxAggregateInputType
  }

  export type RulesMessageGroupByOutputType = {
    id: string
    conversationId: string
    type: string
    content: string
    images: string[]
    completed: boolean
    marketData: JsonValue | null
    createdAt: Date
    _count: RulesMessageCountAggregateOutputType | null
    _min: RulesMessageMinAggregateOutputType | null
    _max: RulesMessageMaxAggregateOutputType | null
  }

  type GetRulesMessageGroupByPayload<T extends RulesMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RulesMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RulesMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RulesMessageGroupByOutputType[P]>
            : GetScalarType<T[P], RulesMessageGroupByOutputType[P]>
        }
      >
    >


  export type RulesMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    type?: boolean
    content?: boolean
    images?: boolean
    completed?: boolean
    marketData?: boolean
    createdAt?: boolean
    conversation?: boolean | RulesConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rulesMessage"]>

  export type RulesMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    type?: boolean
    content?: boolean
    images?: boolean
    completed?: boolean
    marketData?: boolean
    createdAt?: boolean
    conversation?: boolean | RulesConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rulesMessage"]>

  export type RulesMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    type?: boolean
    content?: boolean
    images?: boolean
    completed?: boolean
    marketData?: boolean
    createdAt?: boolean
    conversation?: boolean | RulesConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rulesMessage"]>

  export type RulesMessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    type?: boolean
    content?: boolean
    images?: boolean
    completed?: boolean
    marketData?: boolean
    createdAt?: boolean
  }

  export type RulesMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "type" | "content" | "images" | "completed" | "marketData" | "createdAt", ExtArgs["result"]["rulesMessage"]>
  export type RulesMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | RulesConversationDefaultArgs<ExtArgs>
  }
  export type RulesMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | RulesConversationDefaultArgs<ExtArgs>
  }
  export type RulesMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | RulesConversationDefaultArgs<ExtArgs>
  }

  export type $RulesMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RulesMessage"
    objects: {
      conversation: Prisma.$RulesConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      type: string
      content: string
      images: string[]
      completed: boolean
      marketData: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["rulesMessage"]>
    composites: {}
  }

  type RulesMessageGetPayload<S extends boolean | null | undefined | RulesMessageDefaultArgs> = $Result.GetResult<Prisma.$RulesMessagePayload, S>

  type RulesMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RulesMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RulesMessageCountAggregateInputType | true
    }

  export interface RulesMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RulesMessage'], meta: { name: 'RulesMessage' } }
    /**
     * Find zero or one RulesMessage that matches the filter.
     * @param {RulesMessageFindUniqueArgs} args - Arguments to find a RulesMessage
     * @example
     * // Get one RulesMessage
     * const rulesMessage = await prisma.rulesMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RulesMessageFindUniqueArgs>(args: SelectSubset<T, RulesMessageFindUniqueArgs<ExtArgs>>): Prisma__RulesMessageClient<$Result.GetResult<Prisma.$RulesMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RulesMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RulesMessageFindUniqueOrThrowArgs} args - Arguments to find a RulesMessage
     * @example
     * // Get one RulesMessage
     * const rulesMessage = await prisma.rulesMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RulesMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, RulesMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RulesMessageClient<$Result.GetResult<Prisma.$RulesMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RulesMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RulesMessageFindFirstArgs} args - Arguments to find a RulesMessage
     * @example
     * // Get one RulesMessage
     * const rulesMessage = await prisma.rulesMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RulesMessageFindFirstArgs>(args?: SelectSubset<T, RulesMessageFindFirstArgs<ExtArgs>>): Prisma__RulesMessageClient<$Result.GetResult<Prisma.$RulesMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RulesMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RulesMessageFindFirstOrThrowArgs} args - Arguments to find a RulesMessage
     * @example
     * // Get one RulesMessage
     * const rulesMessage = await prisma.rulesMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RulesMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, RulesMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__RulesMessageClient<$Result.GetResult<Prisma.$RulesMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RulesMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RulesMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RulesMessages
     * const rulesMessages = await prisma.rulesMessage.findMany()
     * 
     * // Get first 10 RulesMessages
     * const rulesMessages = await prisma.rulesMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rulesMessageWithIdOnly = await prisma.rulesMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RulesMessageFindManyArgs>(args?: SelectSubset<T, RulesMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RulesMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RulesMessage.
     * @param {RulesMessageCreateArgs} args - Arguments to create a RulesMessage.
     * @example
     * // Create one RulesMessage
     * const RulesMessage = await prisma.rulesMessage.create({
     *   data: {
     *     // ... data to create a RulesMessage
     *   }
     * })
     * 
     */
    create<T extends RulesMessageCreateArgs>(args: SelectSubset<T, RulesMessageCreateArgs<ExtArgs>>): Prisma__RulesMessageClient<$Result.GetResult<Prisma.$RulesMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RulesMessages.
     * @param {RulesMessageCreateManyArgs} args - Arguments to create many RulesMessages.
     * @example
     * // Create many RulesMessages
     * const rulesMessage = await prisma.rulesMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RulesMessageCreateManyArgs>(args?: SelectSubset<T, RulesMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RulesMessages and returns the data saved in the database.
     * @param {RulesMessageCreateManyAndReturnArgs} args - Arguments to create many RulesMessages.
     * @example
     * // Create many RulesMessages
     * const rulesMessage = await prisma.rulesMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RulesMessages and only return the `id`
     * const rulesMessageWithIdOnly = await prisma.rulesMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RulesMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, RulesMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RulesMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RulesMessage.
     * @param {RulesMessageDeleteArgs} args - Arguments to delete one RulesMessage.
     * @example
     * // Delete one RulesMessage
     * const RulesMessage = await prisma.rulesMessage.delete({
     *   where: {
     *     // ... filter to delete one RulesMessage
     *   }
     * })
     * 
     */
    delete<T extends RulesMessageDeleteArgs>(args: SelectSubset<T, RulesMessageDeleteArgs<ExtArgs>>): Prisma__RulesMessageClient<$Result.GetResult<Prisma.$RulesMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RulesMessage.
     * @param {RulesMessageUpdateArgs} args - Arguments to update one RulesMessage.
     * @example
     * // Update one RulesMessage
     * const rulesMessage = await prisma.rulesMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RulesMessageUpdateArgs>(args: SelectSubset<T, RulesMessageUpdateArgs<ExtArgs>>): Prisma__RulesMessageClient<$Result.GetResult<Prisma.$RulesMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RulesMessages.
     * @param {RulesMessageDeleteManyArgs} args - Arguments to filter RulesMessages to delete.
     * @example
     * // Delete a few RulesMessages
     * const { count } = await prisma.rulesMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RulesMessageDeleteManyArgs>(args?: SelectSubset<T, RulesMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RulesMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RulesMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RulesMessages
     * const rulesMessage = await prisma.rulesMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RulesMessageUpdateManyArgs>(args: SelectSubset<T, RulesMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RulesMessages and returns the data updated in the database.
     * @param {RulesMessageUpdateManyAndReturnArgs} args - Arguments to update many RulesMessages.
     * @example
     * // Update many RulesMessages
     * const rulesMessage = await prisma.rulesMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RulesMessages and only return the `id`
     * const rulesMessageWithIdOnly = await prisma.rulesMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RulesMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, RulesMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RulesMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RulesMessage.
     * @param {RulesMessageUpsertArgs} args - Arguments to update or create a RulesMessage.
     * @example
     * // Update or create a RulesMessage
     * const rulesMessage = await prisma.rulesMessage.upsert({
     *   create: {
     *     // ... data to create a RulesMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RulesMessage we want to update
     *   }
     * })
     */
    upsert<T extends RulesMessageUpsertArgs>(args: SelectSubset<T, RulesMessageUpsertArgs<ExtArgs>>): Prisma__RulesMessageClient<$Result.GetResult<Prisma.$RulesMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RulesMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RulesMessageCountArgs} args - Arguments to filter RulesMessages to count.
     * @example
     * // Count the number of RulesMessages
     * const count = await prisma.rulesMessage.count({
     *   where: {
     *     // ... the filter for the RulesMessages we want to count
     *   }
     * })
    **/
    count<T extends RulesMessageCountArgs>(
      args?: Subset<T, RulesMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RulesMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RulesMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RulesMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RulesMessageAggregateArgs>(args: Subset<T, RulesMessageAggregateArgs>): Prisma.PrismaPromise<GetRulesMessageAggregateType<T>>

    /**
     * Group by RulesMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RulesMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RulesMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RulesMessageGroupByArgs['orderBy'] }
        : { orderBy?: RulesMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RulesMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRulesMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RulesMessage model
   */
  readonly fields: RulesMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RulesMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RulesMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends RulesConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RulesConversationDefaultArgs<ExtArgs>>): Prisma__RulesConversationClient<$Result.GetResult<Prisma.$RulesConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RulesMessage model
   */
  interface RulesMessageFieldRefs {
    readonly id: FieldRef<"RulesMessage", 'String'>
    readonly conversationId: FieldRef<"RulesMessage", 'String'>
    readonly type: FieldRef<"RulesMessage", 'String'>
    readonly content: FieldRef<"RulesMessage", 'String'>
    readonly images: FieldRef<"RulesMessage", 'String[]'>
    readonly completed: FieldRef<"RulesMessage", 'Boolean'>
    readonly marketData: FieldRef<"RulesMessage", 'Json'>
    readonly createdAt: FieldRef<"RulesMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RulesMessage findUnique
   */
  export type RulesMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesMessage
     */
    select?: RulesMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesMessage
     */
    omit?: RulesMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesMessageInclude<ExtArgs> | null
    /**
     * Filter, which RulesMessage to fetch.
     */
    where: RulesMessageWhereUniqueInput
  }

  /**
   * RulesMessage findUniqueOrThrow
   */
  export type RulesMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesMessage
     */
    select?: RulesMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesMessage
     */
    omit?: RulesMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesMessageInclude<ExtArgs> | null
    /**
     * Filter, which RulesMessage to fetch.
     */
    where: RulesMessageWhereUniqueInput
  }

  /**
   * RulesMessage findFirst
   */
  export type RulesMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesMessage
     */
    select?: RulesMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesMessage
     */
    omit?: RulesMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesMessageInclude<ExtArgs> | null
    /**
     * Filter, which RulesMessage to fetch.
     */
    where?: RulesMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RulesMessages to fetch.
     */
    orderBy?: RulesMessageOrderByWithRelationInput | RulesMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RulesMessages.
     */
    cursor?: RulesMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RulesMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RulesMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RulesMessages.
     */
    distinct?: RulesMessageScalarFieldEnum | RulesMessageScalarFieldEnum[]
  }

  /**
   * RulesMessage findFirstOrThrow
   */
  export type RulesMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesMessage
     */
    select?: RulesMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesMessage
     */
    omit?: RulesMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesMessageInclude<ExtArgs> | null
    /**
     * Filter, which RulesMessage to fetch.
     */
    where?: RulesMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RulesMessages to fetch.
     */
    orderBy?: RulesMessageOrderByWithRelationInput | RulesMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RulesMessages.
     */
    cursor?: RulesMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RulesMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RulesMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RulesMessages.
     */
    distinct?: RulesMessageScalarFieldEnum | RulesMessageScalarFieldEnum[]
  }

  /**
   * RulesMessage findMany
   */
  export type RulesMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesMessage
     */
    select?: RulesMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesMessage
     */
    omit?: RulesMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesMessageInclude<ExtArgs> | null
    /**
     * Filter, which RulesMessages to fetch.
     */
    where?: RulesMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RulesMessages to fetch.
     */
    orderBy?: RulesMessageOrderByWithRelationInput | RulesMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RulesMessages.
     */
    cursor?: RulesMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RulesMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RulesMessages.
     */
    skip?: number
    distinct?: RulesMessageScalarFieldEnum | RulesMessageScalarFieldEnum[]
  }

  /**
   * RulesMessage create
   */
  export type RulesMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesMessage
     */
    select?: RulesMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesMessage
     */
    omit?: RulesMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a RulesMessage.
     */
    data: XOR<RulesMessageCreateInput, RulesMessageUncheckedCreateInput>
  }

  /**
   * RulesMessage createMany
   */
  export type RulesMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RulesMessages.
     */
    data: RulesMessageCreateManyInput | RulesMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RulesMessage createManyAndReturn
   */
  export type RulesMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesMessage
     */
    select?: RulesMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RulesMessage
     */
    omit?: RulesMessageOmit<ExtArgs> | null
    /**
     * The data used to create many RulesMessages.
     */
    data: RulesMessageCreateManyInput | RulesMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RulesMessage update
   */
  export type RulesMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesMessage
     */
    select?: RulesMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesMessage
     */
    omit?: RulesMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a RulesMessage.
     */
    data: XOR<RulesMessageUpdateInput, RulesMessageUncheckedUpdateInput>
    /**
     * Choose, which RulesMessage to update.
     */
    where: RulesMessageWhereUniqueInput
  }

  /**
   * RulesMessage updateMany
   */
  export type RulesMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RulesMessages.
     */
    data: XOR<RulesMessageUpdateManyMutationInput, RulesMessageUncheckedUpdateManyInput>
    /**
     * Filter which RulesMessages to update
     */
    where?: RulesMessageWhereInput
    /**
     * Limit how many RulesMessages to update.
     */
    limit?: number
  }

  /**
   * RulesMessage updateManyAndReturn
   */
  export type RulesMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesMessage
     */
    select?: RulesMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RulesMessage
     */
    omit?: RulesMessageOmit<ExtArgs> | null
    /**
     * The data used to update RulesMessages.
     */
    data: XOR<RulesMessageUpdateManyMutationInput, RulesMessageUncheckedUpdateManyInput>
    /**
     * Filter which RulesMessages to update
     */
    where?: RulesMessageWhereInput
    /**
     * Limit how many RulesMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RulesMessage upsert
   */
  export type RulesMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesMessage
     */
    select?: RulesMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesMessage
     */
    omit?: RulesMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the RulesMessage to update in case it exists.
     */
    where: RulesMessageWhereUniqueInput
    /**
     * In case the RulesMessage found by the `where` argument doesn't exist, create a new RulesMessage with this data.
     */
    create: XOR<RulesMessageCreateInput, RulesMessageUncheckedCreateInput>
    /**
     * In case the RulesMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RulesMessageUpdateInput, RulesMessageUncheckedUpdateInput>
  }

  /**
   * RulesMessage delete
   */
  export type RulesMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesMessage
     */
    select?: RulesMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesMessage
     */
    omit?: RulesMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesMessageInclude<ExtArgs> | null
    /**
     * Filter which RulesMessage to delete.
     */
    where: RulesMessageWhereUniqueInput
  }

  /**
   * RulesMessage deleteMany
   */
  export type RulesMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RulesMessages to delete
     */
    where?: RulesMessageWhereInput
    /**
     * Limit how many RulesMessages to delete.
     */
    limit?: number
  }

  /**
   * RulesMessage without action
   */
  export type RulesMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesMessage
     */
    select?: RulesMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RulesMessage
     */
    omit?: RulesMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RulesMessageInclude<ExtArgs> | null
  }


  /**
   * Model WatchList
   */

  export type AggregateWatchList = {
    _count: WatchListCountAggregateOutputType | null
    _avg: WatchListAvgAggregateOutputType | null
    _sum: WatchListSumAggregateOutputType | null
    _min: WatchListMinAggregateOutputType | null
    _max: WatchListMaxAggregateOutputType | null
  }

  export type WatchListAvgAggregateOutputType = {
    triggerValue: number | null
  }

  export type WatchListSumAggregateOutputType = {
    triggerValue: number | null
  }

  export type WatchListMinAggregateOutputType = {
    id: string | null
    userId: string | null
    marketId: string | null
    triggerType: string | null
    triggerValue: number | null
    frequency: string | null
    isActive: boolean | null
    isEmailNotification: boolean | null
    isTelegramNotification: boolean | null
    lastNotifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WatchListMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    marketId: string | null
    triggerType: string | null
    triggerValue: number | null
    frequency: string | null
    isActive: boolean | null
    isEmailNotification: boolean | null
    isTelegramNotification: boolean | null
    lastNotifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WatchListCountAggregateOutputType = {
    id: number
    userId: number
    marketId: number
    triggerType: number
    triggerValue: number
    frequency: number
    isActive: number
    isEmailNotification: number
    isTelegramNotification: number
    lastNotifiedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WatchListAvgAggregateInputType = {
    triggerValue?: true
  }

  export type WatchListSumAggregateInputType = {
    triggerValue?: true
  }

  export type WatchListMinAggregateInputType = {
    id?: true
    userId?: true
    marketId?: true
    triggerType?: true
    triggerValue?: true
    frequency?: true
    isActive?: true
    isEmailNotification?: true
    isTelegramNotification?: true
    lastNotifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WatchListMaxAggregateInputType = {
    id?: true
    userId?: true
    marketId?: true
    triggerType?: true
    triggerValue?: true
    frequency?: true
    isActive?: true
    isEmailNotification?: true
    isTelegramNotification?: true
    lastNotifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WatchListCountAggregateInputType = {
    id?: true
    userId?: true
    marketId?: true
    triggerType?: true
    triggerValue?: true
    frequency?: true
    isActive?: true
    isEmailNotification?: true
    isTelegramNotification?: true
    lastNotifiedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WatchListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchList to aggregate.
     */
    where?: WatchListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchLists to fetch.
     */
    orderBy?: WatchListOrderByWithRelationInput | WatchListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WatchListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WatchLists
    **/
    _count?: true | WatchListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WatchListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WatchListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WatchListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WatchListMaxAggregateInputType
  }

  export type GetWatchListAggregateType<T extends WatchListAggregateArgs> = {
        [P in keyof T & keyof AggregateWatchList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWatchList[P]>
      : GetScalarType<T[P], AggregateWatchList[P]>
  }




  export type WatchListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchListWhereInput
    orderBy?: WatchListOrderByWithAggregationInput | WatchListOrderByWithAggregationInput[]
    by: WatchListScalarFieldEnum[] | WatchListScalarFieldEnum
    having?: WatchListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WatchListCountAggregateInputType | true
    _avg?: WatchListAvgAggregateInputType
    _sum?: WatchListSumAggregateInputType
    _min?: WatchListMinAggregateInputType
    _max?: WatchListMaxAggregateInputType
  }

  export type WatchListGroupByOutputType = {
    id: string
    userId: string
    marketId: string
    triggerType: string
    triggerValue: number | null
    frequency: string
    isActive: boolean
    isEmailNotification: boolean
    isTelegramNotification: boolean
    lastNotifiedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: WatchListCountAggregateOutputType | null
    _avg: WatchListAvgAggregateOutputType | null
    _sum: WatchListSumAggregateOutputType | null
    _min: WatchListMinAggregateOutputType | null
    _max: WatchListMaxAggregateOutputType | null
  }

  type GetWatchListGroupByPayload<T extends WatchListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WatchListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WatchListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WatchListGroupByOutputType[P]>
            : GetScalarType<T[P], WatchListGroupByOutputType[P]>
        }
      >
    >


  export type WatchListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    marketId?: boolean
    triggerType?: boolean
    triggerValue?: boolean
    frequency?: boolean
    isActive?: boolean
    isEmailNotification?: boolean
    isTelegramNotification?: boolean
    lastNotifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchList"]>

  export type WatchListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    marketId?: boolean
    triggerType?: boolean
    triggerValue?: boolean
    frequency?: boolean
    isActive?: boolean
    isEmailNotification?: boolean
    isTelegramNotification?: boolean
    lastNotifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchList"]>

  export type WatchListSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    marketId?: boolean
    triggerType?: boolean
    triggerValue?: boolean
    frequency?: boolean
    isActive?: boolean
    isEmailNotification?: boolean
    isTelegramNotification?: boolean
    lastNotifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchList"]>

  export type WatchListSelectScalar = {
    id?: boolean
    userId?: boolean
    marketId?: boolean
    triggerType?: boolean
    triggerValue?: boolean
    frequency?: boolean
    isActive?: boolean
    isEmailNotification?: boolean
    isTelegramNotification?: boolean
    lastNotifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WatchListOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "marketId" | "triggerType" | "triggerValue" | "frequency" | "isActive" | "isEmailNotification" | "isTelegramNotification" | "lastNotifiedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["watchList"]>
  export type WatchListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WatchListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WatchListIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WatchListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WatchList"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      marketId: string
      triggerType: string
      triggerValue: number | null
      frequency: string
      isActive: boolean
      isEmailNotification: boolean
      isTelegramNotification: boolean
      lastNotifiedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["watchList"]>
    composites: {}
  }

  type WatchListGetPayload<S extends boolean | null | undefined | WatchListDefaultArgs> = $Result.GetResult<Prisma.$WatchListPayload, S>

  type WatchListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WatchListFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WatchListCountAggregateInputType | true
    }

  export interface WatchListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WatchList'], meta: { name: 'WatchList' } }
    /**
     * Find zero or one WatchList that matches the filter.
     * @param {WatchListFindUniqueArgs} args - Arguments to find a WatchList
     * @example
     * // Get one WatchList
     * const watchList = await prisma.watchList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WatchListFindUniqueArgs>(args: SelectSubset<T, WatchListFindUniqueArgs<ExtArgs>>): Prisma__WatchListClient<$Result.GetResult<Prisma.$WatchListPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WatchList that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WatchListFindUniqueOrThrowArgs} args - Arguments to find a WatchList
     * @example
     * // Get one WatchList
     * const watchList = await prisma.watchList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WatchListFindUniqueOrThrowArgs>(args: SelectSubset<T, WatchListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WatchListClient<$Result.GetResult<Prisma.$WatchListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WatchList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchListFindFirstArgs} args - Arguments to find a WatchList
     * @example
     * // Get one WatchList
     * const watchList = await prisma.watchList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WatchListFindFirstArgs>(args?: SelectSubset<T, WatchListFindFirstArgs<ExtArgs>>): Prisma__WatchListClient<$Result.GetResult<Prisma.$WatchListPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WatchList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchListFindFirstOrThrowArgs} args - Arguments to find a WatchList
     * @example
     * // Get one WatchList
     * const watchList = await prisma.watchList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WatchListFindFirstOrThrowArgs>(args?: SelectSubset<T, WatchListFindFirstOrThrowArgs<ExtArgs>>): Prisma__WatchListClient<$Result.GetResult<Prisma.$WatchListPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WatchLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WatchLists
     * const watchLists = await prisma.watchList.findMany()
     * 
     * // Get first 10 WatchLists
     * const watchLists = await prisma.watchList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const watchListWithIdOnly = await prisma.watchList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WatchListFindManyArgs>(args?: SelectSubset<T, WatchListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WatchList.
     * @param {WatchListCreateArgs} args - Arguments to create a WatchList.
     * @example
     * // Create one WatchList
     * const WatchList = await prisma.watchList.create({
     *   data: {
     *     // ... data to create a WatchList
     *   }
     * })
     * 
     */
    create<T extends WatchListCreateArgs>(args: SelectSubset<T, WatchListCreateArgs<ExtArgs>>): Prisma__WatchListClient<$Result.GetResult<Prisma.$WatchListPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WatchLists.
     * @param {WatchListCreateManyArgs} args - Arguments to create many WatchLists.
     * @example
     * // Create many WatchLists
     * const watchList = await prisma.watchList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WatchListCreateManyArgs>(args?: SelectSubset<T, WatchListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WatchLists and returns the data saved in the database.
     * @param {WatchListCreateManyAndReturnArgs} args - Arguments to create many WatchLists.
     * @example
     * // Create many WatchLists
     * const watchList = await prisma.watchList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WatchLists and only return the `id`
     * const watchListWithIdOnly = await prisma.watchList.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WatchListCreateManyAndReturnArgs>(args?: SelectSubset<T, WatchListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchListPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WatchList.
     * @param {WatchListDeleteArgs} args - Arguments to delete one WatchList.
     * @example
     * // Delete one WatchList
     * const WatchList = await prisma.watchList.delete({
     *   where: {
     *     // ... filter to delete one WatchList
     *   }
     * })
     * 
     */
    delete<T extends WatchListDeleteArgs>(args: SelectSubset<T, WatchListDeleteArgs<ExtArgs>>): Prisma__WatchListClient<$Result.GetResult<Prisma.$WatchListPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WatchList.
     * @param {WatchListUpdateArgs} args - Arguments to update one WatchList.
     * @example
     * // Update one WatchList
     * const watchList = await prisma.watchList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WatchListUpdateArgs>(args: SelectSubset<T, WatchListUpdateArgs<ExtArgs>>): Prisma__WatchListClient<$Result.GetResult<Prisma.$WatchListPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WatchLists.
     * @param {WatchListDeleteManyArgs} args - Arguments to filter WatchLists to delete.
     * @example
     * // Delete a few WatchLists
     * const { count } = await prisma.watchList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WatchListDeleteManyArgs>(args?: SelectSubset<T, WatchListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WatchLists
     * const watchList = await prisma.watchList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WatchListUpdateManyArgs>(args: SelectSubset<T, WatchListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchLists and returns the data updated in the database.
     * @param {WatchListUpdateManyAndReturnArgs} args - Arguments to update many WatchLists.
     * @example
     * // Update many WatchLists
     * const watchList = await prisma.watchList.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WatchLists and only return the `id`
     * const watchListWithIdOnly = await prisma.watchList.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WatchListUpdateManyAndReturnArgs>(args: SelectSubset<T, WatchListUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchListPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WatchList.
     * @param {WatchListUpsertArgs} args - Arguments to update or create a WatchList.
     * @example
     * // Update or create a WatchList
     * const watchList = await prisma.watchList.upsert({
     *   create: {
     *     // ... data to create a WatchList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WatchList we want to update
     *   }
     * })
     */
    upsert<T extends WatchListUpsertArgs>(args: SelectSubset<T, WatchListUpsertArgs<ExtArgs>>): Prisma__WatchListClient<$Result.GetResult<Prisma.$WatchListPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WatchLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchListCountArgs} args - Arguments to filter WatchLists to count.
     * @example
     * // Count the number of WatchLists
     * const count = await prisma.watchList.count({
     *   where: {
     *     // ... the filter for the WatchLists we want to count
     *   }
     * })
    **/
    count<T extends WatchListCountArgs>(
      args?: Subset<T, WatchListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WatchListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WatchList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WatchListAggregateArgs>(args: Subset<T, WatchListAggregateArgs>): Prisma.PrismaPromise<GetWatchListAggregateType<T>>

    /**
     * Group by WatchList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WatchListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WatchListGroupByArgs['orderBy'] }
        : { orderBy?: WatchListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WatchListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWatchListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WatchList model
   */
  readonly fields: WatchListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WatchList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WatchListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WatchList model
   */
  interface WatchListFieldRefs {
    readonly id: FieldRef<"WatchList", 'String'>
    readonly userId: FieldRef<"WatchList", 'String'>
    readonly marketId: FieldRef<"WatchList", 'String'>
    readonly triggerType: FieldRef<"WatchList", 'String'>
    readonly triggerValue: FieldRef<"WatchList", 'Float'>
    readonly frequency: FieldRef<"WatchList", 'String'>
    readonly isActive: FieldRef<"WatchList", 'Boolean'>
    readonly isEmailNotification: FieldRef<"WatchList", 'Boolean'>
    readonly isTelegramNotification: FieldRef<"WatchList", 'Boolean'>
    readonly lastNotifiedAt: FieldRef<"WatchList", 'DateTime'>
    readonly createdAt: FieldRef<"WatchList", 'DateTime'>
    readonly updatedAt: FieldRef<"WatchList", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WatchList findUnique
   */
  export type WatchListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchList
     */
    select?: WatchListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchList
     */
    omit?: WatchListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchListInclude<ExtArgs> | null
    /**
     * Filter, which WatchList to fetch.
     */
    where: WatchListWhereUniqueInput
  }

  /**
   * WatchList findUniqueOrThrow
   */
  export type WatchListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchList
     */
    select?: WatchListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchList
     */
    omit?: WatchListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchListInclude<ExtArgs> | null
    /**
     * Filter, which WatchList to fetch.
     */
    where: WatchListWhereUniqueInput
  }

  /**
   * WatchList findFirst
   */
  export type WatchListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchList
     */
    select?: WatchListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchList
     */
    omit?: WatchListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchListInclude<ExtArgs> | null
    /**
     * Filter, which WatchList to fetch.
     */
    where?: WatchListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchLists to fetch.
     */
    orderBy?: WatchListOrderByWithRelationInput | WatchListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchLists.
     */
    cursor?: WatchListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchLists.
     */
    distinct?: WatchListScalarFieldEnum | WatchListScalarFieldEnum[]
  }

  /**
   * WatchList findFirstOrThrow
   */
  export type WatchListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchList
     */
    select?: WatchListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchList
     */
    omit?: WatchListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchListInclude<ExtArgs> | null
    /**
     * Filter, which WatchList to fetch.
     */
    where?: WatchListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchLists to fetch.
     */
    orderBy?: WatchListOrderByWithRelationInput | WatchListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchLists.
     */
    cursor?: WatchListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchLists.
     */
    distinct?: WatchListScalarFieldEnum | WatchListScalarFieldEnum[]
  }

  /**
   * WatchList findMany
   */
  export type WatchListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchList
     */
    select?: WatchListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchList
     */
    omit?: WatchListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchListInclude<ExtArgs> | null
    /**
     * Filter, which WatchLists to fetch.
     */
    where?: WatchListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchLists to fetch.
     */
    orderBy?: WatchListOrderByWithRelationInput | WatchListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WatchLists.
     */
    cursor?: WatchListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchLists.
     */
    skip?: number
    distinct?: WatchListScalarFieldEnum | WatchListScalarFieldEnum[]
  }

  /**
   * WatchList create
   */
  export type WatchListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchList
     */
    select?: WatchListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchList
     */
    omit?: WatchListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchListInclude<ExtArgs> | null
    /**
     * The data needed to create a WatchList.
     */
    data: XOR<WatchListCreateInput, WatchListUncheckedCreateInput>
  }

  /**
   * WatchList createMany
   */
  export type WatchListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WatchLists.
     */
    data: WatchListCreateManyInput | WatchListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WatchList createManyAndReturn
   */
  export type WatchListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchList
     */
    select?: WatchListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WatchList
     */
    omit?: WatchListOmit<ExtArgs> | null
    /**
     * The data used to create many WatchLists.
     */
    data: WatchListCreateManyInput | WatchListCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchListIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WatchList update
   */
  export type WatchListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchList
     */
    select?: WatchListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchList
     */
    omit?: WatchListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchListInclude<ExtArgs> | null
    /**
     * The data needed to update a WatchList.
     */
    data: XOR<WatchListUpdateInput, WatchListUncheckedUpdateInput>
    /**
     * Choose, which WatchList to update.
     */
    where: WatchListWhereUniqueInput
  }

  /**
   * WatchList updateMany
   */
  export type WatchListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WatchLists.
     */
    data: XOR<WatchListUpdateManyMutationInput, WatchListUncheckedUpdateManyInput>
    /**
     * Filter which WatchLists to update
     */
    where?: WatchListWhereInput
    /**
     * Limit how many WatchLists to update.
     */
    limit?: number
  }

  /**
   * WatchList updateManyAndReturn
   */
  export type WatchListUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchList
     */
    select?: WatchListSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WatchList
     */
    omit?: WatchListOmit<ExtArgs> | null
    /**
     * The data used to update WatchLists.
     */
    data: XOR<WatchListUpdateManyMutationInput, WatchListUncheckedUpdateManyInput>
    /**
     * Filter which WatchLists to update
     */
    where?: WatchListWhereInput
    /**
     * Limit how many WatchLists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchListIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WatchList upsert
   */
  export type WatchListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchList
     */
    select?: WatchListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchList
     */
    omit?: WatchListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchListInclude<ExtArgs> | null
    /**
     * The filter to search for the WatchList to update in case it exists.
     */
    where: WatchListWhereUniqueInput
    /**
     * In case the WatchList found by the `where` argument doesn't exist, create a new WatchList with this data.
     */
    create: XOR<WatchListCreateInput, WatchListUncheckedCreateInput>
    /**
     * In case the WatchList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WatchListUpdateInput, WatchListUncheckedUpdateInput>
  }

  /**
   * WatchList delete
   */
  export type WatchListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchList
     */
    select?: WatchListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchList
     */
    omit?: WatchListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchListInclude<ExtArgs> | null
    /**
     * Filter which WatchList to delete.
     */
    where: WatchListWhereUniqueInput
  }

  /**
   * WatchList deleteMany
   */
  export type WatchListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchLists to delete
     */
    where?: WatchListWhereInput
    /**
     * Limit how many WatchLists to delete.
     */
    limit?: number
  }

  /**
   * WatchList without action
   */
  export type WatchListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchList
     */
    select?: WatchListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchList
     */
    omit?: WatchListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchListInclude<ExtArgs> | null
  }


  /**
   * Model Market
   */

  export type AggregateMarket = {
    _count: MarketCountAggregateOutputType | null
    _avg: MarketAvgAggregateOutputType | null
    _sum: MarketSumAggregateOutputType | null
    _min: MarketMinAggregateOutputType | null
    _max: MarketMaxAggregateOutputType | null
  }

  export type MarketAvgAggregateOutputType = {
    liquidity: number | null
    volume: number | null
    volume24hr: number | null
    outcomePrices: number | null
  }

  export type MarketSumAggregateOutputType = {
    liquidity: number | null
    volume: number | null
    volume24hr: number | null
    outcomePrices: number[]
  }

  export type MarketMinAggregateOutputType = {
    id: string | null
    conditionId: string | null
    marketId: string | null
    question: string | null
    slug: string | null
    liquidity: number | null
    volume: number | null
    volume24hr: number | null
    active: boolean | null
    closed: boolean | null
    archived: boolean | null
    image: string | null
    category: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketMaxAggregateOutputType = {
    id: string | null
    conditionId: string | null
    marketId: string | null
    question: string | null
    slug: string | null
    liquidity: number | null
    volume: number | null
    volume24hr: number | null
    active: boolean | null
    closed: boolean | null
    archived: boolean | null
    image: string | null
    category: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketCountAggregateOutputType = {
    id: number
    conditionId: number
    marketId: number
    question: number
    slug: number
    liquidity: number
    volume: number
    volume24hr: number
    active: number
    closed: number
    archived: number
    image: number
    category: number
    tags: number
    outcomes: number
    outcomePrices: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketAvgAggregateInputType = {
    liquidity?: true
    volume?: true
    volume24hr?: true
    outcomePrices?: true
  }

  export type MarketSumAggregateInputType = {
    liquidity?: true
    volume?: true
    volume24hr?: true
    outcomePrices?: true
  }

  export type MarketMinAggregateInputType = {
    id?: true
    conditionId?: true
    marketId?: true
    question?: true
    slug?: true
    liquidity?: true
    volume?: true
    volume24hr?: true
    active?: true
    closed?: true
    archived?: true
    image?: true
    category?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketMaxAggregateInputType = {
    id?: true
    conditionId?: true
    marketId?: true
    question?: true
    slug?: true
    liquidity?: true
    volume?: true
    volume24hr?: true
    active?: true
    closed?: true
    archived?: true
    image?: true
    category?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketCountAggregateInputType = {
    id?: true
    conditionId?: true
    marketId?: true
    question?: true
    slug?: true
    liquidity?: true
    volume?: true
    volume24hr?: true
    active?: true
    closed?: true
    archived?: true
    image?: true
    category?: true
    tags?: true
    outcomes?: true
    outcomePrices?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Market to aggregate.
     */
    where?: MarketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Markets to fetch.
     */
    orderBy?: MarketOrderByWithRelationInput | MarketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Markets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Markets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Markets
    **/
    _count?: true | MarketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketMaxAggregateInputType
  }

  export type GetMarketAggregateType<T extends MarketAggregateArgs> = {
        [P in keyof T & keyof AggregateMarket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarket[P]>
      : GetScalarType<T[P], AggregateMarket[P]>
  }




  export type MarketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketWhereInput
    orderBy?: MarketOrderByWithAggregationInput | MarketOrderByWithAggregationInput[]
    by: MarketScalarFieldEnum[] | MarketScalarFieldEnum
    having?: MarketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketCountAggregateInputType | true
    _avg?: MarketAvgAggregateInputType
    _sum?: MarketSumAggregateInputType
    _min?: MarketMinAggregateInputType
    _max?: MarketMaxAggregateInputType
  }

  export type MarketGroupByOutputType = {
    id: string
    conditionId: string
    marketId: string | null
    question: string
    slug: string | null
    liquidity: number
    volume: number
    volume24hr: number
    active: boolean
    closed: boolean
    archived: boolean
    image: string | null
    category: string | null
    tags: string[]
    outcomes: string[]
    outcomePrices: number[]
    startDate: Date | null
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MarketCountAggregateOutputType | null
    _avg: MarketAvgAggregateOutputType | null
    _sum: MarketSumAggregateOutputType | null
    _min: MarketMinAggregateOutputType | null
    _max: MarketMaxAggregateOutputType | null
  }

  type GetMarketGroupByPayload<T extends MarketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketGroupByOutputType[P]>
            : GetScalarType<T[P], MarketGroupByOutputType[P]>
        }
      >
    >


  export type MarketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conditionId?: boolean
    marketId?: boolean
    question?: boolean
    slug?: boolean
    liquidity?: boolean
    volume?: boolean
    volume24hr?: boolean
    active?: boolean
    closed?: boolean
    archived?: boolean
    image?: boolean
    category?: boolean
    tags?: boolean
    outcomes?: boolean
    outcomePrices?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["market"]>

  export type MarketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conditionId?: boolean
    marketId?: boolean
    question?: boolean
    slug?: boolean
    liquidity?: boolean
    volume?: boolean
    volume24hr?: boolean
    active?: boolean
    closed?: boolean
    archived?: boolean
    image?: boolean
    category?: boolean
    tags?: boolean
    outcomes?: boolean
    outcomePrices?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["market"]>

  export type MarketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conditionId?: boolean
    marketId?: boolean
    question?: boolean
    slug?: boolean
    liquidity?: boolean
    volume?: boolean
    volume24hr?: boolean
    active?: boolean
    closed?: boolean
    archived?: boolean
    image?: boolean
    category?: boolean
    tags?: boolean
    outcomes?: boolean
    outcomePrices?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["market"]>

  export type MarketSelectScalar = {
    id?: boolean
    conditionId?: boolean
    marketId?: boolean
    question?: boolean
    slug?: boolean
    liquidity?: boolean
    volume?: boolean
    volume24hr?: boolean
    active?: boolean
    closed?: boolean
    archived?: boolean
    image?: boolean
    category?: boolean
    tags?: boolean
    outcomes?: boolean
    outcomePrices?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MarketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conditionId" | "marketId" | "question" | "slug" | "liquidity" | "volume" | "volume24hr" | "active" | "closed" | "archived" | "image" | "category" | "tags" | "outcomes" | "outcomePrices" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["market"]>

  export type $MarketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Market"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conditionId: string
      marketId: string | null
      question: string
      slug: string | null
      liquidity: number
      volume: number
      volume24hr: number
      active: boolean
      closed: boolean
      archived: boolean
      image: string | null
      category: string | null
      tags: string[]
      outcomes: string[]
      outcomePrices: number[]
      startDate: Date | null
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["market"]>
    composites: {}
  }

  type MarketGetPayload<S extends boolean | null | undefined | MarketDefaultArgs> = $Result.GetResult<Prisma.$MarketPayload, S>

  type MarketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketCountAggregateInputType | true
    }

  export interface MarketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Market'], meta: { name: 'Market' } }
    /**
     * Find zero or one Market that matches the filter.
     * @param {MarketFindUniqueArgs} args - Arguments to find a Market
     * @example
     * // Get one Market
     * const market = await prisma.market.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketFindUniqueArgs>(args: SelectSubset<T, MarketFindUniqueArgs<ExtArgs>>): Prisma__MarketClient<$Result.GetResult<Prisma.$MarketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Market that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketFindUniqueOrThrowArgs} args - Arguments to find a Market
     * @example
     * // Get one Market
     * const market = await prisma.market.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketClient<$Result.GetResult<Prisma.$MarketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Market that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketFindFirstArgs} args - Arguments to find a Market
     * @example
     * // Get one Market
     * const market = await prisma.market.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketFindFirstArgs>(args?: SelectSubset<T, MarketFindFirstArgs<ExtArgs>>): Prisma__MarketClient<$Result.GetResult<Prisma.$MarketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Market that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketFindFirstOrThrowArgs} args - Arguments to find a Market
     * @example
     * // Get one Market
     * const market = await prisma.market.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketClient<$Result.GetResult<Prisma.$MarketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Markets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Markets
     * const markets = await prisma.market.findMany()
     * 
     * // Get first 10 Markets
     * const markets = await prisma.market.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketWithIdOnly = await prisma.market.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketFindManyArgs>(args?: SelectSubset<T, MarketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Market.
     * @param {MarketCreateArgs} args - Arguments to create a Market.
     * @example
     * // Create one Market
     * const Market = await prisma.market.create({
     *   data: {
     *     // ... data to create a Market
     *   }
     * })
     * 
     */
    create<T extends MarketCreateArgs>(args: SelectSubset<T, MarketCreateArgs<ExtArgs>>): Prisma__MarketClient<$Result.GetResult<Prisma.$MarketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Markets.
     * @param {MarketCreateManyArgs} args - Arguments to create many Markets.
     * @example
     * // Create many Markets
     * const market = await prisma.market.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketCreateManyArgs>(args?: SelectSubset<T, MarketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Markets and returns the data saved in the database.
     * @param {MarketCreateManyAndReturnArgs} args - Arguments to create many Markets.
     * @example
     * // Create many Markets
     * const market = await prisma.market.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Markets and only return the `id`
     * const marketWithIdOnly = await prisma.market.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Market.
     * @param {MarketDeleteArgs} args - Arguments to delete one Market.
     * @example
     * // Delete one Market
     * const Market = await prisma.market.delete({
     *   where: {
     *     // ... filter to delete one Market
     *   }
     * })
     * 
     */
    delete<T extends MarketDeleteArgs>(args: SelectSubset<T, MarketDeleteArgs<ExtArgs>>): Prisma__MarketClient<$Result.GetResult<Prisma.$MarketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Market.
     * @param {MarketUpdateArgs} args - Arguments to update one Market.
     * @example
     * // Update one Market
     * const market = await prisma.market.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketUpdateArgs>(args: SelectSubset<T, MarketUpdateArgs<ExtArgs>>): Prisma__MarketClient<$Result.GetResult<Prisma.$MarketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Markets.
     * @param {MarketDeleteManyArgs} args - Arguments to filter Markets to delete.
     * @example
     * // Delete a few Markets
     * const { count } = await prisma.market.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketDeleteManyArgs>(args?: SelectSubset<T, MarketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Markets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Markets
     * const market = await prisma.market.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketUpdateManyArgs>(args: SelectSubset<T, MarketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Markets and returns the data updated in the database.
     * @param {MarketUpdateManyAndReturnArgs} args - Arguments to update many Markets.
     * @example
     * // Update many Markets
     * const market = await prisma.market.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Markets and only return the `id`
     * const marketWithIdOnly = await prisma.market.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MarketUpdateManyAndReturnArgs>(args: SelectSubset<T, MarketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Market.
     * @param {MarketUpsertArgs} args - Arguments to update or create a Market.
     * @example
     * // Update or create a Market
     * const market = await prisma.market.upsert({
     *   create: {
     *     // ... data to create a Market
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Market we want to update
     *   }
     * })
     */
    upsert<T extends MarketUpsertArgs>(args: SelectSubset<T, MarketUpsertArgs<ExtArgs>>): Prisma__MarketClient<$Result.GetResult<Prisma.$MarketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Markets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketCountArgs} args - Arguments to filter Markets to count.
     * @example
     * // Count the number of Markets
     * const count = await prisma.market.count({
     *   where: {
     *     // ... the filter for the Markets we want to count
     *   }
     * })
    **/
    count<T extends MarketCountArgs>(
      args?: Subset<T, MarketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Market.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketAggregateArgs>(args: Subset<T, MarketAggregateArgs>): Prisma.PrismaPromise<GetMarketAggregateType<T>>

    /**
     * Group by Market.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketGroupByArgs['orderBy'] }
        : { orderBy?: MarketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Market model
   */
  readonly fields: MarketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Market.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Market model
   */
  interface MarketFieldRefs {
    readonly id: FieldRef<"Market", 'String'>
    readonly conditionId: FieldRef<"Market", 'String'>
    readonly marketId: FieldRef<"Market", 'String'>
    readonly question: FieldRef<"Market", 'String'>
    readonly slug: FieldRef<"Market", 'String'>
    readonly liquidity: FieldRef<"Market", 'Float'>
    readonly volume: FieldRef<"Market", 'Float'>
    readonly volume24hr: FieldRef<"Market", 'Float'>
    readonly active: FieldRef<"Market", 'Boolean'>
    readonly closed: FieldRef<"Market", 'Boolean'>
    readonly archived: FieldRef<"Market", 'Boolean'>
    readonly image: FieldRef<"Market", 'String'>
    readonly category: FieldRef<"Market", 'String'>
    readonly tags: FieldRef<"Market", 'String[]'>
    readonly outcomes: FieldRef<"Market", 'String[]'>
    readonly outcomePrices: FieldRef<"Market", 'Float[]'>
    readonly startDate: FieldRef<"Market", 'DateTime'>
    readonly endDate: FieldRef<"Market", 'DateTime'>
    readonly createdAt: FieldRef<"Market", 'DateTime'>
    readonly updatedAt: FieldRef<"Market", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Market findUnique
   */
  export type MarketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Market
     */
    select?: MarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Market
     */
    omit?: MarketOmit<ExtArgs> | null
    /**
     * Filter, which Market to fetch.
     */
    where: MarketWhereUniqueInput
  }

  /**
   * Market findUniqueOrThrow
   */
  export type MarketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Market
     */
    select?: MarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Market
     */
    omit?: MarketOmit<ExtArgs> | null
    /**
     * Filter, which Market to fetch.
     */
    where: MarketWhereUniqueInput
  }

  /**
   * Market findFirst
   */
  export type MarketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Market
     */
    select?: MarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Market
     */
    omit?: MarketOmit<ExtArgs> | null
    /**
     * Filter, which Market to fetch.
     */
    where?: MarketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Markets to fetch.
     */
    orderBy?: MarketOrderByWithRelationInput | MarketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Markets.
     */
    cursor?: MarketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Markets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Markets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Markets.
     */
    distinct?: MarketScalarFieldEnum | MarketScalarFieldEnum[]
  }

  /**
   * Market findFirstOrThrow
   */
  export type MarketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Market
     */
    select?: MarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Market
     */
    omit?: MarketOmit<ExtArgs> | null
    /**
     * Filter, which Market to fetch.
     */
    where?: MarketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Markets to fetch.
     */
    orderBy?: MarketOrderByWithRelationInput | MarketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Markets.
     */
    cursor?: MarketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Markets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Markets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Markets.
     */
    distinct?: MarketScalarFieldEnum | MarketScalarFieldEnum[]
  }

  /**
   * Market findMany
   */
  export type MarketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Market
     */
    select?: MarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Market
     */
    omit?: MarketOmit<ExtArgs> | null
    /**
     * Filter, which Markets to fetch.
     */
    where?: MarketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Markets to fetch.
     */
    orderBy?: MarketOrderByWithRelationInput | MarketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Markets.
     */
    cursor?: MarketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Markets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Markets.
     */
    skip?: number
    distinct?: MarketScalarFieldEnum | MarketScalarFieldEnum[]
  }

  /**
   * Market create
   */
  export type MarketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Market
     */
    select?: MarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Market
     */
    omit?: MarketOmit<ExtArgs> | null
    /**
     * The data needed to create a Market.
     */
    data: XOR<MarketCreateInput, MarketUncheckedCreateInput>
  }

  /**
   * Market createMany
   */
  export type MarketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Markets.
     */
    data: MarketCreateManyInput | MarketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Market createManyAndReturn
   */
  export type MarketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Market
     */
    select?: MarketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Market
     */
    omit?: MarketOmit<ExtArgs> | null
    /**
     * The data used to create many Markets.
     */
    data: MarketCreateManyInput | MarketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Market update
   */
  export type MarketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Market
     */
    select?: MarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Market
     */
    omit?: MarketOmit<ExtArgs> | null
    /**
     * The data needed to update a Market.
     */
    data: XOR<MarketUpdateInput, MarketUncheckedUpdateInput>
    /**
     * Choose, which Market to update.
     */
    where: MarketWhereUniqueInput
  }

  /**
   * Market updateMany
   */
  export type MarketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Markets.
     */
    data: XOR<MarketUpdateManyMutationInput, MarketUncheckedUpdateManyInput>
    /**
     * Filter which Markets to update
     */
    where?: MarketWhereInput
    /**
     * Limit how many Markets to update.
     */
    limit?: number
  }

  /**
   * Market updateManyAndReturn
   */
  export type MarketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Market
     */
    select?: MarketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Market
     */
    omit?: MarketOmit<ExtArgs> | null
    /**
     * The data used to update Markets.
     */
    data: XOR<MarketUpdateManyMutationInput, MarketUncheckedUpdateManyInput>
    /**
     * Filter which Markets to update
     */
    where?: MarketWhereInput
    /**
     * Limit how many Markets to update.
     */
    limit?: number
  }

  /**
   * Market upsert
   */
  export type MarketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Market
     */
    select?: MarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Market
     */
    omit?: MarketOmit<ExtArgs> | null
    /**
     * The filter to search for the Market to update in case it exists.
     */
    where: MarketWhereUniqueInput
    /**
     * In case the Market found by the `where` argument doesn't exist, create a new Market with this data.
     */
    create: XOR<MarketCreateInput, MarketUncheckedCreateInput>
    /**
     * In case the Market was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketUpdateInput, MarketUncheckedUpdateInput>
  }

  /**
   * Market delete
   */
  export type MarketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Market
     */
    select?: MarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Market
     */
    omit?: MarketOmit<ExtArgs> | null
    /**
     * Filter which Market to delete.
     */
    where: MarketWhereUniqueInput
  }

  /**
   * Market deleteMany
   */
  export type MarketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Markets to delete
     */
    where?: MarketWhereInput
    /**
     * Limit how many Markets to delete.
     */
    limit?: number
  }

  /**
   * Market without action
   */
  export type MarketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Market
     */
    select?: MarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Market
     */
    omit?: MarketOmit<ExtArgs> | null
  }


  /**
   * Model ProxyWallet
   */

  export type AggregateProxyWallet = {
    _count: ProxyWalletCountAggregateOutputType | null
    _min: ProxyWalletMinAggregateOutputType | null
    _max: ProxyWalletMaxAggregateOutputType | null
  }

  export type ProxyWalletMinAggregateOutputType = {
    id: string | null
    address: string | null
    createdAt: Date | null
  }

  export type ProxyWalletMaxAggregateOutputType = {
    id: string | null
    address: string | null
    createdAt: Date | null
  }

  export type ProxyWalletCountAggregateOutputType = {
    id: number
    address: number
    createdAt: number
    _all: number
  }


  export type ProxyWalletMinAggregateInputType = {
    id?: true
    address?: true
    createdAt?: true
  }

  export type ProxyWalletMaxAggregateInputType = {
    id?: true
    address?: true
    createdAt?: true
  }

  export type ProxyWalletCountAggregateInputType = {
    id?: true
    address?: true
    createdAt?: true
    _all?: true
  }

  export type ProxyWalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProxyWallet to aggregate.
     */
    where?: ProxyWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyWallets to fetch.
     */
    orderBy?: ProxyWalletOrderByWithRelationInput | ProxyWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProxyWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxyWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProxyWallets
    **/
    _count?: true | ProxyWalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProxyWalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProxyWalletMaxAggregateInputType
  }

  export type GetProxyWalletAggregateType<T extends ProxyWalletAggregateArgs> = {
        [P in keyof T & keyof AggregateProxyWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProxyWallet[P]>
      : GetScalarType<T[P], AggregateProxyWallet[P]>
  }




  export type ProxyWalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxyWalletWhereInput
    orderBy?: ProxyWalletOrderByWithAggregationInput | ProxyWalletOrderByWithAggregationInput[]
    by: ProxyWalletScalarFieldEnum[] | ProxyWalletScalarFieldEnum
    having?: ProxyWalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProxyWalletCountAggregateInputType | true
    _min?: ProxyWalletMinAggregateInputType
    _max?: ProxyWalletMaxAggregateInputType
  }

  export type ProxyWalletGroupByOutputType = {
    id: string
    address: string
    createdAt: Date
    _count: ProxyWalletCountAggregateOutputType | null
    _min: ProxyWalletMinAggregateOutputType | null
    _max: ProxyWalletMaxAggregateOutputType | null
  }

  type GetProxyWalletGroupByPayload<T extends ProxyWalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProxyWalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProxyWalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProxyWalletGroupByOutputType[P]>
            : GetScalarType<T[P], ProxyWalletGroupByOutputType[P]>
        }
      >
    >


  export type ProxyWalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["proxyWallet"]>

  export type ProxyWalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["proxyWallet"]>

  export type ProxyWalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["proxyWallet"]>

  export type ProxyWalletSelectScalar = {
    id?: boolean
    address?: boolean
    createdAt?: boolean
  }

  export type ProxyWalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "address" | "createdAt", ExtArgs["result"]["proxyWallet"]>

  export type $ProxyWalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProxyWallet"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      address: string
      createdAt: Date
    }, ExtArgs["result"]["proxyWallet"]>
    composites: {}
  }

  type ProxyWalletGetPayload<S extends boolean | null | undefined | ProxyWalletDefaultArgs> = $Result.GetResult<Prisma.$ProxyWalletPayload, S>

  type ProxyWalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProxyWalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProxyWalletCountAggregateInputType | true
    }

  export interface ProxyWalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProxyWallet'], meta: { name: 'ProxyWallet' } }
    /**
     * Find zero or one ProxyWallet that matches the filter.
     * @param {ProxyWalletFindUniqueArgs} args - Arguments to find a ProxyWallet
     * @example
     * // Get one ProxyWallet
     * const proxyWallet = await prisma.proxyWallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProxyWalletFindUniqueArgs>(args: SelectSubset<T, ProxyWalletFindUniqueArgs<ExtArgs>>): Prisma__ProxyWalletClient<$Result.GetResult<Prisma.$ProxyWalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProxyWallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProxyWalletFindUniqueOrThrowArgs} args - Arguments to find a ProxyWallet
     * @example
     * // Get one ProxyWallet
     * const proxyWallet = await prisma.proxyWallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProxyWalletFindUniqueOrThrowArgs>(args: SelectSubset<T, ProxyWalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProxyWalletClient<$Result.GetResult<Prisma.$ProxyWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProxyWallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyWalletFindFirstArgs} args - Arguments to find a ProxyWallet
     * @example
     * // Get one ProxyWallet
     * const proxyWallet = await prisma.proxyWallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProxyWalletFindFirstArgs>(args?: SelectSubset<T, ProxyWalletFindFirstArgs<ExtArgs>>): Prisma__ProxyWalletClient<$Result.GetResult<Prisma.$ProxyWalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProxyWallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyWalletFindFirstOrThrowArgs} args - Arguments to find a ProxyWallet
     * @example
     * // Get one ProxyWallet
     * const proxyWallet = await prisma.proxyWallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProxyWalletFindFirstOrThrowArgs>(args?: SelectSubset<T, ProxyWalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProxyWalletClient<$Result.GetResult<Prisma.$ProxyWalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProxyWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyWalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProxyWallets
     * const proxyWallets = await prisma.proxyWallet.findMany()
     * 
     * // Get first 10 ProxyWallets
     * const proxyWallets = await prisma.proxyWallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proxyWalletWithIdOnly = await prisma.proxyWallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProxyWalletFindManyArgs>(args?: SelectSubset<T, ProxyWalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyWalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProxyWallet.
     * @param {ProxyWalletCreateArgs} args - Arguments to create a ProxyWallet.
     * @example
     * // Create one ProxyWallet
     * const ProxyWallet = await prisma.proxyWallet.create({
     *   data: {
     *     // ... data to create a ProxyWallet
     *   }
     * })
     * 
     */
    create<T extends ProxyWalletCreateArgs>(args: SelectSubset<T, ProxyWalletCreateArgs<ExtArgs>>): Prisma__ProxyWalletClient<$Result.GetResult<Prisma.$ProxyWalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProxyWallets.
     * @param {ProxyWalletCreateManyArgs} args - Arguments to create many ProxyWallets.
     * @example
     * // Create many ProxyWallets
     * const proxyWallet = await prisma.proxyWallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProxyWalletCreateManyArgs>(args?: SelectSubset<T, ProxyWalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProxyWallets and returns the data saved in the database.
     * @param {ProxyWalletCreateManyAndReturnArgs} args - Arguments to create many ProxyWallets.
     * @example
     * // Create many ProxyWallets
     * const proxyWallet = await prisma.proxyWallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProxyWallets and only return the `id`
     * const proxyWalletWithIdOnly = await prisma.proxyWallet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProxyWalletCreateManyAndReturnArgs>(args?: SelectSubset<T, ProxyWalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyWalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProxyWallet.
     * @param {ProxyWalletDeleteArgs} args - Arguments to delete one ProxyWallet.
     * @example
     * // Delete one ProxyWallet
     * const ProxyWallet = await prisma.proxyWallet.delete({
     *   where: {
     *     // ... filter to delete one ProxyWallet
     *   }
     * })
     * 
     */
    delete<T extends ProxyWalletDeleteArgs>(args: SelectSubset<T, ProxyWalletDeleteArgs<ExtArgs>>): Prisma__ProxyWalletClient<$Result.GetResult<Prisma.$ProxyWalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProxyWallet.
     * @param {ProxyWalletUpdateArgs} args - Arguments to update one ProxyWallet.
     * @example
     * // Update one ProxyWallet
     * const proxyWallet = await prisma.proxyWallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProxyWalletUpdateArgs>(args: SelectSubset<T, ProxyWalletUpdateArgs<ExtArgs>>): Prisma__ProxyWalletClient<$Result.GetResult<Prisma.$ProxyWalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProxyWallets.
     * @param {ProxyWalletDeleteManyArgs} args - Arguments to filter ProxyWallets to delete.
     * @example
     * // Delete a few ProxyWallets
     * const { count } = await prisma.proxyWallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProxyWalletDeleteManyArgs>(args?: SelectSubset<T, ProxyWalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProxyWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyWalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProxyWallets
     * const proxyWallet = await prisma.proxyWallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProxyWalletUpdateManyArgs>(args: SelectSubset<T, ProxyWalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProxyWallets and returns the data updated in the database.
     * @param {ProxyWalletUpdateManyAndReturnArgs} args - Arguments to update many ProxyWallets.
     * @example
     * // Update many ProxyWallets
     * const proxyWallet = await prisma.proxyWallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProxyWallets and only return the `id`
     * const proxyWalletWithIdOnly = await prisma.proxyWallet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProxyWalletUpdateManyAndReturnArgs>(args: SelectSubset<T, ProxyWalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyWalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProxyWallet.
     * @param {ProxyWalletUpsertArgs} args - Arguments to update or create a ProxyWallet.
     * @example
     * // Update or create a ProxyWallet
     * const proxyWallet = await prisma.proxyWallet.upsert({
     *   create: {
     *     // ... data to create a ProxyWallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProxyWallet we want to update
     *   }
     * })
     */
    upsert<T extends ProxyWalletUpsertArgs>(args: SelectSubset<T, ProxyWalletUpsertArgs<ExtArgs>>): Prisma__ProxyWalletClient<$Result.GetResult<Prisma.$ProxyWalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProxyWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyWalletCountArgs} args - Arguments to filter ProxyWallets to count.
     * @example
     * // Count the number of ProxyWallets
     * const count = await prisma.proxyWallet.count({
     *   where: {
     *     // ... the filter for the ProxyWallets we want to count
     *   }
     * })
    **/
    count<T extends ProxyWalletCountArgs>(
      args?: Subset<T, ProxyWalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProxyWalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProxyWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyWalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProxyWalletAggregateArgs>(args: Subset<T, ProxyWalletAggregateArgs>): Prisma.PrismaPromise<GetProxyWalletAggregateType<T>>

    /**
     * Group by ProxyWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyWalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProxyWalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProxyWalletGroupByArgs['orderBy'] }
        : { orderBy?: ProxyWalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProxyWalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProxyWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProxyWallet model
   */
  readonly fields: ProxyWalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProxyWallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProxyWalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProxyWallet model
   */
  interface ProxyWalletFieldRefs {
    readonly id: FieldRef<"ProxyWallet", 'String'>
    readonly address: FieldRef<"ProxyWallet", 'String'>
    readonly createdAt: FieldRef<"ProxyWallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProxyWallet findUnique
   */
  export type ProxyWalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyWallet
     */
    select?: ProxyWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyWallet
     */
    omit?: ProxyWalletOmit<ExtArgs> | null
    /**
     * Filter, which ProxyWallet to fetch.
     */
    where: ProxyWalletWhereUniqueInput
  }

  /**
   * ProxyWallet findUniqueOrThrow
   */
  export type ProxyWalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyWallet
     */
    select?: ProxyWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyWallet
     */
    omit?: ProxyWalletOmit<ExtArgs> | null
    /**
     * Filter, which ProxyWallet to fetch.
     */
    where: ProxyWalletWhereUniqueInput
  }

  /**
   * ProxyWallet findFirst
   */
  export type ProxyWalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyWallet
     */
    select?: ProxyWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyWallet
     */
    omit?: ProxyWalletOmit<ExtArgs> | null
    /**
     * Filter, which ProxyWallet to fetch.
     */
    where?: ProxyWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyWallets to fetch.
     */
    orderBy?: ProxyWalletOrderByWithRelationInput | ProxyWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxyWallets.
     */
    cursor?: ProxyWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxyWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxyWallets.
     */
    distinct?: ProxyWalletScalarFieldEnum | ProxyWalletScalarFieldEnum[]
  }

  /**
   * ProxyWallet findFirstOrThrow
   */
  export type ProxyWalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyWallet
     */
    select?: ProxyWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyWallet
     */
    omit?: ProxyWalletOmit<ExtArgs> | null
    /**
     * Filter, which ProxyWallet to fetch.
     */
    where?: ProxyWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyWallets to fetch.
     */
    orderBy?: ProxyWalletOrderByWithRelationInput | ProxyWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxyWallets.
     */
    cursor?: ProxyWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxyWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxyWallets.
     */
    distinct?: ProxyWalletScalarFieldEnum | ProxyWalletScalarFieldEnum[]
  }

  /**
   * ProxyWallet findMany
   */
  export type ProxyWalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyWallet
     */
    select?: ProxyWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyWallet
     */
    omit?: ProxyWalletOmit<ExtArgs> | null
    /**
     * Filter, which ProxyWallets to fetch.
     */
    where?: ProxyWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyWallets to fetch.
     */
    orderBy?: ProxyWalletOrderByWithRelationInput | ProxyWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProxyWallets.
     */
    cursor?: ProxyWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxyWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyWallets.
     */
    skip?: number
    distinct?: ProxyWalletScalarFieldEnum | ProxyWalletScalarFieldEnum[]
  }

  /**
   * ProxyWallet create
   */
  export type ProxyWalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyWallet
     */
    select?: ProxyWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyWallet
     */
    omit?: ProxyWalletOmit<ExtArgs> | null
    /**
     * The data needed to create a ProxyWallet.
     */
    data: XOR<ProxyWalletCreateInput, ProxyWalletUncheckedCreateInput>
  }

  /**
   * ProxyWallet createMany
   */
  export type ProxyWalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProxyWallets.
     */
    data: ProxyWalletCreateManyInput | ProxyWalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProxyWallet createManyAndReturn
   */
  export type ProxyWalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyWallet
     */
    select?: ProxyWalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyWallet
     */
    omit?: ProxyWalletOmit<ExtArgs> | null
    /**
     * The data used to create many ProxyWallets.
     */
    data: ProxyWalletCreateManyInput | ProxyWalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProxyWallet update
   */
  export type ProxyWalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyWallet
     */
    select?: ProxyWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyWallet
     */
    omit?: ProxyWalletOmit<ExtArgs> | null
    /**
     * The data needed to update a ProxyWallet.
     */
    data: XOR<ProxyWalletUpdateInput, ProxyWalletUncheckedUpdateInput>
    /**
     * Choose, which ProxyWallet to update.
     */
    where: ProxyWalletWhereUniqueInput
  }

  /**
   * ProxyWallet updateMany
   */
  export type ProxyWalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProxyWallets.
     */
    data: XOR<ProxyWalletUpdateManyMutationInput, ProxyWalletUncheckedUpdateManyInput>
    /**
     * Filter which ProxyWallets to update
     */
    where?: ProxyWalletWhereInput
    /**
     * Limit how many ProxyWallets to update.
     */
    limit?: number
  }

  /**
   * ProxyWallet updateManyAndReturn
   */
  export type ProxyWalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyWallet
     */
    select?: ProxyWalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyWallet
     */
    omit?: ProxyWalletOmit<ExtArgs> | null
    /**
     * The data used to update ProxyWallets.
     */
    data: XOR<ProxyWalletUpdateManyMutationInput, ProxyWalletUncheckedUpdateManyInput>
    /**
     * Filter which ProxyWallets to update
     */
    where?: ProxyWalletWhereInput
    /**
     * Limit how many ProxyWallets to update.
     */
    limit?: number
  }

  /**
   * ProxyWallet upsert
   */
  export type ProxyWalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyWallet
     */
    select?: ProxyWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyWallet
     */
    omit?: ProxyWalletOmit<ExtArgs> | null
    /**
     * The filter to search for the ProxyWallet to update in case it exists.
     */
    where: ProxyWalletWhereUniqueInput
    /**
     * In case the ProxyWallet found by the `where` argument doesn't exist, create a new ProxyWallet with this data.
     */
    create: XOR<ProxyWalletCreateInput, ProxyWalletUncheckedCreateInput>
    /**
     * In case the ProxyWallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProxyWalletUpdateInput, ProxyWalletUncheckedUpdateInput>
  }

  /**
   * ProxyWallet delete
   */
  export type ProxyWalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyWallet
     */
    select?: ProxyWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyWallet
     */
    omit?: ProxyWalletOmit<ExtArgs> | null
    /**
     * Filter which ProxyWallet to delete.
     */
    where: ProxyWalletWhereUniqueInput
  }

  /**
   * ProxyWallet deleteMany
   */
  export type ProxyWalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProxyWallets to delete
     */
    where?: ProxyWalletWhereInput
    /**
     * Limit how many ProxyWallets to delete.
     */
    limit?: number
  }

  /**
   * ProxyWallet without action
   */
  export type ProxyWalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyWallet
     */
    select?: ProxyWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyWallet
     */
    omit?: ProxyWalletOmit<ExtArgs> | null
  }


  /**
   * Model SyncHistory
   */

  export type AggregateSyncHistory = {
    _count: SyncHistoryCountAggregateOutputType | null
    _avg: SyncHistoryAvgAggregateOutputType | null
    _sum: SyncHistorySumAggregateOutputType | null
    _min: SyncHistoryMinAggregateOutputType | null
    _max: SyncHistoryMaxAggregateOutputType | null
  }

  export type SyncHistoryAvgAggregateOutputType = {
    marketsFound: number | null
    marketsStored: number | null
    marketsFailed: number | null
    walletsFound: number | null
    walletsStored: number | null
  }

  export type SyncHistorySumAggregateOutputType = {
    marketsFound: number | null
    marketsStored: number | null
    marketsFailed: number | null
    walletsFound: number | null
    walletsStored: number | null
  }

  export type SyncHistoryMinAggregateOutputType = {
    id: string | null
    startedAt: Date | null
    completedAt: Date | null
    marketsFound: number | null
    marketsStored: number | null
    marketsFailed: number | null
    walletsFound: number | null
    walletsStored: number | null
    status: $Enums.SyncStatus | null
    error: string | null
  }

  export type SyncHistoryMaxAggregateOutputType = {
    id: string | null
    startedAt: Date | null
    completedAt: Date | null
    marketsFound: number | null
    marketsStored: number | null
    marketsFailed: number | null
    walletsFound: number | null
    walletsStored: number | null
    status: $Enums.SyncStatus | null
    error: string | null
  }

  export type SyncHistoryCountAggregateOutputType = {
    id: number
    startedAt: number
    completedAt: number
    marketsFound: number
    marketsStored: number
    marketsFailed: number
    walletsFound: number
    walletsStored: number
    status: number
    error: number
    _all: number
  }


  export type SyncHistoryAvgAggregateInputType = {
    marketsFound?: true
    marketsStored?: true
    marketsFailed?: true
    walletsFound?: true
    walletsStored?: true
  }

  export type SyncHistorySumAggregateInputType = {
    marketsFound?: true
    marketsStored?: true
    marketsFailed?: true
    walletsFound?: true
    walletsStored?: true
  }

  export type SyncHistoryMinAggregateInputType = {
    id?: true
    startedAt?: true
    completedAt?: true
    marketsFound?: true
    marketsStored?: true
    marketsFailed?: true
    walletsFound?: true
    walletsStored?: true
    status?: true
    error?: true
  }

  export type SyncHistoryMaxAggregateInputType = {
    id?: true
    startedAt?: true
    completedAt?: true
    marketsFound?: true
    marketsStored?: true
    marketsFailed?: true
    walletsFound?: true
    walletsStored?: true
    status?: true
    error?: true
  }

  export type SyncHistoryCountAggregateInputType = {
    id?: true
    startedAt?: true
    completedAt?: true
    marketsFound?: true
    marketsStored?: true
    marketsFailed?: true
    walletsFound?: true
    walletsStored?: true
    status?: true
    error?: true
    _all?: true
  }

  export type SyncHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncHistory to aggregate.
     */
    where?: SyncHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncHistories to fetch.
     */
    orderBy?: SyncHistoryOrderByWithRelationInput | SyncHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncHistories
    **/
    _count?: true | SyncHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyncHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyncHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncHistoryMaxAggregateInputType
  }

  export type GetSyncHistoryAggregateType<T extends SyncHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncHistory[P]>
      : GetScalarType<T[P], AggregateSyncHistory[P]>
  }




  export type SyncHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncHistoryWhereInput
    orderBy?: SyncHistoryOrderByWithAggregationInput | SyncHistoryOrderByWithAggregationInput[]
    by: SyncHistoryScalarFieldEnum[] | SyncHistoryScalarFieldEnum
    having?: SyncHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncHistoryCountAggregateInputType | true
    _avg?: SyncHistoryAvgAggregateInputType
    _sum?: SyncHistorySumAggregateInputType
    _min?: SyncHistoryMinAggregateInputType
    _max?: SyncHistoryMaxAggregateInputType
  }

  export type SyncHistoryGroupByOutputType = {
    id: string
    startedAt: Date
    completedAt: Date | null
    marketsFound: number
    marketsStored: number
    marketsFailed: number
    walletsFound: number
    walletsStored: number
    status: $Enums.SyncStatus
    error: string | null
    _count: SyncHistoryCountAggregateOutputType | null
    _avg: SyncHistoryAvgAggregateOutputType | null
    _sum: SyncHistorySumAggregateOutputType | null
    _min: SyncHistoryMinAggregateOutputType | null
    _max: SyncHistoryMaxAggregateOutputType | null
  }

  type GetSyncHistoryGroupByPayload<T extends SyncHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], SyncHistoryGroupByOutputType[P]>
        }
      >
    >


  export type SyncHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startedAt?: boolean
    completedAt?: boolean
    marketsFound?: boolean
    marketsStored?: boolean
    marketsFailed?: boolean
    walletsFound?: boolean
    walletsStored?: boolean
    status?: boolean
    error?: boolean
  }, ExtArgs["result"]["syncHistory"]>

  export type SyncHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startedAt?: boolean
    completedAt?: boolean
    marketsFound?: boolean
    marketsStored?: boolean
    marketsFailed?: boolean
    walletsFound?: boolean
    walletsStored?: boolean
    status?: boolean
    error?: boolean
  }, ExtArgs["result"]["syncHistory"]>

  export type SyncHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startedAt?: boolean
    completedAt?: boolean
    marketsFound?: boolean
    marketsStored?: boolean
    marketsFailed?: boolean
    walletsFound?: boolean
    walletsStored?: boolean
    status?: boolean
    error?: boolean
  }, ExtArgs["result"]["syncHistory"]>

  export type SyncHistorySelectScalar = {
    id?: boolean
    startedAt?: boolean
    completedAt?: boolean
    marketsFound?: boolean
    marketsStored?: boolean
    marketsFailed?: boolean
    walletsFound?: boolean
    walletsStored?: boolean
    status?: boolean
    error?: boolean
  }

  export type SyncHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "startedAt" | "completedAt" | "marketsFound" | "marketsStored" | "marketsFailed" | "walletsFound" | "walletsStored" | "status" | "error", ExtArgs["result"]["syncHistory"]>

  export type $SyncHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncHistory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startedAt: Date
      completedAt: Date | null
      marketsFound: number
      marketsStored: number
      marketsFailed: number
      walletsFound: number
      walletsStored: number
      status: $Enums.SyncStatus
      error: string | null
    }, ExtArgs["result"]["syncHistory"]>
    composites: {}
  }

  type SyncHistoryGetPayload<S extends boolean | null | undefined | SyncHistoryDefaultArgs> = $Result.GetResult<Prisma.$SyncHistoryPayload, S>

  type SyncHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SyncHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyncHistoryCountAggregateInputType | true
    }

  export interface SyncHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncHistory'], meta: { name: 'SyncHistory' } }
    /**
     * Find zero or one SyncHistory that matches the filter.
     * @param {SyncHistoryFindUniqueArgs} args - Arguments to find a SyncHistory
     * @example
     * // Get one SyncHistory
     * const syncHistory = await prisma.syncHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncHistoryFindUniqueArgs>(args: SelectSubset<T, SyncHistoryFindUniqueArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SyncHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SyncHistoryFindUniqueOrThrowArgs} args - Arguments to find a SyncHistory
     * @example
     * // Get one SyncHistory
     * const syncHistory = await prisma.syncHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryFindFirstArgs} args - Arguments to find a SyncHistory
     * @example
     * // Get one SyncHistory
     * const syncHistory = await prisma.syncHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncHistoryFindFirstArgs>(args?: SelectSubset<T, SyncHistoryFindFirstArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryFindFirstOrThrowArgs} args - Arguments to find a SyncHistory
     * @example
     * // Get one SyncHistory
     * const syncHistory = await prisma.syncHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SyncHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncHistories
     * const syncHistories = await prisma.syncHistory.findMany()
     * 
     * // Get first 10 SyncHistories
     * const syncHistories = await prisma.syncHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncHistoryWithIdOnly = await prisma.syncHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncHistoryFindManyArgs>(args?: SelectSubset<T, SyncHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SyncHistory.
     * @param {SyncHistoryCreateArgs} args - Arguments to create a SyncHistory.
     * @example
     * // Create one SyncHistory
     * const SyncHistory = await prisma.syncHistory.create({
     *   data: {
     *     // ... data to create a SyncHistory
     *   }
     * })
     * 
     */
    create<T extends SyncHistoryCreateArgs>(args: SelectSubset<T, SyncHistoryCreateArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SyncHistories.
     * @param {SyncHistoryCreateManyArgs} args - Arguments to create many SyncHistories.
     * @example
     * // Create many SyncHistories
     * const syncHistory = await prisma.syncHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncHistoryCreateManyArgs>(args?: SelectSubset<T, SyncHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyncHistories and returns the data saved in the database.
     * @param {SyncHistoryCreateManyAndReturnArgs} args - Arguments to create many SyncHistories.
     * @example
     * // Create many SyncHistories
     * const syncHistory = await prisma.syncHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyncHistories and only return the `id`
     * const syncHistoryWithIdOnly = await prisma.syncHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyncHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SyncHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SyncHistory.
     * @param {SyncHistoryDeleteArgs} args - Arguments to delete one SyncHistory.
     * @example
     * // Delete one SyncHistory
     * const SyncHistory = await prisma.syncHistory.delete({
     *   where: {
     *     // ... filter to delete one SyncHistory
     *   }
     * })
     * 
     */
    delete<T extends SyncHistoryDeleteArgs>(args: SelectSubset<T, SyncHistoryDeleteArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SyncHistory.
     * @param {SyncHistoryUpdateArgs} args - Arguments to update one SyncHistory.
     * @example
     * // Update one SyncHistory
     * const syncHistory = await prisma.syncHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncHistoryUpdateArgs>(args: SelectSubset<T, SyncHistoryUpdateArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SyncHistories.
     * @param {SyncHistoryDeleteManyArgs} args - Arguments to filter SyncHistories to delete.
     * @example
     * // Delete a few SyncHistories
     * const { count } = await prisma.syncHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncHistoryDeleteManyArgs>(args?: SelectSubset<T, SyncHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncHistories
     * const syncHistory = await prisma.syncHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncHistoryUpdateManyArgs>(args: SelectSubset<T, SyncHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncHistories and returns the data updated in the database.
     * @param {SyncHistoryUpdateManyAndReturnArgs} args - Arguments to update many SyncHistories.
     * @example
     * // Update many SyncHistories
     * const syncHistory = await prisma.syncHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SyncHistories and only return the `id`
     * const syncHistoryWithIdOnly = await prisma.syncHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SyncHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, SyncHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SyncHistory.
     * @param {SyncHistoryUpsertArgs} args - Arguments to update or create a SyncHistory.
     * @example
     * // Update or create a SyncHistory
     * const syncHistory = await prisma.syncHistory.upsert({
     *   create: {
     *     // ... data to create a SyncHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncHistory we want to update
     *   }
     * })
     */
    upsert<T extends SyncHistoryUpsertArgs>(args: SelectSubset<T, SyncHistoryUpsertArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SyncHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryCountArgs} args - Arguments to filter SyncHistories to count.
     * @example
     * // Count the number of SyncHistories
     * const count = await prisma.syncHistory.count({
     *   where: {
     *     // ... the filter for the SyncHistories we want to count
     *   }
     * })
    **/
    count<T extends SyncHistoryCountArgs>(
      args?: Subset<T, SyncHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncHistoryAggregateArgs>(args: Subset<T, SyncHistoryAggregateArgs>): Prisma.PrismaPromise<GetSyncHistoryAggregateType<T>>

    /**
     * Group by SyncHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncHistoryGroupByArgs['orderBy'] }
        : { orderBy?: SyncHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncHistory model
   */
  readonly fields: SyncHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncHistory model
   */
  interface SyncHistoryFieldRefs {
    readonly id: FieldRef<"SyncHistory", 'String'>
    readonly startedAt: FieldRef<"SyncHistory", 'DateTime'>
    readonly completedAt: FieldRef<"SyncHistory", 'DateTime'>
    readonly marketsFound: FieldRef<"SyncHistory", 'Int'>
    readonly marketsStored: FieldRef<"SyncHistory", 'Int'>
    readonly marketsFailed: FieldRef<"SyncHistory", 'Int'>
    readonly walletsFound: FieldRef<"SyncHistory", 'Int'>
    readonly walletsStored: FieldRef<"SyncHistory", 'Int'>
    readonly status: FieldRef<"SyncHistory", 'SyncStatus'>
    readonly error: FieldRef<"SyncHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SyncHistory findUnique
   */
  export type SyncHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Filter, which SyncHistory to fetch.
     */
    where: SyncHistoryWhereUniqueInput
  }

  /**
   * SyncHistory findUniqueOrThrow
   */
  export type SyncHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Filter, which SyncHistory to fetch.
     */
    where: SyncHistoryWhereUniqueInput
  }

  /**
   * SyncHistory findFirst
   */
  export type SyncHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Filter, which SyncHistory to fetch.
     */
    where?: SyncHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncHistories to fetch.
     */
    orderBy?: SyncHistoryOrderByWithRelationInput | SyncHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncHistories.
     */
    cursor?: SyncHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncHistories.
     */
    distinct?: SyncHistoryScalarFieldEnum | SyncHistoryScalarFieldEnum[]
  }

  /**
   * SyncHistory findFirstOrThrow
   */
  export type SyncHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Filter, which SyncHistory to fetch.
     */
    where?: SyncHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncHistories to fetch.
     */
    orderBy?: SyncHistoryOrderByWithRelationInput | SyncHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncHistories.
     */
    cursor?: SyncHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncHistories.
     */
    distinct?: SyncHistoryScalarFieldEnum | SyncHistoryScalarFieldEnum[]
  }

  /**
   * SyncHistory findMany
   */
  export type SyncHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Filter, which SyncHistories to fetch.
     */
    where?: SyncHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncHistories to fetch.
     */
    orderBy?: SyncHistoryOrderByWithRelationInput | SyncHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncHistories.
     */
    cursor?: SyncHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncHistories.
     */
    skip?: number
    distinct?: SyncHistoryScalarFieldEnum | SyncHistoryScalarFieldEnum[]
  }

  /**
   * SyncHistory create
   */
  export type SyncHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * The data needed to create a SyncHistory.
     */
    data?: XOR<SyncHistoryCreateInput, SyncHistoryUncheckedCreateInput>
  }

  /**
   * SyncHistory createMany
   */
  export type SyncHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncHistories.
     */
    data: SyncHistoryCreateManyInput | SyncHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyncHistory createManyAndReturn
   */
  export type SyncHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many SyncHistories.
     */
    data: SyncHistoryCreateManyInput | SyncHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyncHistory update
   */
  export type SyncHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * The data needed to update a SyncHistory.
     */
    data: XOR<SyncHistoryUpdateInput, SyncHistoryUncheckedUpdateInput>
    /**
     * Choose, which SyncHistory to update.
     */
    where: SyncHistoryWhereUniqueInput
  }

  /**
   * SyncHistory updateMany
   */
  export type SyncHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncHistories.
     */
    data: XOR<SyncHistoryUpdateManyMutationInput, SyncHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SyncHistories to update
     */
    where?: SyncHistoryWhereInput
    /**
     * Limit how many SyncHistories to update.
     */
    limit?: number
  }

  /**
   * SyncHistory updateManyAndReturn
   */
  export type SyncHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * The data used to update SyncHistories.
     */
    data: XOR<SyncHistoryUpdateManyMutationInput, SyncHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SyncHistories to update
     */
    where?: SyncHistoryWhereInput
    /**
     * Limit how many SyncHistories to update.
     */
    limit?: number
  }

  /**
   * SyncHistory upsert
   */
  export type SyncHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * The filter to search for the SyncHistory to update in case it exists.
     */
    where: SyncHistoryWhereUniqueInput
    /**
     * In case the SyncHistory found by the `where` argument doesn't exist, create a new SyncHistory with this data.
     */
    create: XOR<SyncHistoryCreateInput, SyncHistoryUncheckedCreateInput>
    /**
     * In case the SyncHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncHistoryUpdateInput, SyncHistoryUncheckedUpdateInput>
  }

  /**
   * SyncHistory delete
   */
  export type SyncHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Filter which SyncHistory to delete.
     */
    where: SyncHistoryWhereUniqueInput
  }

  /**
   * SyncHistory deleteMany
   */
  export type SyncHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncHistories to delete
     */
    where?: SyncHistoryWhereInput
    /**
     * Limit how many SyncHistories to delete.
     */
    limit?: number
  }

  /**
   * SyncHistory without action
   */
  export type SyncHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
  }


  /**
   * Model UserAnalytics
   */

  export type AggregateUserAnalytics = {
    _count: UserAnalyticsCountAggregateOutputType | null
    _avg: UserAnalyticsAvgAggregateOutputType | null
    _sum: UserAnalyticsSumAggregateOutputType | null
    _min: UserAnalyticsMinAggregateOutputType | null
    _max: UserAnalyticsMaxAggregateOutputType | null
  }

  export type UserAnalyticsAvgAggregateOutputType = {
    totalVolume: number | null
    totalProfit: number | null
    positionValue: number | null
    totalTrades: number | null
    totalPositions: number | null
    averageWinRate: number | null
    avgMonthlyProfit: number | null
    avgMonthlyTrades: number | null
  }

  export type UserAnalyticsSumAggregateOutputType = {
    totalVolume: number | null
    totalProfit: number | null
    positionValue: number | null
    totalTrades: number | null
    totalPositions: number | null
    averageWinRate: number | null
    avgMonthlyProfit: number | null
    avgMonthlyTrades: number | null
  }

  export type UserAnalyticsMinAggregateOutputType = {
    id: string | null
    address: string | null
    totalVolume: number | null
    totalProfit: number | null
    positionValue: number | null
    totalTrades: number | null
    totalPositions: number | null
    averageWinRate: number | null
    avgMonthlyProfit: number | null
    avgMonthlyTrades: number | null
    mostTradedCategory: string | null
    tradingStyle: string | null
    riskProfile: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastSyncedAt: Date | null
  }

  export type UserAnalyticsMaxAggregateOutputType = {
    id: string | null
    address: string | null
    totalVolume: number | null
    totalProfit: number | null
    positionValue: number | null
    totalTrades: number | null
    totalPositions: number | null
    averageWinRate: number | null
    avgMonthlyProfit: number | null
    avgMonthlyTrades: number | null
    mostTradedCategory: string | null
    tradingStyle: string | null
    riskProfile: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastSyncedAt: Date | null
  }

  export type UserAnalyticsCountAggregateOutputType = {
    id: number
    address: number
    totalVolume: number
    totalProfit: number
    positionValue: number
    totalTrades: number
    totalPositions: number
    averageWinRate: number
    avgMonthlyProfit: number
    avgMonthlyTrades: number
    mostTradedCategory: number
    tradingStyle: number
    riskProfile: number
    createdAt: number
    updatedAt: number
    lastSyncedAt: number
    _all: number
  }


  export type UserAnalyticsAvgAggregateInputType = {
    totalVolume?: true
    totalProfit?: true
    positionValue?: true
    totalTrades?: true
    totalPositions?: true
    averageWinRate?: true
    avgMonthlyProfit?: true
    avgMonthlyTrades?: true
  }

  export type UserAnalyticsSumAggregateInputType = {
    totalVolume?: true
    totalProfit?: true
    positionValue?: true
    totalTrades?: true
    totalPositions?: true
    averageWinRate?: true
    avgMonthlyProfit?: true
    avgMonthlyTrades?: true
  }

  export type UserAnalyticsMinAggregateInputType = {
    id?: true
    address?: true
    totalVolume?: true
    totalProfit?: true
    positionValue?: true
    totalTrades?: true
    totalPositions?: true
    averageWinRate?: true
    avgMonthlyProfit?: true
    avgMonthlyTrades?: true
    mostTradedCategory?: true
    tradingStyle?: true
    riskProfile?: true
    createdAt?: true
    updatedAt?: true
    lastSyncedAt?: true
  }

  export type UserAnalyticsMaxAggregateInputType = {
    id?: true
    address?: true
    totalVolume?: true
    totalProfit?: true
    positionValue?: true
    totalTrades?: true
    totalPositions?: true
    averageWinRate?: true
    avgMonthlyProfit?: true
    avgMonthlyTrades?: true
    mostTradedCategory?: true
    tradingStyle?: true
    riskProfile?: true
    createdAt?: true
    updatedAt?: true
    lastSyncedAt?: true
  }

  export type UserAnalyticsCountAggregateInputType = {
    id?: true
    address?: true
    totalVolume?: true
    totalProfit?: true
    positionValue?: true
    totalTrades?: true
    totalPositions?: true
    averageWinRate?: true
    avgMonthlyProfit?: true
    avgMonthlyTrades?: true
    mostTradedCategory?: true
    tradingStyle?: true
    riskProfile?: true
    createdAt?: true
    updatedAt?: true
    lastSyncedAt?: true
    _all?: true
  }

  export type UserAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAnalytics to aggregate.
     */
    where?: UserAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnalytics to fetch.
     */
    orderBy?: UserAnalyticsOrderByWithRelationInput | UserAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAnalytics
    **/
    _count?: true | UserAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAnalyticsMaxAggregateInputType
  }

  export type GetUserAnalyticsAggregateType<T extends UserAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAnalytics[P]>
      : GetScalarType<T[P], AggregateUserAnalytics[P]>
  }




  export type UserAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAnalyticsWhereInput
    orderBy?: UserAnalyticsOrderByWithAggregationInput | UserAnalyticsOrderByWithAggregationInput[]
    by: UserAnalyticsScalarFieldEnum[] | UserAnalyticsScalarFieldEnum
    having?: UserAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAnalyticsCountAggregateInputType | true
    _avg?: UserAnalyticsAvgAggregateInputType
    _sum?: UserAnalyticsSumAggregateInputType
    _min?: UserAnalyticsMinAggregateInputType
    _max?: UserAnalyticsMaxAggregateInputType
  }

  export type UserAnalyticsGroupByOutputType = {
    id: string
    address: string
    totalVolume: number
    totalProfit: number
    positionValue: number
    totalTrades: number
    totalPositions: number
    averageWinRate: number
    avgMonthlyProfit: number
    avgMonthlyTrades: number
    mostTradedCategory: string | null
    tradingStyle: string | null
    riskProfile: string | null
    createdAt: Date
    updatedAt: Date
    lastSyncedAt: Date | null
    _count: UserAnalyticsCountAggregateOutputType | null
    _avg: UserAnalyticsAvgAggregateOutputType | null
    _sum: UserAnalyticsSumAggregateOutputType | null
    _min: UserAnalyticsMinAggregateOutputType | null
    _max: UserAnalyticsMaxAggregateOutputType | null
  }

  type GetUserAnalyticsGroupByPayload<T extends UserAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], UserAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type UserAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    totalVolume?: boolean
    totalProfit?: boolean
    positionValue?: boolean
    totalTrades?: boolean
    totalPositions?: boolean
    averageWinRate?: boolean
    avgMonthlyProfit?: boolean
    avgMonthlyTrades?: boolean
    mostTradedCategory?: boolean
    tradingStyle?: boolean
    riskProfile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastSyncedAt?: boolean
    marketDistribution?: boolean | UserAnalytics$marketDistributionArgs<ExtArgs>
    buySellData?: boolean | UserAnalytics$buySellDataArgs<ExtArgs>
    tradeSizeData?: boolean | UserAnalytics$tradeSizeDataArgs<ExtArgs>
    priceStats?: boolean | UserAnalytics$priceStatsArgs<ExtArgs>
    monthlyPerformance?: boolean | UserAnalytics$monthlyPerformanceArgs<ExtArgs>
    weeklyWinRate?: boolean | UserAnalytics$weeklyWinRateArgs<ExtArgs>
    _count?: boolean | UserAnalyticsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAnalytics"]>

  export type UserAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    totalVolume?: boolean
    totalProfit?: boolean
    positionValue?: boolean
    totalTrades?: boolean
    totalPositions?: boolean
    averageWinRate?: boolean
    avgMonthlyProfit?: boolean
    avgMonthlyTrades?: boolean
    mostTradedCategory?: boolean
    tradingStyle?: boolean
    riskProfile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastSyncedAt?: boolean
  }, ExtArgs["result"]["userAnalytics"]>

  export type UserAnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    totalVolume?: boolean
    totalProfit?: boolean
    positionValue?: boolean
    totalTrades?: boolean
    totalPositions?: boolean
    averageWinRate?: boolean
    avgMonthlyProfit?: boolean
    avgMonthlyTrades?: boolean
    mostTradedCategory?: boolean
    tradingStyle?: boolean
    riskProfile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastSyncedAt?: boolean
  }, ExtArgs["result"]["userAnalytics"]>

  export type UserAnalyticsSelectScalar = {
    id?: boolean
    address?: boolean
    totalVolume?: boolean
    totalProfit?: boolean
    positionValue?: boolean
    totalTrades?: boolean
    totalPositions?: boolean
    averageWinRate?: boolean
    avgMonthlyProfit?: boolean
    avgMonthlyTrades?: boolean
    mostTradedCategory?: boolean
    tradingStyle?: boolean
    riskProfile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastSyncedAt?: boolean
  }

  export type UserAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "address" | "totalVolume" | "totalProfit" | "positionValue" | "totalTrades" | "totalPositions" | "averageWinRate" | "avgMonthlyProfit" | "avgMonthlyTrades" | "mostTradedCategory" | "tradingStyle" | "riskProfile" | "createdAt" | "updatedAt" | "lastSyncedAt", ExtArgs["result"]["userAnalytics"]>
  export type UserAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marketDistribution?: boolean | UserAnalytics$marketDistributionArgs<ExtArgs>
    buySellData?: boolean | UserAnalytics$buySellDataArgs<ExtArgs>
    tradeSizeData?: boolean | UserAnalytics$tradeSizeDataArgs<ExtArgs>
    priceStats?: boolean | UserAnalytics$priceStatsArgs<ExtArgs>
    monthlyPerformance?: boolean | UserAnalytics$monthlyPerformanceArgs<ExtArgs>
    weeklyWinRate?: boolean | UserAnalytics$weeklyWinRateArgs<ExtArgs>
    _count?: boolean | UserAnalyticsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserAnalyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAnalytics"
    objects: {
      marketDistribution: Prisma.$MarketDistributionPayload<ExtArgs>[]
      buySellData: Prisma.$BuySellDataPayload<ExtArgs> | null
      tradeSizeData: Prisma.$TradeSizeDataPayload<ExtArgs> | null
      priceStats: Prisma.$PriceStatsPayload<ExtArgs> | null
      monthlyPerformance: Prisma.$MonthlyPerformancePayload<ExtArgs>[]
      weeklyWinRate: Prisma.$WeeklyWinRatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      address: string
      totalVolume: number
      totalProfit: number
      positionValue: number
      totalTrades: number
      totalPositions: number
      averageWinRate: number
      avgMonthlyProfit: number
      avgMonthlyTrades: number
      mostTradedCategory: string | null
      tradingStyle: string | null
      riskProfile: string | null
      createdAt: Date
      updatedAt: Date
      lastSyncedAt: Date | null
    }, ExtArgs["result"]["userAnalytics"]>
    composites: {}
  }

  type UserAnalyticsGetPayload<S extends boolean | null | undefined | UserAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$UserAnalyticsPayload, S>

  type UserAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAnalyticsCountAggregateInputType | true
    }

  export interface UserAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAnalytics'], meta: { name: 'UserAnalytics' } }
    /**
     * Find zero or one UserAnalytics that matches the filter.
     * @param {UserAnalyticsFindUniqueArgs} args - Arguments to find a UserAnalytics
     * @example
     * // Get one UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAnalyticsFindUniqueArgs>(args: SelectSubset<T, UserAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a UserAnalytics
     * @example
     * // Get one UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsFindFirstArgs} args - Arguments to find a UserAnalytics
     * @example
     * // Get one UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAnalyticsFindFirstArgs>(args?: SelectSubset<T, UserAnalyticsFindFirstArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsFindFirstOrThrowArgs} args - Arguments to find a UserAnalytics
     * @example
     * // Get one UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.findMany()
     * 
     * // Get first 10 UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAnalyticsWithIdOnly = await prisma.userAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAnalyticsFindManyArgs>(args?: SelectSubset<T, UserAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAnalytics.
     * @param {UserAnalyticsCreateArgs} args - Arguments to create a UserAnalytics.
     * @example
     * // Create one UserAnalytics
     * const UserAnalytics = await prisma.userAnalytics.create({
     *   data: {
     *     // ... data to create a UserAnalytics
     *   }
     * })
     * 
     */
    create<T extends UserAnalyticsCreateArgs>(args: SelectSubset<T, UserAnalyticsCreateArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAnalytics.
     * @param {UserAnalyticsCreateManyArgs} args - Arguments to create many UserAnalytics.
     * @example
     * // Create many UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAnalyticsCreateManyArgs>(args?: SelectSubset<T, UserAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAnalytics and returns the data saved in the database.
     * @param {UserAnalyticsCreateManyAndReturnArgs} args - Arguments to create many UserAnalytics.
     * @example
     * // Create many UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAnalytics and only return the `id`
     * const userAnalyticsWithIdOnly = await prisma.userAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAnalytics.
     * @param {UserAnalyticsDeleteArgs} args - Arguments to delete one UserAnalytics.
     * @example
     * // Delete one UserAnalytics
     * const UserAnalytics = await prisma.userAnalytics.delete({
     *   where: {
     *     // ... filter to delete one UserAnalytics
     *   }
     * })
     * 
     */
    delete<T extends UserAnalyticsDeleteArgs>(args: SelectSubset<T, UserAnalyticsDeleteArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAnalytics.
     * @param {UserAnalyticsUpdateArgs} args - Arguments to update one UserAnalytics.
     * @example
     * // Update one UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAnalyticsUpdateArgs>(args: SelectSubset<T, UserAnalyticsUpdateArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAnalytics.
     * @param {UserAnalyticsDeleteManyArgs} args - Arguments to filter UserAnalytics to delete.
     * @example
     * // Delete a few UserAnalytics
     * const { count } = await prisma.userAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAnalyticsDeleteManyArgs>(args?: SelectSubset<T, UserAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAnalyticsUpdateManyArgs>(args: SelectSubset<T, UserAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAnalytics and returns the data updated in the database.
     * @param {UserAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many UserAnalytics.
     * @example
     * // Update many UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAnalytics and only return the `id`
     * const userAnalyticsWithIdOnly = await prisma.userAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAnalytics.
     * @param {UserAnalyticsUpsertArgs} args - Arguments to update or create a UserAnalytics.
     * @example
     * // Update or create a UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.upsert({
     *   create: {
     *     // ... data to create a UserAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends UserAnalyticsUpsertArgs>(args: SelectSubset<T, UserAnalyticsUpsertArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsCountArgs} args - Arguments to filter UserAnalytics to count.
     * @example
     * // Count the number of UserAnalytics
     * const count = await prisma.userAnalytics.count({
     *   where: {
     *     // ... the filter for the UserAnalytics we want to count
     *   }
     * })
    **/
    count<T extends UserAnalyticsCountArgs>(
      args?: Subset<T, UserAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAnalyticsAggregateArgs>(args: Subset<T, UserAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetUserAnalyticsAggregateType<T>>

    /**
     * Group by UserAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: UserAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAnalytics model
   */
  readonly fields: UserAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    marketDistribution<T extends UserAnalytics$marketDistributionArgs<ExtArgs> = {}>(args?: Subset<T, UserAnalytics$marketDistributionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketDistributionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    buySellData<T extends UserAnalytics$buySellDataArgs<ExtArgs> = {}>(args?: Subset<T, UserAnalytics$buySellDataArgs<ExtArgs>>): Prisma__BuySellDataClient<$Result.GetResult<Prisma.$BuySellDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tradeSizeData<T extends UserAnalytics$tradeSizeDataArgs<ExtArgs> = {}>(args?: Subset<T, UserAnalytics$tradeSizeDataArgs<ExtArgs>>): Prisma__TradeSizeDataClient<$Result.GetResult<Prisma.$TradeSizeDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    priceStats<T extends UserAnalytics$priceStatsArgs<ExtArgs> = {}>(args?: Subset<T, UserAnalytics$priceStatsArgs<ExtArgs>>): Prisma__PriceStatsClient<$Result.GetResult<Prisma.$PriceStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    monthlyPerformance<T extends UserAnalytics$monthlyPerformanceArgs<ExtArgs> = {}>(args?: Subset<T, UserAnalytics$monthlyPerformanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlyPerformancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    weeklyWinRate<T extends UserAnalytics$weeklyWinRateArgs<ExtArgs> = {}>(args?: Subset<T, UserAnalytics$weeklyWinRateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyWinRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAnalytics model
   */
  interface UserAnalyticsFieldRefs {
    readonly id: FieldRef<"UserAnalytics", 'String'>
    readonly address: FieldRef<"UserAnalytics", 'String'>
    readonly totalVolume: FieldRef<"UserAnalytics", 'Float'>
    readonly totalProfit: FieldRef<"UserAnalytics", 'Float'>
    readonly positionValue: FieldRef<"UserAnalytics", 'Float'>
    readonly totalTrades: FieldRef<"UserAnalytics", 'Int'>
    readonly totalPositions: FieldRef<"UserAnalytics", 'Int'>
    readonly averageWinRate: FieldRef<"UserAnalytics", 'Float'>
    readonly avgMonthlyProfit: FieldRef<"UserAnalytics", 'Float'>
    readonly avgMonthlyTrades: FieldRef<"UserAnalytics", 'Int'>
    readonly mostTradedCategory: FieldRef<"UserAnalytics", 'String'>
    readonly tradingStyle: FieldRef<"UserAnalytics", 'String'>
    readonly riskProfile: FieldRef<"UserAnalytics", 'String'>
    readonly createdAt: FieldRef<"UserAnalytics", 'DateTime'>
    readonly updatedAt: FieldRef<"UserAnalytics", 'DateTime'>
    readonly lastSyncedAt: FieldRef<"UserAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAnalytics findUnique
   */
  export type UserAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAnalytics
     */
    omit?: UserAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which UserAnalytics to fetch.
     */
    where: UserAnalyticsWhereUniqueInput
  }

  /**
   * UserAnalytics findUniqueOrThrow
   */
  export type UserAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAnalytics
     */
    omit?: UserAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which UserAnalytics to fetch.
     */
    where: UserAnalyticsWhereUniqueInput
  }

  /**
   * UserAnalytics findFirst
   */
  export type UserAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAnalytics
     */
    omit?: UserAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which UserAnalytics to fetch.
     */
    where?: UserAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnalytics to fetch.
     */
    orderBy?: UserAnalyticsOrderByWithRelationInput | UserAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAnalytics.
     */
    cursor?: UserAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAnalytics.
     */
    distinct?: UserAnalyticsScalarFieldEnum | UserAnalyticsScalarFieldEnum[]
  }

  /**
   * UserAnalytics findFirstOrThrow
   */
  export type UserAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAnalytics
     */
    omit?: UserAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which UserAnalytics to fetch.
     */
    where?: UserAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnalytics to fetch.
     */
    orderBy?: UserAnalyticsOrderByWithRelationInput | UserAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAnalytics.
     */
    cursor?: UserAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAnalytics.
     */
    distinct?: UserAnalyticsScalarFieldEnum | UserAnalyticsScalarFieldEnum[]
  }

  /**
   * UserAnalytics findMany
   */
  export type UserAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAnalytics
     */
    omit?: UserAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which UserAnalytics to fetch.
     */
    where?: UserAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnalytics to fetch.
     */
    orderBy?: UserAnalyticsOrderByWithRelationInput | UserAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAnalytics.
     */
    cursor?: UserAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnalytics.
     */
    skip?: number
    distinct?: UserAnalyticsScalarFieldEnum | UserAnalyticsScalarFieldEnum[]
  }

  /**
   * UserAnalytics create
   */
  export type UserAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAnalytics
     */
    omit?: UserAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAnalytics.
     */
    data: XOR<UserAnalyticsCreateInput, UserAnalyticsUncheckedCreateInput>
  }

  /**
   * UserAnalytics createMany
   */
  export type UserAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAnalytics.
     */
    data: UserAnalyticsCreateManyInput | UserAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAnalytics createManyAndReturn
   */
  export type UserAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAnalytics
     */
    omit?: UserAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many UserAnalytics.
     */
    data: UserAnalyticsCreateManyInput | UserAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAnalytics update
   */
  export type UserAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAnalytics
     */
    omit?: UserAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAnalytics.
     */
    data: XOR<UserAnalyticsUpdateInput, UserAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which UserAnalytics to update.
     */
    where: UserAnalyticsWhereUniqueInput
  }

  /**
   * UserAnalytics updateMany
   */
  export type UserAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAnalytics.
     */
    data: XOR<UserAnalyticsUpdateManyMutationInput, UserAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which UserAnalytics to update
     */
    where?: UserAnalyticsWhereInput
    /**
     * Limit how many UserAnalytics to update.
     */
    limit?: number
  }

  /**
   * UserAnalytics updateManyAndReturn
   */
  export type UserAnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAnalytics
     */
    omit?: UserAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update UserAnalytics.
     */
    data: XOR<UserAnalyticsUpdateManyMutationInput, UserAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which UserAnalytics to update
     */
    where?: UserAnalyticsWhereInput
    /**
     * Limit how many UserAnalytics to update.
     */
    limit?: number
  }

  /**
   * UserAnalytics upsert
   */
  export type UserAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAnalytics
     */
    omit?: UserAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAnalytics to update in case it exists.
     */
    where: UserAnalyticsWhereUniqueInput
    /**
     * In case the UserAnalytics found by the `where` argument doesn't exist, create a new UserAnalytics with this data.
     */
    create: XOR<UserAnalyticsCreateInput, UserAnalyticsUncheckedCreateInput>
    /**
     * In case the UserAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAnalyticsUpdateInput, UserAnalyticsUncheckedUpdateInput>
  }

  /**
   * UserAnalytics delete
   */
  export type UserAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAnalytics
     */
    omit?: UserAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which UserAnalytics to delete.
     */
    where: UserAnalyticsWhereUniqueInput
  }

  /**
   * UserAnalytics deleteMany
   */
  export type UserAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAnalytics to delete
     */
    where?: UserAnalyticsWhereInput
    /**
     * Limit how many UserAnalytics to delete.
     */
    limit?: number
  }

  /**
   * UserAnalytics.marketDistribution
   */
  export type UserAnalytics$marketDistributionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketDistribution
     */
    select?: MarketDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketDistribution
     */
    omit?: MarketDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketDistributionInclude<ExtArgs> | null
    where?: MarketDistributionWhereInput
    orderBy?: MarketDistributionOrderByWithRelationInput | MarketDistributionOrderByWithRelationInput[]
    cursor?: MarketDistributionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketDistributionScalarFieldEnum | MarketDistributionScalarFieldEnum[]
  }

  /**
   * UserAnalytics.buySellData
   */
  export type UserAnalytics$buySellDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuySellData
     */
    select?: BuySellDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuySellData
     */
    omit?: BuySellDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuySellDataInclude<ExtArgs> | null
    where?: BuySellDataWhereInput
  }

  /**
   * UserAnalytics.tradeSizeData
   */
  export type UserAnalytics$tradeSizeDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeSizeData
     */
    select?: TradeSizeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeSizeData
     */
    omit?: TradeSizeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeSizeDataInclude<ExtArgs> | null
    where?: TradeSizeDataWhereInput
  }

  /**
   * UserAnalytics.priceStats
   */
  export type UserAnalytics$priceStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceStats
     */
    select?: PriceStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceStats
     */
    omit?: PriceStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceStatsInclude<ExtArgs> | null
    where?: PriceStatsWhereInput
  }

  /**
   * UserAnalytics.monthlyPerformance
   */
  export type UserAnalytics$monthlyPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyPerformance
     */
    select?: MonthlyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyPerformance
     */
    omit?: MonthlyPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyPerformanceInclude<ExtArgs> | null
    where?: MonthlyPerformanceWhereInput
    orderBy?: MonthlyPerformanceOrderByWithRelationInput | MonthlyPerformanceOrderByWithRelationInput[]
    cursor?: MonthlyPerformanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonthlyPerformanceScalarFieldEnum | MonthlyPerformanceScalarFieldEnum[]
  }

  /**
   * UserAnalytics.weeklyWinRate
   */
  export type UserAnalytics$weeklyWinRateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyWinRate
     */
    select?: WeeklyWinRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyWinRate
     */
    omit?: WeeklyWinRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyWinRateInclude<ExtArgs> | null
    where?: WeeklyWinRateWhereInput
    orderBy?: WeeklyWinRateOrderByWithRelationInput | WeeklyWinRateOrderByWithRelationInput[]
    cursor?: WeeklyWinRateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeeklyWinRateScalarFieldEnum | WeeklyWinRateScalarFieldEnum[]
  }

  /**
   * UserAnalytics without action
   */
  export type UserAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAnalytics
     */
    omit?: UserAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model MarketDistribution
   */

  export type AggregateMarketDistribution = {
    _count: MarketDistributionCountAggregateOutputType | null
    _avg: MarketDistributionAvgAggregateOutputType | null
    _sum: MarketDistributionSumAggregateOutputType | null
    _min: MarketDistributionMinAggregateOutputType | null
    _max: MarketDistributionMaxAggregateOutputType | null
  }

  export type MarketDistributionAvgAggregateOutputType = {
    value: number | null
    trades: number | null
    volume: number | null
    uniqueMarkets: number | null
  }

  export type MarketDistributionSumAggregateOutputType = {
    value: number | null
    trades: number | null
    volume: number | null
    uniqueMarkets: number | null
  }

  export type MarketDistributionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    market: string | null
    value: number | null
    trades: number | null
    volume: number | null
    uniqueMarkets: number | null
    createdAt: Date | null
  }

  export type MarketDistributionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    market: string | null
    value: number | null
    trades: number | null
    volume: number | null
    uniqueMarkets: number | null
    createdAt: Date | null
  }

  export type MarketDistributionCountAggregateOutputType = {
    id: number
    userId: number
    market: number
    value: number
    trades: number
    volume: number
    uniqueMarkets: number
    createdAt: number
    _all: number
  }


  export type MarketDistributionAvgAggregateInputType = {
    value?: true
    trades?: true
    volume?: true
    uniqueMarkets?: true
  }

  export type MarketDistributionSumAggregateInputType = {
    value?: true
    trades?: true
    volume?: true
    uniqueMarkets?: true
  }

  export type MarketDistributionMinAggregateInputType = {
    id?: true
    userId?: true
    market?: true
    value?: true
    trades?: true
    volume?: true
    uniqueMarkets?: true
    createdAt?: true
  }

  export type MarketDistributionMaxAggregateInputType = {
    id?: true
    userId?: true
    market?: true
    value?: true
    trades?: true
    volume?: true
    uniqueMarkets?: true
    createdAt?: true
  }

  export type MarketDistributionCountAggregateInputType = {
    id?: true
    userId?: true
    market?: true
    value?: true
    trades?: true
    volume?: true
    uniqueMarkets?: true
    createdAt?: true
    _all?: true
  }

  export type MarketDistributionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketDistribution to aggregate.
     */
    where?: MarketDistributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketDistributions to fetch.
     */
    orderBy?: MarketDistributionOrderByWithRelationInput | MarketDistributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketDistributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketDistributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketDistributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketDistributions
    **/
    _count?: true | MarketDistributionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketDistributionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketDistributionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketDistributionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketDistributionMaxAggregateInputType
  }

  export type GetMarketDistributionAggregateType<T extends MarketDistributionAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketDistribution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketDistribution[P]>
      : GetScalarType<T[P], AggregateMarketDistribution[P]>
  }




  export type MarketDistributionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketDistributionWhereInput
    orderBy?: MarketDistributionOrderByWithAggregationInput | MarketDistributionOrderByWithAggregationInput[]
    by: MarketDistributionScalarFieldEnum[] | MarketDistributionScalarFieldEnum
    having?: MarketDistributionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketDistributionCountAggregateInputType | true
    _avg?: MarketDistributionAvgAggregateInputType
    _sum?: MarketDistributionSumAggregateInputType
    _min?: MarketDistributionMinAggregateInputType
    _max?: MarketDistributionMaxAggregateInputType
  }

  export type MarketDistributionGroupByOutputType = {
    id: string
    userId: string
    market: string
    value: number
    trades: number
    volume: number
    uniqueMarkets: number
    createdAt: Date
    _count: MarketDistributionCountAggregateOutputType | null
    _avg: MarketDistributionAvgAggregateOutputType | null
    _sum: MarketDistributionSumAggregateOutputType | null
    _min: MarketDistributionMinAggregateOutputType | null
    _max: MarketDistributionMaxAggregateOutputType | null
  }

  type GetMarketDistributionGroupByPayload<T extends MarketDistributionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketDistributionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketDistributionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketDistributionGroupByOutputType[P]>
            : GetScalarType<T[P], MarketDistributionGroupByOutputType[P]>
        }
      >
    >


  export type MarketDistributionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    market?: boolean
    value?: boolean
    trades?: boolean
    volume?: boolean
    uniqueMarkets?: boolean
    createdAt?: boolean
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketDistribution"]>

  export type MarketDistributionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    market?: boolean
    value?: boolean
    trades?: boolean
    volume?: boolean
    uniqueMarkets?: boolean
    createdAt?: boolean
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketDistribution"]>

  export type MarketDistributionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    market?: boolean
    value?: boolean
    trades?: boolean
    volume?: boolean
    uniqueMarkets?: boolean
    createdAt?: boolean
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketDistribution"]>

  export type MarketDistributionSelectScalar = {
    id?: boolean
    userId?: boolean
    market?: boolean
    value?: boolean
    trades?: boolean
    volume?: boolean
    uniqueMarkets?: boolean
    createdAt?: boolean
  }

  export type MarketDistributionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "market" | "value" | "trades" | "volume" | "uniqueMarkets" | "createdAt", ExtArgs["result"]["marketDistribution"]>
  export type MarketDistributionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }
  export type MarketDistributionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }
  export type MarketDistributionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }

  export type $MarketDistributionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketDistribution"
    objects: {
      user: Prisma.$UserAnalyticsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      market: string
      value: number
      trades: number
      volume: number
      uniqueMarkets: number
      createdAt: Date
    }, ExtArgs["result"]["marketDistribution"]>
    composites: {}
  }

  type MarketDistributionGetPayload<S extends boolean | null | undefined | MarketDistributionDefaultArgs> = $Result.GetResult<Prisma.$MarketDistributionPayload, S>

  type MarketDistributionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketDistributionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketDistributionCountAggregateInputType | true
    }

  export interface MarketDistributionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketDistribution'], meta: { name: 'MarketDistribution' } }
    /**
     * Find zero or one MarketDistribution that matches the filter.
     * @param {MarketDistributionFindUniqueArgs} args - Arguments to find a MarketDistribution
     * @example
     * // Get one MarketDistribution
     * const marketDistribution = await prisma.marketDistribution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketDistributionFindUniqueArgs>(args: SelectSubset<T, MarketDistributionFindUniqueArgs<ExtArgs>>): Prisma__MarketDistributionClient<$Result.GetResult<Prisma.$MarketDistributionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketDistribution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketDistributionFindUniqueOrThrowArgs} args - Arguments to find a MarketDistribution
     * @example
     * // Get one MarketDistribution
     * const marketDistribution = await prisma.marketDistribution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketDistributionFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketDistributionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketDistributionClient<$Result.GetResult<Prisma.$MarketDistributionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketDistribution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketDistributionFindFirstArgs} args - Arguments to find a MarketDistribution
     * @example
     * // Get one MarketDistribution
     * const marketDistribution = await prisma.marketDistribution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketDistributionFindFirstArgs>(args?: SelectSubset<T, MarketDistributionFindFirstArgs<ExtArgs>>): Prisma__MarketDistributionClient<$Result.GetResult<Prisma.$MarketDistributionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketDistribution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketDistributionFindFirstOrThrowArgs} args - Arguments to find a MarketDistribution
     * @example
     * // Get one MarketDistribution
     * const marketDistribution = await prisma.marketDistribution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketDistributionFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketDistributionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketDistributionClient<$Result.GetResult<Prisma.$MarketDistributionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketDistributions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketDistributionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketDistributions
     * const marketDistributions = await prisma.marketDistribution.findMany()
     * 
     * // Get first 10 MarketDistributions
     * const marketDistributions = await prisma.marketDistribution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketDistributionWithIdOnly = await prisma.marketDistribution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketDistributionFindManyArgs>(args?: SelectSubset<T, MarketDistributionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketDistributionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketDistribution.
     * @param {MarketDistributionCreateArgs} args - Arguments to create a MarketDistribution.
     * @example
     * // Create one MarketDistribution
     * const MarketDistribution = await prisma.marketDistribution.create({
     *   data: {
     *     // ... data to create a MarketDistribution
     *   }
     * })
     * 
     */
    create<T extends MarketDistributionCreateArgs>(args: SelectSubset<T, MarketDistributionCreateArgs<ExtArgs>>): Prisma__MarketDistributionClient<$Result.GetResult<Prisma.$MarketDistributionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketDistributions.
     * @param {MarketDistributionCreateManyArgs} args - Arguments to create many MarketDistributions.
     * @example
     * // Create many MarketDistributions
     * const marketDistribution = await prisma.marketDistribution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketDistributionCreateManyArgs>(args?: SelectSubset<T, MarketDistributionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketDistributions and returns the data saved in the database.
     * @param {MarketDistributionCreateManyAndReturnArgs} args - Arguments to create many MarketDistributions.
     * @example
     * // Create many MarketDistributions
     * const marketDistribution = await prisma.marketDistribution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketDistributions and only return the `id`
     * const marketDistributionWithIdOnly = await prisma.marketDistribution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketDistributionCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketDistributionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketDistributionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MarketDistribution.
     * @param {MarketDistributionDeleteArgs} args - Arguments to delete one MarketDistribution.
     * @example
     * // Delete one MarketDistribution
     * const MarketDistribution = await prisma.marketDistribution.delete({
     *   where: {
     *     // ... filter to delete one MarketDistribution
     *   }
     * })
     * 
     */
    delete<T extends MarketDistributionDeleteArgs>(args: SelectSubset<T, MarketDistributionDeleteArgs<ExtArgs>>): Prisma__MarketDistributionClient<$Result.GetResult<Prisma.$MarketDistributionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketDistribution.
     * @param {MarketDistributionUpdateArgs} args - Arguments to update one MarketDistribution.
     * @example
     * // Update one MarketDistribution
     * const marketDistribution = await prisma.marketDistribution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketDistributionUpdateArgs>(args: SelectSubset<T, MarketDistributionUpdateArgs<ExtArgs>>): Prisma__MarketDistributionClient<$Result.GetResult<Prisma.$MarketDistributionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketDistributions.
     * @param {MarketDistributionDeleteManyArgs} args - Arguments to filter MarketDistributions to delete.
     * @example
     * // Delete a few MarketDistributions
     * const { count } = await prisma.marketDistribution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketDistributionDeleteManyArgs>(args?: SelectSubset<T, MarketDistributionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketDistributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketDistributionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketDistributions
     * const marketDistribution = await prisma.marketDistribution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketDistributionUpdateManyArgs>(args: SelectSubset<T, MarketDistributionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketDistributions and returns the data updated in the database.
     * @param {MarketDistributionUpdateManyAndReturnArgs} args - Arguments to update many MarketDistributions.
     * @example
     * // Update many MarketDistributions
     * const marketDistribution = await prisma.marketDistribution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MarketDistributions and only return the `id`
     * const marketDistributionWithIdOnly = await prisma.marketDistribution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MarketDistributionUpdateManyAndReturnArgs>(args: SelectSubset<T, MarketDistributionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketDistributionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MarketDistribution.
     * @param {MarketDistributionUpsertArgs} args - Arguments to update or create a MarketDistribution.
     * @example
     * // Update or create a MarketDistribution
     * const marketDistribution = await prisma.marketDistribution.upsert({
     *   create: {
     *     // ... data to create a MarketDistribution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketDistribution we want to update
     *   }
     * })
     */
    upsert<T extends MarketDistributionUpsertArgs>(args: SelectSubset<T, MarketDistributionUpsertArgs<ExtArgs>>): Prisma__MarketDistributionClient<$Result.GetResult<Prisma.$MarketDistributionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MarketDistributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketDistributionCountArgs} args - Arguments to filter MarketDistributions to count.
     * @example
     * // Count the number of MarketDistributions
     * const count = await prisma.marketDistribution.count({
     *   where: {
     *     // ... the filter for the MarketDistributions we want to count
     *   }
     * })
    **/
    count<T extends MarketDistributionCountArgs>(
      args?: Subset<T, MarketDistributionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketDistributionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketDistribution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketDistributionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketDistributionAggregateArgs>(args: Subset<T, MarketDistributionAggregateArgs>): Prisma.PrismaPromise<GetMarketDistributionAggregateType<T>>

    /**
     * Group by MarketDistribution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketDistributionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketDistributionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketDistributionGroupByArgs['orderBy'] }
        : { orderBy?: MarketDistributionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketDistributionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketDistributionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketDistribution model
   */
  readonly fields: MarketDistributionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketDistribution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketDistributionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserAnalyticsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserAnalyticsDefaultArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketDistribution model
   */
  interface MarketDistributionFieldRefs {
    readonly id: FieldRef<"MarketDistribution", 'String'>
    readonly userId: FieldRef<"MarketDistribution", 'String'>
    readonly market: FieldRef<"MarketDistribution", 'String'>
    readonly value: FieldRef<"MarketDistribution", 'Int'>
    readonly trades: FieldRef<"MarketDistribution", 'Int'>
    readonly volume: FieldRef<"MarketDistribution", 'Float'>
    readonly uniqueMarkets: FieldRef<"MarketDistribution", 'Int'>
    readonly createdAt: FieldRef<"MarketDistribution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketDistribution findUnique
   */
  export type MarketDistributionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketDistribution
     */
    select?: MarketDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketDistribution
     */
    omit?: MarketDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketDistributionInclude<ExtArgs> | null
    /**
     * Filter, which MarketDistribution to fetch.
     */
    where: MarketDistributionWhereUniqueInput
  }

  /**
   * MarketDistribution findUniqueOrThrow
   */
  export type MarketDistributionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketDistribution
     */
    select?: MarketDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketDistribution
     */
    omit?: MarketDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketDistributionInclude<ExtArgs> | null
    /**
     * Filter, which MarketDistribution to fetch.
     */
    where: MarketDistributionWhereUniqueInput
  }

  /**
   * MarketDistribution findFirst
   */
  export type MarketDistributionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketDistribution
     */
    select?: MarketDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketDistribution
     */
    omit?: MarketDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketDistributionInclude<ExtArgs> | null
    /**
     * Filter, which MarketDistribution to fetch.
     */
    where?: MarketDistributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketDistributions to fetch.
     */
    orderBy?: MarketDistributionOrderByWithRelationInput | MarketDistributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketDistributions.
     */
    cursor?: MarketDistributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketDistributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketDistributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketDistributions.
     */
    distinct?: MarketDistributionScalarFieldEnum | MarketDistributionScalarFieldEnum[]
  }

  /**
   * MarketDistribution findFirstOrThrow
   */
  export type MarketDistributionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketDistribution
     */
    select?: MarketDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketDistribution
     */
    omit?: MarketDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketDistributionInclude<ExtArgs> | null
    /**
     * Filter, which MarketDistribution to fetch.
     */
    where?: MarketDistributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketDistributions to fetch.
     */
    orderBy?: MarketDistributionOrderByWithRelationInput | MarketDistributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketDistributions.
     */
    cursor?: MarketDistributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketDistributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketDistributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketDistributions.
     */
    distinct?: MarketDistributionScalarFieldEnum | MarketDistributionScalarFieldEnum[]
  }

  /**
   * MarketDistribution findMany
   */
  export type MarketDistributionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketDistribution
     */
    select?: MarketDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketDistribution
     */
    omit?: MarketDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketDistributionInclude<ExtArgs> | null
    /**
     * Filter, which MarketDistributions to fetch.
     */
    where?: MarketDistributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketDistributions to fetch.
     */
    orderBy?: MarketDistributionOrderByWithRelationInput | MarketDistributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketDistributions.
     */
    cursor?: MarketDistributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketDistributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketDistributions.
     */
    skip?: number
    distinct?: MarketDistributionScalarFieldEnum | MarketDistributionScalarFieldEnum[]
  }

  /**
   * MarketDistribution create
   */
  export type MarketDistributionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketDistribution
     */
    select?: MarketDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketDistribution
     */
    omit?: MarketDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketDistributionInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketDistribution.
     */
    data: XOR<MarketDistributionCreateInput, MarketDistributionUncheckedCreateInput>
  }

  /**
   * MarketDistribution createMany
   */
  export type MarketDistributionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketDistributions.
     */
    data: MarketDistributionCreateManyInput | MarketDistributionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketDistribution createManyAndReturn
   */
  export type MarketDistributionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketDistribution
     */
    select?: MarketDistributionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketDistribution
     */
    omit?: MarketDistributionOmit<ExtArgs> | null
    /**
     * The data used to create many MarketDistributions.
     */
    data: MarketDistributionCreateManyInput | MarketDistributionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketDistributionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketDistribution update
   */
  export type MarketDistributionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketDistribution
     */
    select?: MarketDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketDistribution
     */
    omit?: MarketDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketDistributionInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketDistribution.
     */
    data: XOR<MarketDistributionUpdateInput, MarketDistributionUncheckedUpdateInput>
    /**
     * Choose, which MarketDistribution to update.
     */
    where: MarketDistributionWhereUniqueInput
  }

  /**
   * MarketDistribution updateMany
   */
  export type MarketDistributionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketDistributions.
     */
    data: XOR<MarketDistributionUpdateManyMutationInput, MarketDistributionUncheckedUpdateManyInput>
    /**
     * Filter which MarketDistributions to update
     */
    where?: MarketDistributionWhereInput
    /**
     * Limit how many MarketDistributions to update.
     */
    limit?: number
  }

  /**
   * MarketDistribution updateManyAndReturn
   */
  export type MarketDistributionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketDistribution
     */
    select?: MarketDistributionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketDistribution
     */
    omit?: MarketDistributionOmit<ExtArgs> | null
    /**
     * The data used to update MarketDistributions.
     */
    data: XOR<MarketDistributionUpdateManyMutationInput, MarketDistributionUncheckedUpdateManyInput>
    /**
     * Filter which MarketDistributions to update
     */
    where?: MarketDistributionWhereInput
    /**
     * Limit how many MarketDistributions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketDistributionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketDistribution upsert
   */
  export type MarketDistributionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketDistribution
     */
    select?: MarketDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketDistribution
     */
    omit?: MarketDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketDistributionInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketDistribution to update in case it exists.
     */
    where: MarketDistributionWhereUniqueInput
    /**
     * In case the MarketDistribution found by the `where` argument doesn't exist, create a new MarketDistribution with this data.
     */
    create: XOR<MarketDistributionCreateInput, MarketDistributionUncheckedCreateInput>
    /**
     * In case the MarketDistribution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketDistributionUpdateInput, MarketDistributionUncheckedUpdateInput>
  }

  /**
   * MarketDistribution delete
   */
  export type MarketDistributionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketDistribution
     */
    select?: MarketDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketDistribution
     */
    omit?: MarketDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketDistributionInclude<ExtArgs> | null
    /**
     * Filter which MarketDistribution to delete.
     */
    where: MarketDistributionWhereUniqueInput
  }

  /**
   * MarketDistribution deleteMany
   */
  export type MarketDistributionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketDistributions to delete
     */
    where?: MarketDistributionWhereInput
    /**
     * Limit how many MarketDistributions to delete.
     */
    limit?: number
  }

  /**
   * MarketDistribution without action
   */
  export type MarketDistributionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketDistribution
     */
    select?: MarketDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketDistribution
     */
    omit?: MarketDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketDistributionInclude<ExtArgs> | null
  }


  /**
   * Model BuySellData
   */

  export type AggregateBuySellData = {
    _count: BuySellDataCountAggregateOutputType | null
    _avg: BuySellDataAvgAggregateOutputType | null
    _sum: BuySellDataSumAggregateOutputType | null
    _min: BuySellDataMinAggregateOutputType | null
    _max: BuySellDataMaxAggregateOutputType | null
  }

  export type BuySellDataAvgAggregateOutputType = {
    buyPercentage: number | null
    sellPercentage: number | null
    buyVolume: number | null
    sellVolume: number | null
    buyCount: number | null
    sellCount: number | null
  }

  export type BuySellDataSumAggregateOutputType = {
    buyPercentage: number | null
    sellPercentage: number | null
    buyVolume: number | null
    sellVolume: number | null
    buyCount: number | null
    sellCount: number | null
  }

  export type BuySellDataMinAggregateOutputType = {
    id: string | null
    userId: string | null
    buyPercentage: number | null
    sellPercentage: number | null
    buyVolume: number | null
    sellVolume: number | null
    buyCount: number | null
    sellCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuySellDataMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    buyPercentage: number | null
    sellPercentage: number | null
    buyVolume: number | null
    sellVolume: number | null
    buyCount: number | null
    sellCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuySellDataCountAggregateOutputType = {
    id: number
    userId: number
    buyPercentage: number
    sellPercentage: number
    buyVolume: number
    sellVolume: number
    buyCount: number
    sellCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BuySellDataAvgAggregateInputType = {
    buyPercentage?: true
    sellPercentage?: true
    buyVolume?: true
    sellVolume?: true
    buyCount?: true
    sellCount?: true
  }

  export type BuySellDataSumAggregateInputType = {
    buyPercentage?: true
    sellPercentage?: true
    buyVolume?: true
    sellVolume?: true
    buyCount?: true
    sellCount?: true
  }

  export type BuySellDataMinAggregateInputType = {
    id?: true
    userId?: true
    buyPercentage?: true
    sellPercentage?: true
    buyVolume?: true
    sellVolume?: true
    buyCount?: true
    sellCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuySellDataMaxAggregateInputType = {
    id?: true
    userId?: true
    buyPercentage?: true
    sellPercentage?: true
    buyVolume?: true
    sellVolume?: true
    buyCount?: true
    sellCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuySellDataCountAggregateInputType = {
    id?: true
    userId?: true
    buyPercentage?: true
    sellPercentage?: true
    buyVolume?: true
    sellVolume?: true
    buyCount?: true
    sellCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BuySellDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuySellData to aggregate.
     */
    where?: BuySellDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuySellData to fetch.
     */
    orderBy?: BuySellDataOrderByWithRelationInput | BuySellDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuySellDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuySellData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuySellData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuySellData
    **/
    _count?: true | BuySellDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuySellDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuySellDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuySellDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuySellDataMaxAggregateInputType
  }

  export type GetBuySellDataAggregateType<T extends BuySellDataAggregateArgs> = {
        [P in keyof T & keyof AggregateBuySellData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuySellData[P]>
      : GetScalarType<T[P], AggregateBuySellData[P]>
  }




  export type BuySellDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuySellDataWhereInput
    orderBy?: BuySellDataOrderByWithAggregationInput | BuySellDataOrderByWithAggregationInput[]
    by: BuySellDataScalarFieldEnum[] | BuySellDataScalarFieldEnum
    having?: BuySellDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuySellDataCountAggregateInputType | true
    _avg?: BuySellDataAvgAggregateInputType
    _sum?: BuySellDataSumAggregateInputType
    _min?: BuySellDataMinAggregateInputType
    _max?: BuySellDataMaxAggregateInputType
  }

  export type BuySellDataGroupByOutputType = {
    id: string
    userId: string
    buyPercentage: number
    sellPercentage: number
    buyVolume: number
    sellVolume: number
    buyCount: number
    sellCount: number
    createdAt: Date
    updatedAt: Date
    _count: BuySellDataCountAggregateOutputType | null
    _avg: BuySellDataAvgAggregateOutputType | null
    _sum: BuySellDataSumAggregateOutputType | null
    _min: BuySellDataMinAggregateOutputType | null
    _max: BuySellDataMaxAggregateOutputType | null
  }

  type GetBuySellDataGroupByPayload<T extends BuySellDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuySellDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuySellDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuySellDataGroupByOutputType[P]>
            : GetScalarType<T[P], BuySellDataGroupByOutputType[P]>
        }
      >
    >


  export type BuySellDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    buyPercentage?: boolean
    sellPercentage?: boolean
    buyVolume?: boolean
    sellVolume?: boolean
    buyCount?: boolean
    sellCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buySellData"]>

  export type BuySellDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    buyPercentage?: boolean
    sellPercentage?: boolean
    buyVolume?: boolean
    sellVolume?: boolean
    buyCount?: boolean
    sellCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buySellData"]>

  export type BuySellDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    buyPercentage?: boolean
    sellPercentage?: boolean
    buyVolume?: boolean
    sellVolume?: boolean
    buyCount?: boolean
    sellCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buySellData"]>

  export type BuySellDataSelectScalar = {
    id?: boolean
    userId?: boolean
    buyPercentage?: boolean
    sellPercentage?: boolean
    buyVolume?: boolean
    sellVolume?: boolean
    buyCount?: boolean
    sellCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BuySellDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "buyPercentage" | "sellPercentage" | "buyVolume" | "sellVolume" | "buyCount" | "sellCount" | "createdAt" | "updatedAt", ExtArgs["result"]["buySellData"]>
  export type BuySellDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }
  export type BuySellDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }
  export type BuySellDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }

  export type $BuySellDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuySellData"
    objects: {
      user: Prisma.$UserAnalyticsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      buyPercentage: number
      sellPercentage: number
      buyVolume: number
      sellVolume: number
      buyCount: number
      sellCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["buySellData"]>
    composites: {}
  }

  type BuySellDataGetPayload<S extends boolean | null | undefined | BuySellDataDefaultArgs> = $Result.GetResult<Prisma.$BuySellDataPayload, S>

  type BuySellDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BuySellDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BuySellDataCountAggregateInputType | true
    }

  export interface BuySellDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuySellData'], meta: { name: 'BuySellData' } }
    /**
     * Find zero or one BuySellData that matches the filter.
     * @param {BuySellDataFindUniqueArgs} args - Arguments to find a BuySellData
     * @example
     * // Get one BuySellData
     * const buySellData = await prisma.buySellData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuySellDataFindUniqueArgs>(args: SelectSubset<T, BuySellDataFindUniqueArgs<ExtArgs>>): Prisma__BuySellDataClient<$Result.GetResult<Prisma.$BuySellDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BuySellData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BuySellDataFindUniqueOrThrowArgs} args - Arguments to find a BuySellData
     * @example
     * // Get one BuySellData
     * const buySellData = await prisma.buySellData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuySellDataFindUniqueOrThrowArgs>(args: SelectSubset<T, BuySellDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuySellDataClient<$Result.GetResult<Prisma.$BuySellDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuySellData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuySellDataFindFirstArgs} args - Arguments to find a BuySellData
     * @example
     * // Get one BuySellData
     * const buySellData = await prisma.buySellData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuySellDataFindFirstArgs>(args?: SelectSubset<T, BuySellDataFindFirstArgs<ExtArgs>>): Prisma__BuySellDataClient<$Result.GetResult<Prisma.$BuySellDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuySellData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuySellDataFindFirstOrThrowArgs} args - Arguments to find a BuySellData
     * @example
     * // Get one BuySellData
     * const buySellData = await prisma.buySellData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuySellDataFindFirstOrThrowArgs>(args?: SelectSubset<T, BuySellDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuySellDataClient<$Result.GetResult<Prisma.$BuySellDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BuySellData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuySellDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuySellData
     * const buySellData = await prisma.buySellData.findMany()
     * 
     * // Get first 10 BuySellData
     * const buySellData = await prisma.buySellData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buySellDataWithIdOnly = await prisma.buySellData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuySellDataFindManyArgs>(args?: SelectSubset<T, BuySellDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuySellDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BuySellData.
     * @param {BuySellDataCreateArgs} args - Arguments to create a BuySellData.
     * @example
     * // Create one BuySellData
     * const BuySellData = await prisma.buySellData.create({
     *   data: {
     *     // ... data to create a BuySellData
     *   }
     * })
     * 
     */
    create<T extends BuySellDataCreateArgs>(args: SelectSubset<T, BuySellDataCreateArgs<ExtArgs>>): Prisma__BuySellDataClient<$Result.GetResult<Prisma.$BuySellDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BuySellData.
     * @param {BuySellDataCreateManyArgs} args - Arguments to create many BuySellData.
     * @example
     * // Create many BuySellData
     * const buySellData = await prisma.buySellData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuySellDataCreateManyArgs>(args?: SelectSubset<T, BuySellDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BuySellData and returns the data saved in the database.
     * @param {BuySellDataCreateManyAndReturnArgs} args - Arguments to create many BuySellData.
     * @example
     * // Create many BuySellData
     * const buySellData = await prisma.buySellData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BuySellData and only return the `id`
     * const buySellDataWithIdOnly = await prisma.buySellData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BuySellDataCreateManyAndReturnArgs>(args?: SelectSubset<T, BuySellDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuySellDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BuySellData.
     * @param {BuySellDataDeleteArgs} args - Arguments to delete one BuySellData.
     * @example
     * // Delete one BuySellData
     * const BuySellData = await prisma.buySellData.delete({
     *   where: {
     *     // ... filter to delete one BuySellData
     *   }
     * })
     * 
     */
    delete<T extends BuySellDataDeleteArgs>(args: SelectSubset<T, BuySellDataDeleteArgs<ExtArgs>>): Prisma__BuySellDataClient<$Result.GetResult<Prisma.$BuySellDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BuySellData.
     * @param {BuySellDataUpdateArgs} args - Arguments to update one BuySellData.
     * @example
     * // Update one BuySellData
     * const buySellData = await prisma.buySellData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuySellDataUpdateArgs>(args: SelectSubset<T, BuySellDataUpdateArgs<ExtArgs>>): Prisma__BuySellDataClient<$Result.GetResult<Prisma.$BuySellDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BuySellData.
     * @param {BuySellDataDeleteManyArgs} args - Arguments to filter BuySellData to delete.
     * @example
     * // Delete a few BuySellData
     * const { count } = await prisma.buySellData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuySellDataDeleteManyArgs>(args?: SelectSubset<T, BuySellDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuySellData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuySellDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuySellData
     * const buySellData = await prisma.buySellData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuySellDataUpdateManyArgs>(args: SelectSubset<T, BuySellDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuySellData and returns the data updated in the database.
     * @param {BuySellDataUpdateManyAndReturnArgs} args - Arguments to update many BuySellData.
     * @example
     * // Update many BuySellData
     * const buySellData = await prisma.buySellData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BuySellData and only return the `id`
     * const buySellDataWithIdOnly = await prisma.buySellData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BuySellDataUpdateManyAndReturnArgs>(args: SelectSubset<T, BuySellDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuySellDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BuySellData.
     * @param {BuySellDataUpsertArgs} args - Arguments to update or create a BuySellData.
     * @example
     * // Update or create a BuySellData
     * const buySellData = await prisma.buySellData.upsert({
     *   create: {
     *     // ... data to create a BuySellData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuySellData we want to update
     *   }
     * })
     */
    upsert<T extends BuySellDataUpsertArgs>(args: SelectSubset<T, BuySellDataUpsertArgs<ExtArgs>>): Prisma__BuySellDataClient<$Result.GetResult<Prisma.$BuySellDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BuySellData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuySellDataCountArgs} args - Arguments to filter BuySellData to count.
     * @example
     * // Count the number of BuySellData
     * const count = await prisma.buySellData.count({
     *   where: {
     *     // ... the filter for the BuySellData we want to count
     *   }
     * })
    **/
    count<T extends BuySellDataCountArgs>(
      args?: Subset<T, BuySellDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuySellDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuySellData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuySellDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuySellDataAggregateArgs>(args: Subset<T, BuySellDataAggregateArgs>): Prisma.PrismaPromise<GetBuySellDataAggregateType<T>>

    /**
     * Group by BuySellData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuySellDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuySellDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuySellDataGroupByArgs['orderBy'] }
        : { orderBy?: BuySellDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuySellDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuySellDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuySellData model
   */
  readonly fields: BuySellDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuySellData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuySellDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserAnalyticsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserAnalyticsDefaultArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuySellData model
   */
  interface BuySellDataFieldRefs {
    readonly id: FieldRef<"BuySellData", 'String'>
    readonly userId: FieldRef<"BuySellData", 'String'>
    readonly buyPercentage: FieldRef<"BuySellData", 'Int'>
    readonly sellPercentage: FieldRef<"BuySellData", 'Int'>
    readonly buyVolume: FieldRef<"BuySellData", 'Float'>
    readonly sellVolume: FieldRef<"BuySellData", 'Float'>
    readonly buyCount: FieldRef<"BuySellData", 'Int'>
    readonly sellCount: FieldRef<"BuySellData", 'Int'>
    readonly createdAt: FieldRef<"BuySellData", 'DateTime'>
    readonly updatedAt: FieldRef<"BuySellData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BuySellData findUnique
   */
  export type BuySellDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuySellData
     */
    select?: BuySellDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuySellData
     */
    omit?: BuySellDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuySellDataInclude<ExtArgs> | null
    /**
     * Filter, which BuySellData to fetch.
     */
    where: BuySellDataWhereUniqueInput
  }

  /**
   * BuySellData findUniqueOrThrow
   */
  export type BuySellDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuySellData
     */
    select?: BuySellDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuySellData
     */
    omit?: BuySellDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuySellDataInclude<ExtArgs> | null
    /**
     * Filter, which BuySellData to fetch.
     */
    where: BuySellDataWhereUniqueInput
  }

  /**
   * BuySellData findFirst
   */
  export type BuySellDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuySellData
     */
    select?: BuySellDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuySellData
     */
    omit?: BuySellDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuySellDataInclude<ExtArgs> | null
    /**
     * Filter, which BuySellData to fetch.
     */
    where?: BuySellDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuySellData to fetch.
     */
    orderBy?: BuySellDataOrderByWithRelationInput | BuySellDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuySellData.
     */
    cursor?: BuySellDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuySellData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuySellData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuySellData.
     */
    distinct?: BuySellDataScalarFieldEnum | BuySellDataScalarFieldEnum[]
  }

  /**
   * BuySellData findFirstOrThrow
   */
  export type BuySellDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuySellData
     */
    select?: BuySellDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuySellData
     */
    omit?: BuySellDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuySellDataInclude<ExtArgs> | null
    /**
     * Filter, which BuySellData to fetch.
     */
    where?: BuySellDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuySellData to fetch.
     */
    orderBy?: BuySellDataOrderByWithRelationInput | BuySellDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuySellData.
     */
    cursor?: BuySellDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuySellData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuySellData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuySellData.
     */
    distinct?: BuySellDataScalarFieldEnum | BuySellDataScalarFieldEnum[]
  }

  /**
   * BuySellData findMany
   */
  export type BuySellDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuySellData
     */
    select?: BuySellDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuySellData
     */
    omit?: BuySellDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuySellDataInclude<ExtArgs> | null
    /**
     * Filter, which BuySellData to fetch.
     */
    where?: BuySellDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuySellData to fetch.
     */
    orderBy?: BuySellDataOrderByWithRelationInput | BuySellDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuySellData.
     */
    cursor?: BuySellDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuySellData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuySellData.
     */
    skip?: number
    distinct?: BuySellDataScalarFieldEnum | BuySellDataScalarFieldEnum[]
  }

  /**
   * BuySellData create
   */
  export type BuySellDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuySellData
     */
    select?: BuySellDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuySellData
     */
    omit?: BuySellDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuySellDataInclude<ExtArgs> | null
    /**
     * The data needed to create a BuySellData.
     */
    data: XOR<BuySellDataCreateInput, BuySellDataUncheckedCreateInput>
  }

  /**
   * BuySellData createMany
   */
  export type BuySellDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuySellData.
     */
    data: BuySellDataCreateManyInput | BuySellDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuySellData createManyAndReturn
   */
  export type BuySellDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuySellData
     */
    select?: BuySellDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BuySellData
     */
    omit?: BuySellDataOmit<ExtArgs> | null
    /**
     * The data used to create many BuySellData.
     */
    data: BuySellDataCreateManyInput | BuySellDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuySellDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BuySellData update
   */
  export type BuySellDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuySellData
     */
    select?: BuySellDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuySellData
     */
    omit?: BuySellDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuySellDataInclude<ExtArgs> | null
    /**
     * The data needed to update a BuySellData.
     */
    data: XOR<BuySellDataUpdateInput, BuySellDataUncheckedUpdateInput>
    /**
     * Choose, which BuySellData to update.
     */
    where: BuySellDataWhereUniqueInput
  }

  /**
   * BuySellData updateMany
   */
  export type BuySellDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuySellData.
     */
    data: XOR<BuySellDataUpdateManyMutationInput, BuySellDataUncheckedUpdateManyInput>
    /**
     * Filter which BuySellData to update
     */
    where?: BuySellDataWhereInput
    /**
     * Limit how many BuySellData to update.
     */
    limit?: number
  }

  /**
   * BuySellData updateManyAndReturn
   */
  export type BuySellDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuySellData
     */
    select?: BuySellDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BuySellData
     */
    omit?: BuySellDataOmit<ExtArgs> | null
    /**
     * The data used to update BuySellData.
     */
    data: XOR<BuySellDataUpdateManyMutationInput, BuySellDataUncheckedUpdateManyInput>
    /**
     * Filter which BuySellData to update
     */
    where?: BuySellDataWhereInput
    /**
     * Limit how many BuySellData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuySellDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BuySellData upsert
   */
  export type BuySellDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuySellData
     */
    select?: BuySellDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuySellData
     */
    omit?: BuySellDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuySellDataInclude<ExtArgs> | null
    /**
     * The filter to search for the BuySellData to update in case it exists.
     */
    where: BuySellDataWhereUniqueInput
    /**
     * In case the BuySellData found by the `where` argument doesn't exist, create a new BuySellData with this data.
     */
    create: XOR<BuySellDataCreateInput, BuySellDataUncheckedCreateInput>
    /**
     * In case the BuySellData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuySellDataUpdateInput, BuySellDataUncheckedUpdateInput>
  }

  /**
   * BuySellData delete
   */
  export type BuySellDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuySellData
     */
    select?: BuySellDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuySellData
     */
    omit?: BuySellDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuySellDataInclude<ExtArgs> | null
    /**
     * Filter which BuySellData to delete.
     */
    where: BuySellDataWhereUniqueInput
  }

  /**
   * BuySellData deleteMany
   */
  export type BuySellDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuySellData to delete
     */
    where?: BuySellDataWhereInput
    /**
     * Limit how many BuySellData to delete.
     */
    limit?: number
  }

  /**
   * BuySellData without action
   */
  export type BuySellDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuySellData
     */
    select?: BuySellDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuySellData
     */
    omit?: BuySellDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuySellDataInclude<ExtArgs> | null
  }


  /**
   * Model TradeSizeData
   */

  export type AggregateTradeSizeData = {
    _count: TradeSizeDataCountAggregateOutputType | null
    _avg: TradeSizeDataAvgAggregateOutputType | null
    _sum: TradeSizeDataSumAggregateOutputType | null
    _min: TradeSizeDataMinAggregateOutputType | null
    _max: TradeSizeDataMaxAggregateOutputType | null
  }

  export type TradeSizeDataAvgAggregateOutputType = {
    averageSize: number | null
    medianSize: number | null
    minSize: number | null
    maxSize: number | null
    smallTrades: number | null
    mediumTrades: number | null
    largeTrades: number | null
  }

  export type TradeSizeDataSumAggregateOutputType = {
    averageSize: number | null
    medianSize: number | null
    minSize: number | null
    maxSize: number | null
    smallTrades: number | null
    mediumTrades: number | null
    largeTrades: number | null
  }

  export type TradeSizeDataMinAggregateOutputType = {
    id: string | null
    userId: string | null
    averageSize: number | null
    medianSize: number | null
    minSize: number | null
    maxSize: number | null
    smallTrades: number | null
    mediumTrades: number | null
    largeTrades: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TradeSizeDataMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    averageSize: number | null
    medianSize: number | null
    minSize: number | null
    maxSize: number | null
    smallTrades: number | null
    mediumTrades: number | null
    largeTrades: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TradeSizeDataCountAggregateOutputType = {
    id: number
    userId: number
    averageSize: number
    medianSize: number
    minSize: number
    maxSize: number
    smallTrades: number
    mediumTrades: number
    largeTrades: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TradeSizeDataAvgAggregateInputType = {
    averageSize?: true
    medianSize?: true
    minSize?: true
    maxSize?: true
    smallTrades?: true
    mediumTrades?: true
    largeTrades?: true
  }

  export type TradeSizeDataSumAggregateInputType = {
    averageSize?: true
    medianSize?: true
    minSize?: true
    maxSize?: true
    smallTrades?: true
    mediumTrades?: true
    largeTrades?: true
  }

  export type TradeSizeDataMinAggregateInputType = {
    id?: true
    userId?: true
    averageSize?: true
    medianSize?: true
    minSize?: true
    maxSize?: true
    smallTrades?: true
    mediumTrades?: true
    largeTrades?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TradeSizeDataMaxAggregateInputType = {
    id?: true
    userId?: true
    averageSize?: true
    medianSize?: true
    minSize?: true
    maxSize?: true
    smallTrades?: true
    mediumTrades?: true
    largeTrades?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TradeSizeDataCountAggregateInputType = {
    id?: true
    userId?: true
    averageSize?: true
    medianSize?: true
    minSize?: true
    maxSize?: true
    smallTrades?: true
    mediumTrades?: true
    largeTrades?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TradeSizeDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeSizeData to aggregate.
     */
    where?: TradeSizeDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeSizeData to fetch.
     */
    orderBy?: TradeSizeDataOrderByWithRelationInput | TradeSizeDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TradeSizeDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeSizeData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeSizeData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TradeSizeData
    **/
    _count?: true | TradeSizeDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TradeSizeDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TradeSizeDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TradeSizeDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TradeSizeDataMaxAggregateInputType
  }

  export type GetTradeSizeDataAggregateType<T extends TradeSizeDataAggregateArgs> = {
        [P in keyof T & keyof AggregateTradeSizeData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTradeSizeData[P]>
      : GetScalarType<T[P], AggregateTradeSizeData[P]>
  }




  export type TradeSizeDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeSizeDataWhereInput
    orderBy?: TradeSizeDataOrderByWithAggregationInput | TradeSizeDataOrderByWithAggregationInput[]
    by: TradeSizeDataScalarFieldEnum[] | TradeSizeDataScalarFieldEnum
    having?: TradeSizeDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TradeSizeDataCountAggregateInputType | true
    _avg?: TradeSizeDataAvgAggregateInputType
    _sum?: TradeSizeDataSumAggregateInputType
    _min?: TradeSizeDataMinAggregateInputType
    _max?: TradeSizeDataMaxAggregateInputType
  }

  export type TradeSizeDataGroupByOutputType = {
    id: string
    userId: string
    averageSize: number
    medianSize: number
    minSize: number
    maxSize: number
    smallTrades: number
    mediumTrades: number
    largeTrades: number
    createdAt: Date
    updatedAt: Date
    _count: TradeSizeDataCountAggregateOutputType | null
    _avg: TradeSizeDataAvgAggregateOutputType | null
    _sum: TradeSizeDataSumAggregateOutputType | null
    _min: TradeSizeDataMinAggregateOutputType | null
    _max: TradeSizeDataMaxAggregateOutputType | null
  }

  type GetTradeSizeDataGroupByPayload<T extends TradeSizeDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TradeSizeDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TradeSizeDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TradeSizeDataGroupByOutputType[P]>
            : GetScalarType<T[P], TradeSizeDataGroupByOutputType[P]>
        }
      >
    >


  export type TradeSizeDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    averageSize?: boolean
    medianSize?: boolean
    minSize?: boolean
    maxSize?: boolean
    smallTrades?: boolean
    mediumTrades?: boolean
    largeTrades?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tradeSizeData"]>

  export type TradeSizeDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    averageSize?: boolean
    medianSize?: boolean
    minSize?: boolean
    maxSize?: boolean
    smallTrades?: boolean
    mediumTrades?: boolean
    largeTrades?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tradeSizeData"]>

  export type TradeSizeDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    averageSize?: boolean
    medianSize?: boolean
    minSize?: boolean
    maxSize?: boolean
    smallTrades?: boolean
    mediumTrades?: boolean
    largeTrades?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tradeSizeData"]>

  export type TradeSizeDataSelectScalar = {
    id?: boolean
    userId?: boolean
    averageSize?: boolean
    medianSize?: boolean
    minSize?: boolean
    maxSize?: boolean
    smallTrades?: boolean
    mediumTrades?: boolean
    largeTrades?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TradeSizeDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "averageSize" | "medianSize" | "minSize" | "maxSize" | "smallTrades" | "mediumTrades" | "largeTrades" | "createdAt" | "updatedAt", ExtArgs["result"]["tradeSizeData"]>
  export type TradeSizeDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }
  export type TradeSizeDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }
  export type TradeSizeDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }

  export type $TradeSizeDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TradeSizeData"
    objects: {
      user: Prisma.$UserAnalyticsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      averageSize: number
      medianSize: number
      minSize: number
      maxSize: number
      smallTrades: number
      mediumTrades: number
      largeTrades: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tradeSizeData"]>
    composites: {}
  }

  type TradeSizeDataGetPayload<S extends boolean | null | undefined | TradeSizeDataDefaultArgs> = $Result.GetResult<Prisma.$TradeSizeDataPayload, S>

  type TradeSizeDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TradeSizeDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TradeSizeDataCountAggregateInputType | true
    }

  export interface TradeSizeDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TradeSizeData'], meta: { name: 'TradeSizeData' } }
    /**
     * Find zero or one TradeSizeData that matches the filter.
     * @param {TradeSizeDataFindUniqueArgs} args - Arguments to find a TradeSizeData
     * @example
     * // Get one TradeSizeData
     * const tradeSizeData = await prisma.tradeSizeData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TradeSizeDataFindUniqueArgs>(args: SelectSubset<T, TradeSizeDataFindUniqueArgs<ExtArgs>>): Prisma__TradeSizeDataClient<$Result.GetResult<Prisma.$TradeSizeDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TradeSizeData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TradeSizeDataFindUniqueOrThrowArgs} args - Arguments to find a TradeSizeData
     * @example
     * // Get one TradeSizeData
     * const tradeSizeData = await prisma.tradeSizeData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TradeSizeDataFindUniqueOrThrowArgs>(args: SelectSubset<T, TradeSizeDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TradeSizeDataClient<$Result.GetResult<Prisma.$TradeSizeDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TradeSizeData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeSizeDataFindFirstArgs} args - Arguments to find a TradeSizeData
     * @example
     * // Get one TradeSizeData
     * const tradeSizeData = await prisma.tradeSizeData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TradeSizeDataFindFirstArgs>(args?: SelectSubset<T, TradeSizeDataFindFirstArgs<ExtArgs>>): Prisma__TradeSizeDataClient<$Result.GetResult<Prisma.$TradeSizeDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TradeSizeData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeSizeDataFindFirstOrThrowArgs} args - Arguments to find a TradeSizeData
     * @example
     * // Get one TradeSizeData
     * const tradeSizeData = await prisma.tradeSizeData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TradeSizeDataFindFirstOrThrowArgs>(args?: SelectSubset<T, TradeSizeDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__TradeSizeDataClient<$Result.GetResult<Prisma.$TradeSizeDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TradeSizeData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeSizeDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TradeSizeData
     * const tradeSizeData = await prisma.tradeSizeData.findMany()
     * 
     * // Get first 10 TradeSizeData
     * const tradeSizeData = await prisma.tradeSizeData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tradeSizeDataWithIdOnly = await prisma.tradeSizeData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TradeSizeDataFindManyArgs>(args?: SelectSubset<T, TradeSizeDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeSizeDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TradeSizeData.
     * @param {TradeSizeDataCreateArgs} args - Arguments to create a TradeSizeData.
     * @example
     * // Create one TradeSizeData
     * const TradeSizeData = await prisma.tradeSizeData.create({
     *   data: {
     *     // ... data to create a TradeSizeData
     *   }
     * })
     * 
     */
    create<T extends TradeSizeDataCreateArgs>(args: SelectSubset<T, TradeSizeDataCreateArgs<ExtArgs>>): Prisma__TradeSizeDataClient<$Result.GetResult<Prisma.$TradeSizeDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TradeSizeData.
     * @param {TradeSizeDataCreateManyArgs} args - Arguments to create many TradeSizeData.
     * @example
     * // Create many TradeSizeData
     * const tradeSizeData = await prisma.tradeSizeData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TradeSizeDataCreateManyArgs>(args?: SelectSubset<T, TradeSizeDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TradeSizeData and returns the data saved in the database.
     * @param {TradeSizeDataCreateManyAndReturnArgs} args - Arguments to create many TradeSizeData.
     * @example
     * // Create many TradeSizeData
     * const tradeSizeData = await prisma.tradeSizeData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TradeSizeData and only return the `id`
     * const tradeSizeDataWithIdOnly = await prisma.tradeSizeData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TradeSizeDataCreateManyAndReturnArgs>(args?: SelectSubset<T, TradeSizeDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeSizeDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TradeSizeData.
     * @param {TradeSizeDataDeleteArgs} args - Arguments to delete one TradeSizeData.
     * @example
     * // Delete one TradeSizeData
     * const TradeSizeData = await prisma.tradeSizeData.delete({
     *   where: {
     *     // ... filter to delete one TradeSizeData
     *   }
     * })
     * 
     */
    delete<T extends TradeSizeDataDeleteArgs>(args: SelectSubset<T, TradeSizeDataDeleteArgs<ExtArgs>>): Prisma__TradeSizeDataClient<$Result.GetResult<Prisma.$TradeSizeDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TradeSizeData.
     * @param {TradeSizeDataUpdateArgs} args - Arguments to update one TradeSizeData.
     * @example
     * // Update one TradeSizeData
     * const tradeSizeData = await prisma.tradeSizeData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TradeSizeDataUpdateArgs>(args: SelectSubset<T, TradeSizeDataUpdateArgs<ExtArgs>>): Prisma__TradeSizeDataClient<$Result.GetResult<Prisma.$TradeSizeDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TradeSizeData.
     * @param {TradeSizeDataDeleteManyArgs} args - Arguments to filter TradeSizeData to delete.
     * @example
     * // Delete a few TradeSizeData
     * const { count } = await prisma.tradeSizeData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TradeSizeDataDeleteManyArgs>(args?: SelectSubset<T, TradeSizeDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TradeSizeData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeSizeDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TradeSizeData
     * const tradeSizeData = await prisma.tradeSizeData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TradeSizeDataUpdateManyArgs>(args: SelectSubset<T, TradeSizeDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TradeSizeData and returns the data updated in the database.
     * @param {TradeSizeDataUpdateManyAndReturnArgs} args - Arguments to update many TradeSizeData.
     * @example
     * // Update many TradeSizeData
     * const tradeSizeData = await prisma.tradeSizeData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TradeSizeData and only return the `id`
     * const tradeSizeDataWithIdOnly = await prisma.tradeSizeData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TradeSizeDataUpdateManyAndReturnArgs>(args: SelectSubset<T, TradeSizeDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeSizeDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TradeSizeData.
     * @param {TradeSizeDataUpsertArgs} args - Arguments to update or create a TradeSizeData.
     * @example
     * // Update or create a TradeSizeData
     * const tradeSizeData = await prisma.tradeSizeData.upsert({
     *   create: {
     *     // ... data to create a TradeSizeData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TradeSizeData we want to update
     *   }
     * })
     */
    upsert<T extends TradeSizeDataUpsertArgs>(args: SelectSubset<T, TradeSizeDataUpsertArgs<ExtArgs>>): Prisma__TradeSizeDataClient<$Result.GetResult<Prisma.$TradeSizeDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TradeSizeData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeSizeDataCountArgs} args - Arguments to filter TradeSizeData to count.
     * @example
     * // Count the number of TradeSizeData
     * const count = await prisma.tradeSizeData.count({
     *   where: {
     *     // ... the filter for the TradeSizeData we want to count
     *   }
     * })
    **/
    count<T extends TradeSizeDataCountArgs>(
      args?: Subset<T, TradeSizeDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TradeSizeDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TradeSizeData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeSizeDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TradeSizeDataAggregateArgs>(args: Subset<T, TradeSizeDataAggregateArgs>): Prisma.PrismaPromise<GetTradeSizeDataAggregateType<T>>

    /**
     * Group by TradeSizeData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeSizeDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TradeSizeDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TradeSizeDataGroupByArgs['orderBy'] }
        : { orderBy?: TradeSizeDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TradeSizeDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTradeSizeDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TradeSizeData model
   */
  readonly fields: TradeSizeDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TradeSizeData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TradeSizeDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserAnalyticsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserAnalyticsDefaultArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TradeSizeData model
   */
  interface TradeSizeDataFieldRefs {
    readonly id: FieldRef<"TradeSizeData", 'String'>
    readonly userId: FieldRef<"TradeSizeData", 'String'>
    readonly averageSize: FieldRef<"TradeSizeData", 'Float'>
    readonly medianSize: FieldRef<"TradeSizeData", 'Float'>
    readonly minSize: FieldRef<"TradeSizeData", 'Float'>
    readonly maxSize: FieldRef<"TradeSizeData", 'Float'>
    readonly smallTrades: FieldRef<"TradeSizeData", 'Int'>
    readonly mediumTrades: FieldRef<"TradeSizeData", 'Int'>
    readonly largeTrades: FieldRef<"TradeSizeData", 'Int'>
    readonly createdAt: FieldRef<"TradeSizeData", 'DateTime'>
    readonly updatedAt: FieldRef<"TradeSizeData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TradeSizeData findUnique
   */
  export type TradeSizeDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeSizeData
     */
    select?: TradeSizeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeSizeData
     */
    omit?: TradeSizeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeSizeDataInclude<ExtArgs> | null
    /**
     * Filter, which TradeSizeData to fetch.
     */
    where: TradeSizeDataWhereUniqueInput
  }

  /**
   * TradeSizeData findUniqueOrThrow
   */
  export type TradeSizeDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeSizeData
     */
    select?: TradeSizeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeSizeData
     */
    omit?: TradeSizeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeSizeDataInclude<ExtArgs> | null
    /**
     * Filter, which TradeSizeData to fetch.
     */
    where: TradeSizeDataWhereUniqueInput
  }

  /**
   * TradeSizeData findFirst
   */
  export type TradeSizeDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeSizeData
     */
    select?: TradeSizeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeSizeData
     */
    omit?: TradeSizeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeSizeDataInclude<ExtArgs> | null
    /**
     * Filter, which TradeSizeData to fetch.
     */
    where?: TradeSizeDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeSizeData to fetch.
     */
    orderBy?: TradeSizeDataOrderByWithRelationInput | TradeSizeDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeSizeData.
     */
    cursor?: TradeSizeDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeSizeData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeSizeData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeSizeData.
     */
    distinct?: TradeSizeDataScalarFieldEnum | TradeSizeDataScalarFieldEnum[]
  }

  /**
   * TradeSizeData findFirstOrThrow
   */
  export type TradeSizeDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeSizeData
     */
    select?: TradeSizeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeSizeData
     */
    omit?: TradeSizeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeSizeDataInclude<ExtArgs> | null
    /**
     * Filter, which TradeSizeData to fetch.
     */
    where?: TradeSizeDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeSizeData to fetch.
     */
    orderBy?: TradeSizeDataOrderByWithRelationInput | TradeSizeDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeSizeData.
     */
    cursor?: TradeSizeDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeSizeData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeSizeData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeSizeData.
     */
    distinct?: TradeSizeDataScalarFieldEnum | TradeSizeDataScalarFieldEnum[]
  }

  /**
   * TradeSizeData findMany
   */
  export type TradeSizeDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeSizeData
     */
    select?: TradeSizeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeSizeData
     */
    omit?: TradeSizeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeSizeDataInclude<ExtArgs> | null
    /**
     * Filter, which TradeSizeData to fetch.
     */
    where?: TradeSizeDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeSizeData to fetch.
     */
    orderBy?: TradeSizeDataOrderByWithRelationInput | TradeSizeDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TradeSizeData.
     */
    cursor?: TradeSizeDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeSizeData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeSizeData.
     */
    skip?: number
    distinct?: TradeSizeDataScalarFieldEnum | TradeSizeDataScalarFieldEnum[]
  }

  /**
   * TradeSizeData create
   */
  export type TradeSizeDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeSizeData
     */
    select?: TradeSizeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeSizeData
     */
    omit?: TradeSizeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeSizeDataInclude<ExtArgs> | null
    /**
     * The data needed to create a TradeSizeData.
     */
    data: XOR<TradeSizeDataCreateInput, TradeSizeDataUncheckedCreateInput>
  }

  /**
   * TradeSizeData createMany
   */
  export type TradeSizeDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TradeSizeData.
     */
    data: TradeSizeDataCreateManyInput | TradeSizeDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TradeSizeData createManyAndReturn
   */
  export type TradeSizeDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeSizeData
     */
    select?: TradeSizeDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TradeSizeData
     */
    omit?: TradeSizeDataOmit<ExtArgs> | null
    /**
     * The data used to create many TradeSizeData.
     */
    data: TradeSizeDataCreateManyInput | TradeSizeDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeSizeDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TradeSizeData update
   */
  export type TradeSizeDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeSizeData
     */
    select?: TradeSizeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeSizeData
     */
    omit?: TradeSizeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeSizeDataInclude<ExtArgs> | null
    /**
     * The data needed to update a TradeSizeData.
     */
    data: XOR<TradeSizeDataUpdateInput, TradeSizeDataUncheckedUpdateInput>
    /**
     * Choose, which TradeSizeData to update.
     */
    where: TradeSizeDataWhereUniqueInput
  }

  /**
   * TradeSizeData updateMany
   */
  export type TradeSizeDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TradeSizeData.
     */
    data: XOR<TradeSizeDataUpdateManyMutationInput, TradeSizeDataUncheckedUpdateManyInput>
    /**
     * Filter which TradeSizeData to update
     */
    where?: TradeSizeDataWhereInput
    /**
     * Limit how many TradeSizeData to update.
     */
    limit?: number
  }

  /**
   * TradeSizeData updateManyAndReturn
   */
  export type TradeSizeDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeSizeData
     */
    select?: TradeSizeDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TradeSizeData
     */
    omit?: TradeSizeDataOmit<ExtArgs> | null
    /**
     * The data used to update TradeSizeData.
     */
    data: XOR<TradeSizeDataUpdateManyMutationInput, TradeSizeDataUncheckedUpdateManyInput>
    /**
     * Filter which TradeSizeData to update
     */
    where?: TradeSizeDataWhereInput
    /**
     * Limit how many TradeSizeData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeSizeDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TradeSizeData upsert
   */
  export type TradeSizeDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeSizeData
     */
    select?: TradeSizeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeSizeData
     */
    omit?: TradeSizeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeSizeDataInclude<ExtArgs> | null
    /**
     * The filter to search for the TradeSizeData to update in case it exists.
     */
    where: TradeSizeDataWhereUniqueInput
    /**
     * In case the TradeSizeData found by the `where` argument doesn't exist, create a new TradeSizeData with this data.
     */
    create: XOR<TradeSizeDataCreateInput, TradeSizeDataUncheckedCreateInput>
    /**
     * In case the TradeSizeData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TradeSizeDataUpdateInput, TradeSizeDataUncheckedUpdateInput>
  }

  /**
   * TradeSizeData delete
   */
  export type TradeSizeDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeSizeData
     */
    select?: TradeSizeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeSizeData
     */
    omit?: TradeSizeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeSizeDataInclude<ExtArgs> | null
    /**
     * Filter which TradeSizeData to delete.
     */
    where: TradeSizeDataWhereUniqueInput
  }

  /**
   * TradeSizeData deleteMany
   */
  export type TradeSizeDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeSizeData to delete
     */
    where?: TradeSizeDataWhereInput
    /**
     * Limit how many TradeSizeData to delete.
     */
    limit?: number
  }

  /**
   * TradeSizeData without action
   */
  export type TradeSizeDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeSizeData
     */
    select?: TradeSizeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeSizeData
     */
    omit?: TradeSizeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeSizeDataInclude<ExtArgs> | null
  }


  /**
   * Model PriceStats
   */

  export type AggregatePriceStats = {
    _count: PriceStatsCountAggregateOutputType | null
    _avg: PriceStatsAvgAggregateOutputType | null
    _sum: PriceStatsSumAggregateOutputType | null
    _min: PriceStatsMinAggregateOutputType | null
    _max: PriceStatsMaxAggregateOutputType | null
  }

  export type PriceStatsAvgAggregateOutputType = {
    averagePrice: number | null
    minPrice: number | null
    maxPrice: number | null
  }

  export type PriceStatsSumAggregateOutputType = {
    averagePrice: number | null
    minPrice: number | null
    maxPrice: number | null
  }

  export type PriceStatsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    averagePrice: number | null
    minPrice: number | null
    maxPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PriceStatsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    averagePrice: number | null
    minPrice: number | null
    maxPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PriceStatsCountAggregateOutputType = {
    id: number
    userId: number
    averagePrice: number
    minPrice: number
    maxPrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PriceStatsAvgAggregateInputType = {
    averagePrice?: true
    minPrice?: true
    maxPrice?: true
  }

  export type PriceStatsSumAggregateInputType = {
    averagePrice?: true
    minPrice?: true
    maxPrice?: true
  }

  export type PriceStatsMinAggregateInputType = {
    id?: true
    userId?: true
    averagePrice?: true
    minPrice?: true
    maxPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PriceStatsMaxAggregateInputType = {
    id?: true
    userId?: true
    averagePrice?: true
    minPrice?: true
    maxPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PriceStatsCountAggregateInputType = {
    id?: true
    userId?: true
    averagePrice?: true
    minPrice?: true
    maxPrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PriceStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceStats to aggregate.
     */
    where?: PriceStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceStats to fetch.
     */
    orderBy?: PriceStatsOrderByWithRelationInput | PriceStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceStats
    **/
    _count?: true | PriceStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceStatsMaxAggregateInputType
  }

  export type GetPriceStatsAggregateType<T extends PriceStatsAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceStats[P]>
      : GetScalarType<T[P], AggregatePriceStats[P]>
  }




  export type PriceStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceStatsWhereInput
    orderBy?: PriceStatsOrderByWithAggregationInput | PriceStatsOrderByWithAggregationInput[]
    by: PriceStatsScalarFieldEnum[] | PriceStatsScalarFieldEnum
    having?: PriceStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceStatsCountAggregateInputType | true
    _avg?: PriceStatsAvgAggregateInputType
    _sum?: PriceStatsSumAggregateInputType
    _min?: PriceStatsMinAggregateInputType
    _max?: PriceStatsMaxAggregateInputType
  }

  export type PriceStatsGroupByOutputType = {
    id: string
    userId: string
    averagePrice: number
    minPrice: number
    maxPrice: number
    createdAt: Date
    updatedAt: Date
    _count: PriceStatsCountAggregateOutputType | null
    _avg: PriceStatsAvgAggregateOutputType | null
    _sum: PriceStatsSumAggregateOutputType | null
    _min: PriceStatsMinAggregateOutputType | null
    _max: PriceStatsMaxAggregateOutputType | null
  }

  type GetPriceStatsGroupByPayload<T extends PriceStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceStatsGroupByOutputType[P]>
            : GetScalarType<T[P], PriceStatsGroupByOutputType[P]>
        }
      >
    >


  export type PriceStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    averagePrice?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceStats"]>

  export type PriceStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    averagePrice?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceStats"]>

  export type PriceStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    averagePrice?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceStats"]>

  export type PriceStatsSelectScalar = {
    id?: boolean
    userId?: boolean
    averagePrice?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PriceStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "averagePrice" | "minPrice" | "maxPrice" | "createdAt" | "updatedAt", ExtArgs["result"]["priceStats"]>
  export type PriceStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }
  export type PriceStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }
  export type PriceStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }

  export type $PriceStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceStats"
    objects: {
      user: Prisma.$UserAnalyticsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      averagePrice: number
      minPrice: number
      maxPrice: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["priceStats"]>
    composites: {}
  }

  type PriceStatsGetPayload<S extends boolean | null | undefined | PriceStatsDefaultArgs> = $Result.GetResult<Prisma.$PriceStatsPayload, S>

  type PriceStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PriceStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PriceStatsCountAggregateInputType | true
    }

  export interface PriceStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceStats'], meta: { name: 'PriceStats' } }
    /**
     * Find zero or one PriceStats that matches the filter.
     * @param {PriceStatsFindUniqueArgs} args - Arguments to find a PriceStats
     * @example
     * // Get one PriceStats
     * const priceStats = await prisma.priceStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceStatsFindUniqueArgs>(args: SelectSubset<T, PriceStatsFindUniqueArgs<ExtArgs>>): Prisma__PriceStatsClient<$Result.GetResult<Prisma.$PriceStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PriceStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PriceStatsFindUniqueOrThrowArgs} args - Arguments to find a PriceStats
     * @example
     * // Get one PriceStats
     * const priceStats = await prisma.priceStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceStatsClient<$Result.GetResult<Prisma.$PriceStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceStatsFindFirstArgs} args - Arguments to find a PriceStats
     * @example
     * // Get one PriceStats
     * const priceStats = await prisma.priceStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceStatsFindFirstArgs>(args?: SelectSubset<T, PriceStatsFindFirstArgs<ExtArgs>>): Prisma__PriceStatsClient<$Result.GetResult<Prisma.$PriceStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceStatsFindFirstOrThrowArgs} args - Arguments to find a PriceStats
     * @example
     * // Get one PriceStats
     * const priceStats = await prisma.priceStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceStatsClient<$Result.GetResult<Prisma.$PriceStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PriceStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceStats
     * const priceStats = await prisma.priceStats.findMany()
     * 
     * // Get first 10 PriceStats
     * const priceStats = await prisma.priceStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceStatsWithIdOnly = await prisma.priceStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceStatsFindManyArgs>(args?: SelectSubset<T, PriceStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PriceStats.
     * @param {PriceStatsCreateArgs} args - Arguments to create a PriceStats.
     * @example
     * // Create one PriceStats
     * const PriceStats = await prisma.priceStats.create({
     *   data: {
     *     // ... data to create a PriceStats
     *   }
     * })
     * 
     */
    create<T extends PriceStatsCreateArgs>(args: SelectSubset<T, PriceStatsCreateArgs<ExtArgs>>): Prisma__PriceStatsClient<$Result.GetResult<Prisma.$PriceStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PriceStats.
     * @param {PriceStatsCreateManyArgs} args - Arguments to create many PriceStats.
     * @example
     * // Create many PriceStats
     * const priceStats = await prisma.priceStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceStatsCreateManyArgs>(args?: SelectSubset<T, PriceStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PriceStats and returns the data saved in the database.
     * @param {PriceStatsCreateManyAndReturnArgs} args - Arguments to create many PriceStats.
     * @example
     * // Create many PriceStats
     * const priceStats = await prisma.priceStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PriceStats and only return the `id`
     * const priceStatsWithIdOnly = await prisma.priceStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriceStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, PriceStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PriceStats.
     * @param {PriceStatsDeleteArgs} args - Arguments to delete one PriceStats.
     * @example
     * // Delete one PriceStats
     * const PriceStats = await prisma.priceStats.delete({
     *   where: {
     *     // ... filter to delete one PriceStats
     *   }
     * })
     * 
     */
    delete<T extends PriceStatsDeleteArgs>(args: SelectSubset<T, PriceStatsDeleteArgs<ExtArgs>>): Prisma__PriceStatsClient<$Result.GetResult<Prisma.$PriceStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PriceStats.
     * @param {PriceStatsUpdateArgs} args - Arguments to update one PriceStats.
     * @example
     * // Update one PriceStats
     * const priceStats = await prisma.priceStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceStatsUpdateArgs>(args: SelectSubset<T, PriceStatsUpdateArgs<ExtArgs>>): Prisma__PriceStatsClient<$Result.GetResult<Prisma.$PriceStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PriceStats.
     * @param {PriceStatsDeleteManyArgs} args - Arguments to filter PriceStats to delete.
     * @example
     * // Delete a few PriceStats
     * const { count } = await prisma.priceStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceStatsDeleteManyArgs>(args?: SelectSubset<T, PriceStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceStats
     * const priceStats = await prisma.priceStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceStatsUpdateManyArgs>(args: SelectSubset<T, PriceStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceStats and returns the data updated in the database.
     * @param {PriceStatsUpdateManyAndReturnArgs} args - Arguments to update many PriceStats.
     * @example
     * // Update many PriceStats
     * const priceStats = await prisma.priceStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PriceStats and only return the `id`
     * const priceStatsWithIdOnly = await prisma.priceStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PriceStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, PriceStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PriceStats.
     * @param {PriceStatsUpsertArgs} args - Arguments to update or create a PriceStats.
     * @example
     * // Update or create a PriceStats
     * const priceStats = await prisma.priceStats.upsert({
     *   create: {
     *     // ... data to create a PriceStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceStats we want to update
     *   }
     * })
     */
    upsert<T extends PriceStatsUpsertArgs>(args: SelectSubset<T, PriceStatsUpsertArgs<ExtArgs>>): Prisma__PriceStatsClient<$Result.GetResult<Prisma.$PriceStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PriceStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceStatsCountArgs} args - Arguments to filter PriceStats to count.
     * @example
     * // Count the number of PriceStats
     * const count = await prisma.priceStats.count({
     *   where: {
     *     // ... the filter for the PriceStats we want to count
     *   }
     * })
    **/
    count<T extends PriceStatsCountArgs>(
      args?: Subset<T, PriceStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceStatsAggregateArgs>(args: Subset<T, PriceStatsAggregateArgs>): Prisma.PrismaPromise<GetPriceStatsAggregateType<T>>

    /**
     * Group by PriceStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceStatsGroupByArgs['orderBy'] }
        : { orderBy?: PriceStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceStats model
   */
  readonly fields: PriceStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserAnalyticsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserAnalyticsDefaultArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriceStats model
   */
  interface PriceStatsFieldRefs {
    readonly id: FieldRef<"PriceStats", 'String'>
    readonly userId: FieldRef<"PriceStats", 'String'>
    readonly averagePrice: FieldRef<"PriceStats", 'Float'>
    readonly minPrice: FieldRef<"PriceStats", 'Float'>
    readonly maxPrice: FieldRef<"PriceStats", 'Float'>
    readonly createdAt: FieldRef<"PriceStats", 'DateTime'>
    readonly updatedAt: FieldRef<"PriceStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PriceStats findUnique
   */
  export type PriceStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceStats
     */
    select?: PriceStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceStats
     */
    omit?: PriceStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceStatsInclude<ExtArgs> | null
    /**
     * Filter, which PriceStats to fetch.
     */
    where: PriceStatsWhereUniqueInput
  }

  /**
   * PriceStats findUniqueOrThrow
   */
  export type PriceStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceStats
     */
    select?: PriceStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceStats
     */
    omit?: PriceStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceStatsInclude<ExtArgs> | null
    /**
     * Filter, which PriceStats to fetch.
     */
    where: PriceStatsWhereUniqueInput
  }

  /**
   * PriceStats findFirst
   */
  export type PriceStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceStats
     */
    select?: PriceStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceStats
     */
    omit?: PriceStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceStatsInclude<ExtArgs> | null
    /**
     * Filter, which PriceStats to fetch.
     */
    where?: PriceStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceStats to fetch.
     */
    orderBy?: PriceStatsOrderByWithRelationInput | PriceStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceStats.
     */
    cursor?: PriceStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceStats.
     */
    distinct?: PriceStatsScalarFieldEnum | PriceStatsScalarFieldEnum[]
  }

  /**
   * PriceStats findFirstOrThrow
   */
  export type PriceStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceStats
     */
    select?: PriceStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceStats
     */
    omit?: PriceStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceStatsInclude<ExtArgs> | null
    /**
     * Filter, which PriceStats to fetch.
     */
    where?: PriceStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceStats to fetch.
     */
    orderBy?: PriceStatsOrderByWithRelationInput | PriceStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceStats.
     */
    cursor?: PriceStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceStats.
     */
    distinct?: PriceStatsScalarFieldEnum | PriceStatsScalarFieldEnum[]
  }

  /**
   * PriceStats findMany
   */
  export type PriceStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceStats
     */
    select?: PriceStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceStats
     */
    omit?: PriceStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceStatsInclude<ExtArgs> | null
    /**
     * Filter, which PriceStats to fetch.
     */
    where?: PriceStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceStats to fetch.
     */
    orderBy?: PriceStatsOrderByWithRelationInput | PriceStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceStats.
     */
    cursor?: PriceStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceStats.
     */
    skip?: number
    distinct?: PriceStatsScalarFieldEnum | PriceStatsScalarFieldEnum[]
  }

  /**
   * PriceStats create
   */
  export type PriceStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceStats
     */
    select?: PriceStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceStats
     */
    omit?: PriceStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a PriceStats.
     */
    data: XOR<PriceStatsCreateInput, PriceStatsUncheckedCreateInput>
  }

  /**
   * PriceStats createMany
   */
  export type PriceStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceStats.
     */
    data: PriceStatsCreateManyInput | PriceStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceStats createManyAndReturn
   */
  export type PriceStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceStats
     */
    select?: PriceStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceStats
     */
    omit?: PriceStatsOmit<ExtArgs> | null
    /**
     * The data used to create many PriceStats.
     */
    data: PriceStatsCreateManyInput | PriceStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceStats update
   */
  export type PriceStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceStats
     */
    select?: PriceStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceStats
     */
    omit?: PriceStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a PriceStats.
     */
    data: XOR<PriceStatsUpdateInput, PriceStatsUncheckedUpdateInput>
    /**
     * Choose, which PriceStats to update.
     */
    where: PriceStatsWhereUniqueInput
  }

  /**
   * PriceStats updateMany
   */
  export type PriceStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceStats.
     */
    data: XOR<PriceStatsUpdateManyMutationInput, PriceStatsUncheckedUpdateManyInput>
    /**
     * Filter which PriceStats to update
     */
    where?: PriceStatsWhereInput
    /**
     * Limit how many PriceStats to update.
     */
    limit?: number
  }

  /**
   * PriceStats updateManyAndReturn
   */
  export type PriceStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceStats
     */
    select?: PriceStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceStats
     */
    omit?: PriceStatsOmit<ExtArgs> | null
    /**
     * The data used to update PriceStats.
     */
    data: XOR<PriceStatsUpdateManyMutationInput, PriceStatsUncheckedUpdateManyInput>
    /**
     * Filter which PriceStats to update
     */
    where?: PriceStatsWhereInput
    /**
     * Limit how many PriceStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceStats upsert
   */
  export type PriceStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceStats
     */
    select?: PriceStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceStats
     */
    omit?: PriceStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the PriceStats to update in case it exists.
     */
    where: PriceStatsWhereUniqueInput
    /**
     * In case the PriceStats found by the `where` argument doesn't exist, create a new PriceStats with this data.
     */
    create: XOR<PriceStatsCreateInput, PriceStatsUncheckedCreateInput>
    /**
     * In case the PriceStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceStatsUpdateInput, PriceStatsUncheckedUpdateInput>
  }

  /**
   * PriceStats delete
   */
  export type PriceStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceStats
     */
    select?: PriceStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceStats
     */
    omit?: PriceStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceStatsInclude<ExtArgs> | null
    /**
     * Filter which PriceStats to delete.
     */
    where: PriceStatsWhereUniqueInput
  }

  /**
   * PriceStats deleteMany
   */
  export type PriceStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceStats to delete
     */
    where?: PriceStatsWhereInput
    /**
     * Limit how many PriceStats to delete.
     */
    limit?: number
  }

  /**
   * PriceStats without action
   */
  export type PriceStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceStats
     */
    select?: PriceStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceStats
     */
    omit?: PriceStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceStatsInclude<ExtArgs> | null
  }


  /**
   * Model MonthlyPerformance
   */

  export type AggregateMonthlyPerformance = {
    _count: MonthlyPerformanceCountAggregateOutputType | null
    _avg: MonthlyPerformanceAvgAggregateOutputType | null
    _sum: MonthlyPerformanceSumAggregateOutputType | null
    _min: MonthlyPerformanceMinAggregateOutputType | null
    _max: MonthlyPerformanceMaxAggregateOutputType | null
  }

  export type MonthlyPerformanceAvgAggregateOutputType = {
    profit: number | null
    volume: number | null
    trades: number | null
  }

  export type MonthlyPerformanceSumAggregateOutputType = {
    profit: number | null
    volume: number | null
    trades: number | null
  }

  export type MonthlyPerformanceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    month: string | null
    yearMonth: string | null
    profit: number | null
    volume: number | null
    trades: number | null
    createdAt: Date | null
  }

  export type MonthlyPerformanceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    month: string | null
    yearMonth: string | null
    profit: number | null
    volume: number | null
    trades: number | null
    createdAt: Date | null
  }

  export type MonthlyPerformanceCountAggregateOutputType = {
    id: number
    userId: number
    month: number
    yearMonth: number
    profit: number
    volume: number
    trades: number
    createdAt: number
    _all: number
  }


  export type MonthlyPerformanceAvgAggregateInputType = {
    profit?: true
    volume?: true
    trades?: true
  }

  export type MonthlyPerformanceSumAggregateInputType = {
    profit?: true
    volume?: true
    trades?: true
  }

  export type MonthlyPerformanceMinAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    yearMonth?: true
    profit?: true
    volume?: true
    trades?: true
    createdAt?: true
  }

  export type MonthlyPerformanceMaxAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    yearMonth?: true
    profit?: true
    volume?: true
    trades?: true
    createdAt?: true
  }

  export type MonthlyPerformanceCountAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    yearMonth?: true
    profit?: true
    volume?: true
    trades?: true
    createdAt?: true
    _all?: true
  }

  export type MonthlyPerformanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonthlyPerformance to aggregate.
     */
    where?: MonthlyPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlyPerformances to fetch.
     */
    orderBy?: MonthlyPerformanceOrderByWithRelationInput | MonthlyPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MonthlyPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlyPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlyPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MonthlyPerformances
    **/
    _count?: true | MonthlyPerformanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonthlyPerformanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonthlyPerformanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonthlyPerformanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonthlyPerformanceMaxAggregateInputType
  }

  export type GetMonthlyPerformanceAggregateType<T extends MonthlyPerformanceAggregateArgs> = {
        [P in keyof T & keyof AggregateMonthlyPerformance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonthlyPerformance[P]>
      : GetScalarType<T[P], AggregateMonthlyPerformance[P]>
  }




  export type MonthlyPerformanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthlyPerformanceWhereInput
    orderBy?: MonthlyPerformanceOrderByWithAggregationInput | MonthlyPerformanceOrderByWithAggregationInput[]
    by: MonthlyPerformanceScalarFieldEnum[] | MonthlyPerformanceScalarFieldEnum
    having?: MonthlyPerformanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonthlyPerformanceCountAggregateInputType | true
    _avg?: MonthlyPerformanceAvgAggregateInputType
    _sum?: MonthlyPerformanceSumAggregateInputType
    _min?: MonthlyPerformanceMinAggregateInputType
    _max?: MonthlyPerformanceMaxAggregateInputType
  }

  export type MonthlyPerformanceGroupByOutputType = {
    id: string
    userId: string
    month: string
    yearMonth: string
    profit: number
    volume: number
    trades: number
    createdAt: Date
    _count: MonthlyPerformanceCountAggregateOutputType | null
    _avg: MonthlyPerformanceAvgAggregateOutputType | null
    _sum: MonthlyPerformanceSumAggregateOutputType | null
    _min: MonthlyPerformanceMinAggregateOutputType | null
    _max: MonthlyPerformanceMaxAggregateOutputType | null
  }

  type GetMonthlyPerformanceGroupByPayload<T extends MonthlyPerformanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonthlyPerformanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonthlyPerformanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonthlyPerformanceGroupByOutputType[P]>
            : GetScalarType<T[P], MonthlyPerformanceGroupByOutputType[P]>
        }
      >
    >


  export type MonthlyPerformanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    month?: boolean
    yearMonth?: boolean
    profit?: boolean
    volume?: boolean
    trades?: boolean
    createdAt?: boolean
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monthlyPerformance"]>

  export type MonthlyPerformanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    month?: boolean
    yearMonth?: boolean
    profit?: boolean
    volume?: boolean
    trades?: boolean
    createdAt?: boolean
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monthlyPerformance"]>

  export type MonthlyPerformanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    month?: boolean
    yearMonth?: boolean
    profit?: boolean
    volume?: boolean
    trades?: boolean
    createdAt?: boolean
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monthlyPerformance"]>

  export type MonthlyPerformanceSelectScalar = {
    id?: boolean
    userId?: boolean
    month?: boolean
    yearMonth?: boolean
    profit?: boolean
    volume?: boolean
    trades?: boolean
    createdAt?: boolean
  }

  export type MonthlyPerformanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "month" | "yearMonth" | "profit" | "volume" | "trades" | "createdAt", ExtArgs["result"]["monthlyPerformance"]>
  export type MonthlyPerformanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }
  export type MonthlyPerformanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }
  export type MonthlyPerformanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }

  export type $MonthlyPerformancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MonthlyPerformance"
    objects: {
      user: Prisma.$UserAnalyticsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      month: string
      yearMonth: string
      profit: number
      volume: number
      trades: number
      createdAt: Date
    }, ExtArgs["result"]["monthlyPerformance"]>
    composites: {}
  }

  type MonthlyPerformanceGetPayload<S extends boolean | null | undefined | MonthlyPerformanceDefaultArgs> = $Result.GetResult<Prisma.$MonthlyPerformancePayload, S>

  type MonthlyPerformanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MonthlyPerformanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MonthlyPerformanceCountAggregateInputType | true
    }

  export interface MonthlyPerformanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MonthlyPerformance'], meta: { name: 'MonthlyPerformance' } }
    /**
     * Find zero or one MonthlyPerformance that matches the filter.
     * @param {MonthlyPerformanceFindUniqueArgs} args - Arguments to find a MonthlyPerformance
     * @example
     * // Get one MonthlyPerformance
     * const monthlyPerformance = await prisma.monthlyPerformance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MonthlyPerformanceFindUniqueArgs>(args: SelectSubset<T, MonthlyPerformanceFindUniqueArgs<ExtArgs>>): Prisma__MonthlyPerformanceClient<$Result.GetResult<Prisma.$MonthlyPerformancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MonthlyPerformance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MonthlyPerformanceFindUniqueOrThrowArgs} args - Arguments to find a MonthlyPerformance
     * @example
     * // Get one MonthlyPerformance
     * const monthlyPerformance = await prisma.monthlyPerformance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MonthlyPerformanceFindUniqueOrThrowArgs>(args: SelectSubset<T, MonthlyPerformanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MonthlyPerformanceClient<$Result.GetResult<Prisma.$MonthlyPerformancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MonthlyPerformance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyPerformanceFindFirstArgs} args - Arguments to find a MonthlyPerformance
     * @example
     * // Get one MonthlyPerformance
     * const monthlyPerformance = await prisma.monthlyPerformance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MonthlyPerformanceFindFirstArgs>(args?: SelectSubset<T, MonthlyPerformanceFindFirstArgs<ExtArgs>>): Prisma__MonthlyPerformanceClient<$Result.GetResult<Prisma.$MonthlyPerformancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MonthlyPerformance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyPerformanceFindFirstOrThrowArgs} args - Arguments to find a MonthlyPerformance
     * @example
     * // Get one MonthlyPerformance
     * const monthlyPerformance = await prisma.monthlyPerformance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MonthlyPerformanceFindFirstOrThrowArgs>(args?: SelectSubset<T, MonthlyPerformanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__MonthlyPerformanceClient<$Result.GetResult<Prisma.$MonthlyPerformancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MonthlyPerformances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyPerformanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MonthlyPerformances
     * const monthlyPerformances = await prisma.monthlyPerformance.findMany()
     * 
     * // Get first 10 MonthlyPerformances
     * const monthlyPerformances = await prisma.monthlyPerformance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monthlyPerformanceWithIdOnly = await prisma.monthlyPerformance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MonthlyPerformanceFindManyArgs>(args?: SelectSubset<T, MonthlyPerformanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlyPerformancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MonthlyPerformance.
     * @param {MonthlyPerformanceCreateArgs} args - Arguments to create a MonthlyPerformance.
     * @example
     * // Create one MonthlyPerformance
     * const MonthlyPerformance = await prisma.monthlyPerformance.create({
     *   data: {
     *     // ... data to create a MonthlyPerformance
     *   }
     * })
     * 
     */
    create<T extends MonthlyPerformanceCreateArgs>(args: SelectSubset<T, MonthlyPerformanceCreateArgs<ExtArgs>>): Prisma__MonthlyPerformanceClient<$Result.GetResult<Prisma.$MonthlyPerformancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MonthlyPerformances.
     * @param {MonthlyPerformanceCreateManyArgs} args - Arguments to create many MonthlyPerformances.
     * @example
     * // Create many MonthlyPerformances
     * const monthlyPerformance = await prisma.monthlyPerformance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MonthlyPerformanceCreateManyArgs>(args?: SelectSubset<T, MonthlyPerformanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MonthlyPerformances and returns the data saved in the database.
     * @param {MonthlyPerformanceCreateManyAndReturnArgs} args - Arguments to create many MonthlyPerformances.
     * @example
     * // Create many MonthlyPerformances
     * const monthlyPerformance = await prisma.monthlyPerformance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MonthlyPerformances and only return the `id`
     * const monthlyPerformanceWithIdOnly = await prisma.monthlyPerformance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MonthlyPerformanceCreateManyAndReturnArgs>(args?: SelectSubset<T, MonthlyPerformanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlyPerformancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MonthlyPerformance.
     * @param {MonthlyPerformanceDeleteArgs} args - Arguments to delete one MonthlyPerformance.
     * @example
     * // Delete one MonthlyPerformance
     * const MonthlyPerformance = await prisma.monthlyPerformance.delete({
     *   where: {
     *     // ... filter to delete one MonthlyPerformance
     *   }
     * })
     * 
     */
    delete<T extends MonthlyPerformanceDeleteArgs>(args: SelectSubset<T, MonthlyPerformanceDeleteArgs<ExtArgs>>): Prisma__MonthlyPerformanceClient<$Result.GetResult<Prisma.$MonthlyPerformancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MonthlyPerformance.
     * @param {MonthlyPerformanceUpdateArgs} args - Arguments to update one MonthlyPerformance.
     * @example
     * // Update one MonthlyPerformance
     * const monthlyPerformance = await prisma.monthlyPerformance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MonthlyPerformanceUpdateArgs>(args: SelectSubset<T, MonthlyPerformanceUpdateArgs<ExtArgs>>): Prisma__MonthlyPerformanceClient<$Result.GetResult<Prisma.$MonthlyPerformancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MonthlyPerformances.
     * @param {MonthlyPerformanceDeleteManyArgs} args - Arguments to filter MonthlyPerformances to delete.
     * @example
     * // Delete a few MonthlyPerformances
     * const { count } = await prisma.monthlyPerformance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MonthlyPerformanceDeleteManyArgs>(args?: SelectSubset<T, MonthlyPerformanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonthlyPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyPerformanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MonthlyPerformances
     * const monthlyPerformance = await prisma.monthlyPerformance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MonthlyPerformanceUpdateManyArgs>(args: SelectSubset<T, MonthlyPerformanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonthlyPerformances and returns the data updated in the database.
     * @param {MonthlyPerformanceUpdateManyAndReturnArgs} args - Arguments to update many MonthlyPerformances.
     * @example
     * // Update many MonthlyPerformances
     * const monthlyPerformance = await prisma.monthlyPerformance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MonthlyPerformances and only return the `id`
     * const monthlyPerformanceWithIdOnly = await prisma.monthlyPerformance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MonthlyPerformanceUpdateManyAndReturnArgs>(args: SelectSubset<T, MonthlyPerformanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlyPerformancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MonthlyPerformance.
     * @param {MonthlyPerformanceUpsertArgs} args - Arguments to update or create a MonthlyPerformance.
     * @example
     * // Update or create a MonthlyPerformance
     * const monthlyPerformance = await prisma.monthlyPerformance.upsert({
     *   create: {
     *     // ... data to create a MonthlyPerformance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MonthlyPerformance we want to update
     *   }
     * })
     */
    upsert<T extends MonthlyPerformanceUpsertArgs>(args: SelectSubset<T, MonthlyPerformanceUpsertArgs<ExtArgs>>): Prisma__MonthlyPerformanceClient<$Result.GetResult<Prisma.$MonthlyPerformancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MonthlyPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyPerformanceCountArgs} args - Arguments to filter MonthlyPerformances to count.
     * @example
     * // Count the number of MonthlyPerformances
     * const count = await prisma.monthlyPerformance.count({
     *   where: {
     *     // ... the filter for the MonthlyPerformances we want to count
     *   }
     * })
    **/
    count<T extends MonthlyPerformanceCountArgs>(
      args?: Subset<T, MonthlyPerformanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonthlyPerformanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MonthlyPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyPerformanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonthlyPerformanceAggregateArgs>(args: Subset<T, MonthlyPerformanceAggregateArgs>): Prisma.PrismaPromise<GetMonthlyPerformanceAggregateType<T>>

    /**
     * Group by MonthlyPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyPerformanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MonthlyPerformanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MonthlyPerformanceGroupByArgs['orderBy'] }
        : { orderBy?: MonthlyPerformanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MonthlyPerformanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonthlyPerformanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MonthlyPerformance model
   */
  readonly fields: MonthlyPerformanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MonthlyPerformance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MonthlyPerformanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserAnalyticsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserAnalyticsDefaultArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MonthlyPerformance model
   */
  interface MonthlyPerformanceFieldRefs {
    readonly id: FieldRef<"MonthlyPerformance", 'String'>
    readonly userId: FieldRef<"MonthlyPerformance", 'String'>
    readonly month: FieldRef<"MonthlyPerformance", 'String'>
    readonly yearMonth: FieldRef<"MonthlyPerformance", 'String'>
    readonly profit: FieldRef<"MonthlyPerformance", 'Float'>
    readonly volume: FieldRef<"MonthlyPerformance", 'Float'>
    readonly trades: FieldRef<"MonthlyPerformance", 'Int'>
    readonly createdAt: FieldRef<"MonthlyPerformance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MonthlyPerformance findUnique
   */
  export type MonthlyPerformanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyPerformance
     */
    select?: MonthlyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyPerformance
     */
    omit?: MonthlyPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which MonthlyPerformance to fetch.
     */
    where: MonthlyPerformanceWhereUniqueInput
  }

  /**
   * MonthlyPerformance findUniqueOrThrow
   */
  export type MonthlyPerformanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyPerformance
     */
    select?: MonthlyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyPerformance
     */
    omit?: MonthlyPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which MonthlyPerformance to fetch.
     */
    where: MonthlyPerformanceWhereUniqueInput
  }

  /**
   * MonthlyPerformance findFirst
   */
  export type MonthlyPerformanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyPerformance
     */
    select?: MonthlyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyPerformance
     */
    omit?: MonthlyPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which MonthlyPerformance to fetch.
     */
    where?: MonthlyPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlyPerformances to fetch.
     */
    orderBy?: MonthlyPerformanceOrderByWithRelationInput | MonthlyPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonthlyPerformances.
     */
    cursor?: MonthlyPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlyPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlyPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonthlyPerformances.
     */
    distinct?: MonthlyPerformanceScalarFieldEnum | MonthlyPerformanceScalarFieldEnum[]
  }

  /**
   * MonthlyPerformance findFirstOrThrow
   */
  export type MonthlyPerformanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyPerformance
     */
    select?: MonthlyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyPerformance
     */
    omit?: MonthlyPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which MonthlyPerformance to fetch.
     */
    where?: MonthlyPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlyPerformances to fetch.
     */
    orderBy?: MonthlyPerformanceOrderByWithRelationInput | MonthlyPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonthlyPerformances.
     */
    cursor?: MonthlyPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlyPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlyPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonthlyPerformances.
     */
    distinct?: MonthlyPerformanceScalarFieldEnum | MonthlyPerformanceScalarFieldEnum[]
  }

  /**
   * MonthlyPerformance findMany
   */
  export type MonthlyPerformanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyPerformance
     */
    select?: MonthlyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyPerformance
     */
    omit?: MonthlyPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which MonthlyPerformances to fetch.
     */
    where?: MonthlyPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlyPerformances to fetch.
     */
    orderBy?: MonthlyPerformanceOrderByWithRelationInput | MonthlyPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MonthlyPerformances.
     */
    cursor?: MonthlyPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlyPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlyPerformances.
     */
    skip?: number
    distinct?: MonthlyPerformanceScalarFieldEnum | MonthlyPerformanceScalarFieldEnum[]
  }

  /**
   * MonthlyPerformance create
   */
  export type MonthlyPerformanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyPerformance
     */
    select?: MonthlyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyPerformance
     */
    omit?: MonthlyPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to create a MonthlyPerformance.
     */
    data: XOR<MonthlyPerformanceCreateInput, MonthlyPerformanceUncheckedCreateInput>
  }

  /**
   * MonthlyPerformance createMany
   */
  export type MonthlyPerformanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MonthlyPerformances.
     */
    data: MonthlyPerformanceCreateManyInput | MonthlyPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MonthlyPerformance createManyAndReturn
   */
  export type MonthlyPerformanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyPerformance
     */
    select?: MonthlyPerformanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyPerformance
     */
    omit?: MonthlyPerformanceOmit<ExtArgs> | null
    /**
     * The data used to create many MonthlyPerformances.
     */
    data: MonthlyPerformanceCreateManyInput | MonthlyPerformanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyPerformanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MonthlyPerformance update
   */
  export type MonthlyPerformanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyPerformance
     */
    select?: MonthlyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyPerformance
     */
    omit?: MonthlyPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to update a MonthlyPerformance.
     */
    data: XOR<MonthlyPerformanceUpdateInput, MonthlyPerformanceUncheckedUpdateInput>
    /**
     * Choose, which MonthlyPerformance to update.
     */
    where: MonthlyPerformanceWhereUniqueInput
  }

  /**
   * MonthlyPerformance updateMany
   */
  export type MonthlyPerformanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MonthlyPerformances.
     */
    data: XOR<MonthlyPerformanceUpdateManyMutationInput, MonthlyPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which MonthlyPerformances to update
     */
    where?: MonthlyPerformanceWhereInput
    /**
     * Limit how many MonthlyPerformances to update.
     */
    limit?: number
  }

  /**
   * MonthlyPerformance updateManyAndReturn
   */
  export type MonthlyPerformanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyPerformance
     */
    select?: MonthlyPerformanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyPerformance
     */
    omit?: MonthlyPerformanceOmit<ExtArgs> | null
    /**
     * The data used to update MonthlyPerformances.
     */
    data: XOR<MonthlyPerformanceUpdateManyMutationInput, MonthlyPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which MonthlyPerformances to update
     */
    where?: MonthlyPerformanceWhereInput
    /**
     * Limit how many MonthlyPerformances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyPerformanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MonthlyPerformance upsert
   */
  export type MonthlyPerformanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyPerformance
     */
    select?: MonthlyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyPerformance
     */
    omit?: MonthlyPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyPerformanceInclude<ExtArgs> | null
    /**
     * The filter to search for the MonthlyPerformance to update in case it exists.
     */
    where: MonthlyPerformanceWhereUniqueInput
    /**
     * In case the MonthlyPerformance found by the `where` argument doesn't exist, create a new MonthlyPerformance with this data.
     */
    create: XOR<MonthlyPerformanceCreateInput, MonthlyPerformanceUncheckedCreateInput>
    /**
     * In case the MonthlyPerformance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MonthlyPerformanceUpdateInput, MonthlyPerformanceUncheckedUpdateInput>
  }

  /**
   * MonthlyPerformance delete
   */
  export type MonthlyPerformanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyPerformance
     */
    select?: MonthlyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyPerformance
     */
    omit?: MonthlyPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyPerformanceInclude<ExtArgs> | null
    /**
     * Filter which MonthlyPerformance to delete.
     */
    where: MonthlyPerformanceWhereUniqueInput
  }

  /**
   * MonthlyPerformance deleteMany
   */
  export type MonthlyPerformanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonthlyPerformances to delete
     */
    where?: MonthlyPerformanceWhereInput
    /**
     * Limit how many MonthlyPerformances to delete.
     */
    limit?: number
  }

  /**
   * MonthlyPerformance without action
   */
  export type MonthlyPerformanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyPerformance
     */
    select?: MonthlyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyPerformance
     */
    omit?: MonthlyPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyPerformanceInclude<ExtArgs> | null
  }


  /**
   * Model WeeklyWinRate
   */

  export type AggregateWeeklyWinRate = {
    _count: WeeklyWinRateCountAggregateOutputType | null
    _avg: WeeklyWinRateAvgAggregateOutputType | null
    _sum: WeeklyWinRateSumAggregateOutputType | null
    _min: WeeklyWinRateMinAggregateOutputType | null
    _max: WeeklyWinRateMaxAggregateOutputType | null
  }

  export type WeeklyWinRateAvgAggregateOutputType = {
    winRate: number | null
    totalTrades: number | null
  }

  export type WeeklyWinRateSumAggregateOutputType = {
    winRate: number | null
    totalTrades: number | null
  }

  export type WeeklyWinRateMinAggregateOutputType = {
    id: string | null
    userId: string | null
    week: string | null
    weekDate: Date | null
    winRate: number | null
    totalTrades: number | null
    createdAt: Date | null
  }

  export type WeeklyWinRateMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    week: string | null
    weekDate: Date | null
    winRate: number | null
    totalTrades: number | null
    createdAt: Date | null
  }

  export type WeeklyWinRateCountAggregateOutputType = {
    id: number
    userId: number
    week: number
    weekDate: number
    winRate: number
    totalTrades: number
    createdAt: number
    _all: number
  }


  export type WeeklyWinRateAvgAggregateInputType = {
    winRate?: true
    totalTrades?: true
  }

  export type WeeklyWinRateSumAggregateInputType = {
    winRate?: true
    totalTrades?: true
  }

  export type WeeklyWinRateMinAggregateInputType = {
    id?: true
    userId?: true
    week?: true
    weekDate?: true
    winRate?: true
    totalTrades?: true
    createdAt?: true
  }

  export type WeeklyWinRateMaxAggregateInputType = {
    id?: true
    userId?: true
    week?: true
    weekDate?: true
    winRate?: true
    totalTrades?: true
    createdAt?: true
  }

  export type WeeklyWinRateCountAggregateInputType = {
    id?: true
    userId?: true
    week?: true
    weekDate?: true
    winRate?: true
    totalTrades?: true
    createdAt?: true
    _all?: true
  }

  export type WeeklyWinRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeeklyWinRate to aggregate.
     */
    where?: WeeklyWinRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyWinRates to fetch.
     */
    orderBy?: WeeklyWinRateOrderByWithRelationInput | WeeklyWinRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeeklyWinRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyWinRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyWinRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeeklyWinRates
    **/
    _count?: true | WeeklyWinRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeeklyWinRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeeklyWinRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeeklyWinRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeeklyWinRateMaxAggregateInputType
  }

  export type GetWeeklyWinRateAggregateType<T extends WeeklyWinRateAggregateArgs> = {
        [P in keyof T & keyof AggregateWeeklyWinRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeeklyWinRate[P]>
      : GetScalarType<T[P], AggregateWeeklyWinRate[P]>
  }




  export type WeeklyWinRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyWinRateWhereInput
    orderBy?: WeeklyWinRateOrderByWithAggregationInput | WeeklyWinRateOrderByWithAggregationInput[]
    by: WeeklyWinRateScalarFieldEnum[] | WeeklyWinRateScalarFieldEnum
    having?: WeeklyWinRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeeklyWinRateCountAggregateInputType | true
    _avg?: WeeklyWinRateAvgAggregateInputType
    _sum?: WeeklyWinRateSumAggregateInputType
    _min?: WeeklyWinRateMinAggregateInputType
    _max?: WeeklyWinRateMaxAggregateInputType
  }

  export type WeeklyWinRateGroupByOutputType = {
    id: string
    userId: string
    week: string
    weekDate: Date
    winRate: number
    totalTrades: number
    createdAt: Date
    _count: WeeklyWinRateCountAggregateOutputType | null
    _avg: WeeklyWinRateAvgAggregateOutputType | null
    _sum: WeeklyWinRateSumAggregateOutputType | null
    _min: WeeklyWinRateMinAggregateOutputType | null
    _max: WeeklyWinRateMaxAggregateOutputType | null
  }

  type GetWeeklyWinRateGroupByPayload<T extends WeeklyWinRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeeklyWinRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeeklyWinRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeeklyWinRateGroupByOutputType[P]>
            : GetScalarType<T[P], WeeklyWinRateGroupByOutputType[P]>
        }
      >
    >


  export type WeeklyWinRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    week?: boolean
    weekDate?: boolean
    winRate?: boolean
    totalTrades?: boolean
    createdAt?: boolean
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklyWinRate"]>

  export type WeeklyWinRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    week?: boolean
    weekDate?: boolean
    winRate?: boolean
    totalTrades?: boolean
    createdAt?: boolean
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklyWinRate"]>

  export type WeeklyWinRateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    week?: boolean
    weekDate?: boolean
    winRate?: boolean
    totalTrades?: boolean
    createdAt?: boolean
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklyWinRate"]>

  export type WeeklyWinRateSelectScalar = {
    id?: boolean
    userId?: boolean
    week?: boolean
    weekDate?: boolean
    winRate?: boolean
    totalTrades?: boolean
    createdAt?: boolean
  }

  export type WeeklyWinRateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "week" | "weekDate" | "winRate" | "totalTrades" | "createdAt", ExtArgs["result"]["weeklyWinRate"]>
  export type WeeklyWinRateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }
  export type WeeklyWinRateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }
  export type WeeklyWinRateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAnalyticsDefaultArgs<ExtArgs>
  }

  export type $WeeklyWinRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeeklyWinRate"
    objects: {
      user: Prisma.$UserAnalyticsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      week: string
      weekDate: Date
      winRate: number
      totalTrades: number
      createdAt: Date
    }, ExtArgs["result"]["weeklyWinRate"]>
    composites: {}
  }

  type WeeklyWinRateGetPayload<S extends boolean | null | undefined | WeeklyWinRateDefaultArgs> = $Result.GetResult<Prisma.$WeeklyWinRatePayload, S>

  type WeeklyWinRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeeklyWinRateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeeklyWinRateCountAggregateInputType | true
    }

  export interface WeeklyWinRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeeklyWinRate'], meta: { name: 'WeeklyWinRate' } }
    /**
     * Find zero or one WeeklyWinRate that matches the filter.
     * @param {WeeklyWinRateFindUniqueArgs} args - Arguments to find a WeeklyWinRate
     * @example
     * // Get one WeeklyWinRate
     * const weeklyWinRate = await prisma.weeklyWinRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeeklyWinRateFindUniqueArgs>(args: SelectSubset<T, WeeklyWinRateFindUniqueArgs<ExtArgs>>): Prisma__WeeklyWinRateClient<$Result.GetResult<Prisma.$WeeklyWinRatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WeeklyWinRate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeeklyWinRateFindUniqueOrThrowArgs} args - Arguments to find a WeeklyWinRate
     * @example
     * // Get one WeeklyWinRate
     * const weeklyWinRate = await prisma.weeklyWinRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeeklyWinRateFindUniqueOrThrowArgs>(args: SelectSubset<T, WeeklyWinRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeeklyWinRateClient<$Result.GetResult<Prisma.$WeeklyWinRatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeeklyWinRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyWinRateFindFirstArgs} args - Arguments to find a WeeklyWinRate
     * @example
     * // Get one WeeklyWinRate
     * const weeklyWinRate = await prisma.weeklyWinRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeeklyWinRateFindFirstArgs>(args?: SelectSubset<T, WeeklyWinRateFindFirstArgs<ExtArgs>>): Prisma__WeeklyWinRateClient<$Result.GetResult<Prisma.$WeeklyWinRatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeeklyWinRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyWinRateFindFirstOrThrowArgs} args - Arguments to find a WeeklyWinRate
     * @example
     * // Get one WeeklyWinRate
     * const weeklyWinRate = await prisma.weeklyWinRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeeklyWinRateFindFirstOrThrowArgs>(args?: SelectSubset<T, WeeklyWinRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeeklyWinRateClient<$Result.GetResult<Prisma.$WeeklyWinRatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WeeklyWinRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyWinRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeeklyWinRates
     * const weeklyWinRates = await prisma.weeklyWinRate.findMany()
     * 
     * // Get first 10 WeeklyWinRates
     * const weeklyWinRates = await prisma.weeklyWinRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weeklyWinRateWithIdOnly = await prisma.weeklyWinRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeeklyWinRateFindManyArgs>(args?: SelectSubset<T, WeeklyWinRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyWinRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WeeklyWinRate.
     * @param {WeeklyWinRateCreateArgs} args - Arguments to create a WeeklyWinRate.
     * @example
     * // Create one WeeklyWinRate
     * const WeeklyWinRate = await prisma.weeklyWinRate.create({
     *   data: {
     *     // ... data to create a WeeklyWinRate
     *   }
     * })
     * 
     */
    create<T extends WeeklyWinRateCreateArgs>(args: SelectSubset<T, WeeklyWinRateCreateArgs<ExtArgs>>): Prisma__WeeklyWinRateClient<$Result.GetResult<Prisma.$WeeklyWinRatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WeeklyWinRates.
     * @param {WeeklyWinRateCreateManyArgs} args - Arguments to create many WeeklyWinRates.
     * @example
     * // Create many WeeklyWinRates
     * const weeklyWinRate = await prisma.weeklyWinRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeeklyWinRateCreateManyArgs>(args?: SelectSubset<T, WeeklyWinRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeeklyWinRates and returns the data saved in the database.
     * @param {WeeklyWinRateCreateManyAndReturnArgs} args - Arguments to create many WeeklyWinRates.
     * @example
     * // Create many WeeklyWinRates
     * const weeklyWinRate = await prisma.weeklyWinRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeeklyWinRates and only return the `id`
     * const weeklyWinRateWithIdOnly = await prisma.weeklyWinRate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeeklyWinRateCreateManyAndReturnArgs>(args?: SelectSubset<T, WeeklyWinRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyWinRatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WeeklyWinRate.
     * @param {WeeklyWinRateDeleteArgs} args - Arguments to delete one WeeklyWinRate.
     * @example
     * // Delete one WeeklyWinRate
     * const WeeklyWinRate = await prisma.weeklyWinRate.delete({
     *   where: {
     *     // ... filter to delete one WeeklyWinRate
     *   }
     * })
     * 
     */
    delete<T extends WeeklyWinRateDeleteArgs>(args: SelectSubset<T, WeeklyWinRateDeleteArgs<ExtArgs>>): Prisma__WeeklyWinRateClient<$Result.GetResult<Prisma.$WeeklyWinRatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WeeklyWinRate.
     * @param {WeeklyWinRateUpdateArgs} args - Arguments to update one WeeklyWinRate.
     * @example
     * // Update one WeeklyWinRate
     * const weeklyWinRate = await prisma.weeklyWinRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeeklyWinRateUpdateArgs>(args: SelectSubset<T, WeeklyWinRateUpdateArgs<ExtArgs>>): Prisma__WeeklyWinRateClient<$Result.GetResult<Prisma.$WeeklyWinRatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WeeklyWinRates.
     * @param {WeeklyWinRateDeleteManyArgs} args - Arguments to filter WeeklyWinRates to delete.
     * @example
     * // Delete a few WeeklyWinRates
     * const { count } = await prisma.weeklyWinRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeeklyWinRateDeleteManyArgs>(args?: SelectSubset<T, WeeklyWinRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeeklyWinRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyWinRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeeklyWinRates
     * const weeklyWinRate = await prisma.weeklyWinRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeeklyWinRateUpdateManyArgs>(args: SelectSubset<T, WeeklyWinRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeeklyWinRates and returns the data updated in the database.
     * @param {WeeklyWinRateUpdateManyAndReturnArgs} args - Arguments to update many WeeklyWinRates.
     * @example
     * // Update many WeeklyWinRates
     * const weeklyWinRate = await prisma.weeklyWinRate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WeeklyWinRates and only return the `id`
     * const weeklyWinRateWithIdOnly = await prisma.weeklyWinRate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeeklyWinRateUpdateManyAndReturnArgs>(args: SelectSubset<T, WeeklyWinRateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyWinRatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WeeklyWinRate.
     * @param {WeeklyWinRateUpsertArgs} args - Arguments to update or create a WeeklyWinRate.
     * @example
     * // Update or create a WeeklyWinRate
     * const weeklyWinRate = await prisma.weeklyWinRate.upsert({
     *   create: {
     *     // ... data to create a WeeklyWinRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeeklyWinRate we want to update
     *   }
     * })
     */
    upsert<T extends WeeklyWinRateUpsertArgs>(args: SelectSubset<T, WeeklyWinRateUpsertArgs<ExtArgs>>): Prisma__WeeklyWinRateClient<$Result.GetResult<Prisma.$WeeklyWinRatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WeeklyWinRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyWinRateCountArgs} args - Arguments to filter WeeklyWinRates to count.
     * @example
     * // Count the number of WeeklyWinRates
     * const count = await prisma.weeklyWinRate.count({
     *   where: {
     *     // ... the filter for the WeeklyWinRates we want to count
     *   }
     * })
    **/
    count<T extends WeeklyWinRateCountArgs>(
      args?: Subset<T, WeeklyWinRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeeklyWinRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeeklyWinRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyWinRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeeklyWinRateAggregateArgs>(args: Subset<T, WeeklyWinRateAggregateArgs>): Prisma.PrismaPromise<GetWeeklyWinRateAggregateType<T>>

    /**
     * Group by WeeklyWinRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyWinRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeeklyWinRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeeklyWinRateGroupByArgs['orderBy'] }
        : { orderBy?: WeeklyWinRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeeklyWinRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeeklyWinRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeeklyWinRate model
   */
  readonly fields: WeeklyWinRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeeklyWinRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeeklyWinRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserAnalyticsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserAnalyticsDefaultArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeeklyWinRate model
   */
  interface WeeklyWinRateFieldRefs {
    readonly id: FieldRef<"WeeklyWinRate", 'String'>
    readonly userId: FieldRef<"WeeklyWinRate", 'String'>
    readonly week: FieldRef<"WeeklyWinRate", 'String'>
    readonly weekDate: FieldRef<"WeeklyWinRate", 'DateTime'>
    readonly winRate: FieldRef<"WeeklyWinRate", 'Float'>
    readonly totalTrades: FieldRef<"WeeklyWinRate", 'Int'>
    readonly createdAt: FieldRef<"WeeklyWinRate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WeeklyWinRate findUnique
   */
  export type WeeklyWinRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyWinRate
     */
    select?: WeeklyWinRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyWinRate
     */
    omit?: WeeklyWinRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyWinRateInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyWinRate to fetch.
     */
    where: WeeklyWinRateWhereUniqueInput
  }

  /**
   * WeeklyWinRate findUniqueOrThrow
   */
  export type WeeklyWinRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyWinRate
     */
    select?: WeeklyWinRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyWinRate
     */
    omit?: WeeklyWinRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyWinRateInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyWinRate to fetch.
     */
    where: WeeklyWinRateWhereUniqueInput
  }

  /**
   * WeeklyWinRate findFirst
   */
  export type WeeklyWinRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyWinRate
     */
    select?: WeeklyWinRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyWinRate
     */
    omit?: WeeklyWinRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyWinRateInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyWinRate to fetch.
     */
    where?: WeeklyWinRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyWinRates to fetch.
     */
    orderBy?: WeeklyWinRateOrderByWithRelationInput | WeeklyWinRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeeklyWinRates.
     */
    cursor?: WeeklyWinRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyWinRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyWinRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeeklyWinRates.
     */
    distinct?: WeeklyWinRateScalarFieldEnum | WeeklyWinRateScalarFieldEnum[]
  }

  /**
   * WeeklyWinRate findFirstOrThrow
   */
  export type WeeklyWinRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyWinRate
     */
    select?: WeeklyWinRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyWinRate
     */
    omit?: WeeklyWinRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyWinRateInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyWinRate to fetch.
     */
    where?: WeeklyWinRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyWinRates to fetch.
     */
    orderBy?: WeeklyWinRateOrderByWithRelationInput | WeeklyWinRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeeklyWinRates.
     */
    cursor?: WeeklyWinRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyWinRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyWinRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeeklyWinRates.
     */
    distinct?: WeeklyWinRateScalarFieldEnum | WeeklyWinRateScalarFieldEnum[]
  }

  /**
   * WeeklyWinRate findMany
   */
  export type WeeklyWinRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyWinRate
     */
    select?: WeeklyWinRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyWinRate
     */
    omit?: WeeklyWinRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyWinRateInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyWinRates to fetch.
     */
    where?: WeeklyWinRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyWinRates to fetch.
     */
    orderBy?: WeeklyWinRateOrderByWithRelationInput | WeeklyWinRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeeklyWinRates.
     */
    cursor?: WeeklyWinRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyWinRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyWinRates.
     */
    skip?: number
    distinct?: WeeklyWinRateScalarFieldEnum | WeeklyWinRateScalarFieldEnum[]
  }

  /**
   * WeeklyWinRate create
   */
  export type WeeklyWinRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyWinRate
     */
    select?: WeeklyWinRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyWinRate
     */
    omit?: WeeklyWinRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyWinRateInclude<ExtArgs> | null
    /**
     * The data needed to create a WeeklyWinRate.
     */
    data: XOR<WeeklyWinRateCreateInput, WeeklyWinRateUncheckedCreateInput>
  }

  /**
   * WeeklyWinRate createMany
   */
  export type WeeklyWinRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeeklyWinRates.
     */
    data: WeeklyWinRateCreateManyInput | WeeklyWinRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeeklyWinRate createManyAndReturn
   */
  export type WeeklyWinRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyWinRate
     */
    select?: WeeklyWinRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyWinRate
     */
    omit?: WeeklyWinRateOmit<ExtArgs> | null
    /**
     * The data used to create many WeeklyWinRates.
     */
    data: WeeklyWinRateCreateManyInput | WeeklyWinRateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyWinRateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeeklyWinRate update
   */
  export type WeeklyWinRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyWinRate
     */
    select?: WeeklyWinRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyWinRate
     */
    omit?: WeeklyWinRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyWinRateInclude<ExtArgs> | null
    /**
     * The data needed to update a WeeklyWinRate.
     */
    data: XOR<WeeklyWinRateUpdateInput, WeeklyWinRateUncheckedUpdateInput>
    /**
     * Choose, which WeeklyWinRate to update.
     */
    where: WeeklyWinRateWhereUniqueInput
  }

  /**
   * WeeklyWinRate updateMany
   */
  export type WeeklyWinRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeeklyWinRates.
     */
    data: XOR<WeeklyWinRateUpdateManyMutationInput, WeeklyWinRateUncheckedUpdateManyInput>
    /**
     * Filter which WeeklyWinRates to update
     */
    where?: WeeklyWinRateWhereInput
    /**
     * Limit how many WeeklyWinRates to update.
     */
    limit?: number
  }

  /**
   * WeeklyWinRate updateManyAndReturn
   */
  export type WeeklyWinRateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyWinRate
     */
    select?: WeeklyWinRateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyWinRate
     */
    omit?: WeeklyWinRateOmit<ExtArgs> | null
    /**
     * The data used to update WeeklyWinRates.
     */
    data: XOR<WeeklyWinRateUpdateManyMutationInput, WeeklyWinRateUncheckedUpdateManyInput>
    /**
     * Filter which WeeklyWinRates to update
     */
    where?: WeeklyWinRateWhereInput
    /**
     * Limit how many WeeklyWinRates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyWinRateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeeklyWinRate upsert
   */
  export type WeeklyWinRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyWinRate
     */
    select?: WeeklyWinRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyWinRate
     */
    omit?: WeeklyWinRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyWinRateInclude<ExtArgs> | null
    /**
     * The filter to search for the WeeklyWinRate to update in case it exists.
     */
    where: WeeklyWinRateWhereUniqueInput
    /**
     * In case the WeeklyWinRate found by the `where` argument doesn't exist, create a new WeeklyWinRate with this data.
     */
    create: XOR<WeeklyWinRateCreateInput, WeeklyWinRateUncheckedCreateInput>
    /**
     * In case the WeeklyWinRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeeklyWinRateUpdateInput, WeeklyWinRateUncheckedUpdateInput>
  }

  /**
   * WeeklyWinRate delete
   */
  export type WeeklyWinRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyWinRate
     */
    select?: WeeklyWinRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyWinRate
     */
    omit?: WeeklyWinRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyWinRateInclude<ExtArgs> | null
    /**
     * Filter which WeeklyWinRate to delete.
     */
    where: WeeklyWinRateWhereUniqueInput
  }

  /**
   * WeeklyWinRate deleteMany
   */
  export type WeeklyWinRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeeklyWinRates to delete
     */
    where?: WeeklyWinRateWhereInput
    /**
     * Limit how many WeeklyWinRates to delete.
     */
    limit?: number
  }

  /**
   * WeeklyWinRate without action
   */
  export type WeeklyWinRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyWinRate
     */
    select?: WeeklyWinRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyWinRate
     */
    omit?: WeeklyWinRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyWinRateInclude<ExtArgs> | null
  }


  /**
   * Model BlogPost
   */

  export type AggregateBlogPost = {
    _count: BlogPostCountAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  export type BlogPostMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    description: string | null
    date: Date | null
    thumbnail: string | null
    featured: boolean | null
    readTime: string | null
    published: boolean | null
    authorUserId: string | null
    content: string | null
    tags: string | null
    author: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogPostMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    description: string | null
    date: Date | null
    thumbnail: string | null
    featured: boolean | null
    readTime: string | null
    published: boolean | null
    authorUserId: string | null
    content: string | null
    tags: string | null
    author: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogPostCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    description: number
    date: number
    tagsArray: number
    thumbnail: number
    featured: number
    readTime: number
    published: number
    authorUserId: number
    content: number
    tags: number
    author: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogPostMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    date?: true
    thumbnail?: true
    featured?: true
    readTime?: true
    published?: true
    authorUserId?: true
    content?: true
    tags?: true
    author?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogPostMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    date?: true
    thumbnail?: true
    featured?: true
    readTime?: true
    published?: true
    authorUserId?: true
    content?: true
    tags?: true
    author?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogPostCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    date?: true
    tagsArray?: true
    thumbnail?: true
    featured?: true
    readTime?: true
    published?: true
    authorUserId?: true
    content?: true
    tags?: true
    author?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPost to aggregate.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPosts
    **/
    _count?: true | BlogPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostMaxAggregateInputType
  }

  export type GetBlogPostAggregateType<T extends BlogPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPost[P]>
      : GetScalarType<T[P], AggregateBlogPost[P]>
  }




  export type BlogPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithAggregationInput | BlogPostOrderByWithAggregationInput[]
    by: BlogPostScalarFieldEnum[] | BlogPostScalarFieldEnum
    having?: BlogPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostCountAggregateInputType | true
    _min?: BlogPostMinAggregateInputType
    _max?: BlogPostMaxAggregateInputType
  }

  export type BlogPostGroupByOutputType = {
    id: string
    slug: string
    title: string
    description: string | null
    date: Date | null
    tagsArray: string[]
    thumbnail: string | null
    featured: boolean
    readTime: string | null
    published: boolean
    authorUserId: string | null
    content: string
    tags: string
    author: string | null
    createdAt: Date
    updatedAt: Date
    _count: BlogPostCountAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  type GetBlogPostGroupByPayload<T extends BlogPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    tagsArray?: boolean
    thumbnail?: boolean
    featured?: boolean
    readTime?: boolean
    published?: boolean
    authorUserId?: boolean
    content?: boolean
    tags?: boolean
    author?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorUser?: boolean | BlogPost$authorUserArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    tagsArray?: boolean
    thumbnail?: boolean
    featured?: boolean
    readTime?: boolean
    published?: boolean
    authorUserId?: boolean
    content?: boolean
    tags?: boolean
    author?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorUser?: boolean | BlogPost$authorUserArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    tagsArray?: boolean
    thumbnail?: boolean
    featured?: boolean
    readTime?: boolean
    published?: boolean
    authorUserId?: boolean
    content?: boolean
    tags?: boolean
    author?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorUser?: boolean | BlogPost$authorUserArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    tagsArray?: boolean
    thumbnail?: boolean
    featured?: boolean
    readTime?: boolean
    published?: boolean
    authorUserId?: boolean
    content?: boolean
    tags?: boolean
    author?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "title" | "description" | "date" | "tagsArray" | "thumbnail" | "featured" | "readTime" | "published" | "authorUserId" | "content" | "tags" | "author" | "createdAt" | "updatedAt", ExtArgs["result"]["blogPost"]>
  export type BlogPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authorUser?: boolean | BlogPost$authorUserArgs<ExtArgs>
  }
  export type BlogPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authorUser?: boolean | BlogPost$authorUserArgs<ExtArgs>
  }
  export type BlogPostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authorUser?: boolean | BlogPost$authorUserArgs<ExtArgs>
  }

  export type $BlogPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPost"
    objects: {
      authorUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
      description: string | null
      date: Date | null
      tagsArray: string[]
      thumbnail: string | null
      featured: boolean
      readTime: string | null
      published: boolean
      authorUserId: string | null
      content: string
      tags: string
      author: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blogPost"]>
    composites: {}
  }

  type BlogPostGetPayload<S extends boolean | null | undefined | BlogPostDefaultArgs> = $Result.GetResult<Prisma.$BlogPostPayload, S>

  type BlogPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogPostCountAggregateInputType | true
    }

  export interface BlogPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPost'], meta: { name: 'BlogPost' } }
    /**
     * Find zero or one BlogPost that matches the filter.
     * @param {BlogPostFindUniqueArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogPostFindUniqueArgs>(args: SelectSubset<T, BlogPostFindUniqueArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogPostFindUniqueOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogPostFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogPostFindFirstArgs>(args?: SelectSubset<T, BlogPostFindFirstArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogPostFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPosts
     * const blogPosts = await prisma.blogPost.findMany()
     * 
     * // Get first 10 BlogPosts
     * const blogPosts = await prisma.blogPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogPostFindManyArgs>(args?: SelectSubset<T, BlogPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogPost.
     * @param {BlogPostCreateArgs} args - Arguments to create a BlogPost.
     * @example
     * // Create one BlogPost
     * const BlogPost = await prisma.blogPost.create({
     *   data: {
     *     // ... data to create a BlogPost
     *   }
     * })
     * 
     */
    create<T extends BlogPostCreateArgs>(args: SelectSubset<T, BlogPostCreateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogPosts.
     * @param {BlogPostCreateManyArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogPostCreateManyArgs>(args?: SelectSubset<T, BlogPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogPosts and returns the data saved in the database.
     * @param {BlogPostCreateManyAndReturnArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogPostCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogPost.
     * @param {BlogPostDeleteArgs} args - Arguments to delete one BlogPost.
     * @example
     * // Delete one BlogPost
     * const BlogPost = await prisma.blogPost.delete({
     *   where: {
     *     // ... filter to delete one BlogPost
     *   }
     * })
     * 
     */
    delete<T extends BlogPostDeleteArgs>(args: SelectSubset<T, BlogPostDeleteArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogPost.
     * @param {BlogPostUpdateArgs} args - Arguments to update one BlogPost.
     * @example
     * // Update one BlogPost
     * const blogPost = await prisma.blogPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogPostUpdateArgs>(args: SelectSubset<T, BlogPostUpdateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogPosts.
     * @param {BlogPostDeleteManyArgs} args - Arguments to filter BlogPosts to delete.
     * @example
     * // Delete a few BlogPosts
     * const { count } = await prisma.blogPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogPostDeleteManyArgs>(args?: SelectSubset<T, BlogPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogPostUpdateManyArgs>(args: SelectSubset<T, BlogPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts and returns the data updated in the database.
     * @param {BlogPostUpdateManyAndReturnArgs} args - Arguments to update many BlogPosts.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogPostUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogPost.
     * @param {BlogPostUpsertArgs} args - Arguments to update or create a BlogPost.
     * @example
     * // Update or create a BlogPost
     * const blogPost = await prisma.blogPost.upsert({
     *   create: {
     *     // ... data to create a BlogPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPost we want to update
     *   }
     * })
     */
    upsert<T extends BlogPostUpsertArgs>(args: SelectSubset<T, BlogPostUpsertArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostCountArgs} args - Arguments to filter BlogPosts to count.
     * @example
     * // Count the number of BlogPosts
     * const count = await prisma.blogPost.count({
     *   where: {
     *     // ... the filter for the BlogPosts we want to count
     *   }
     * })
    **/
    count<T extends BlogPostCountArgs>(
      args?: Subset<T, BlogPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostAggregateArgs>(args: Subset<T, BlogPostAggregateArgs>): Prisma.PrismaPromise<GetBlogPostAggregateType<T>>

    /**
     * Group by BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPost model
   */
  readonly fields: BlogPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    authorUser<T extends BlogPost$authorUserArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$authorUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogPost model
   */
  interface BlogPostFieldRefs {
    readonly id: FieldRef<"BlogPost", 'String'>
    readonly slug: FieldRef<"BlogPost", 'String'>
    readonly title: FieldRef<"BlogPost", 'String'>
    readonly description: FieldRef<"BlogPost", 'String'>
    readonly date: FieldRef<"BlogPost", 'DateTime'>
    readonly tagsArray: FieldRef<"BlogPost", 'String[]'>
    readonly thumbnail: FieldRef<"BlogPost", 'String'>
    readonly featured: FieldRef<"BlogPost", 'Boolean'>
    readonly readTime: FieldRef<"BlogPost", 'String'>
    readonly published: FieldRef<"BlogPost", 'Boolean'>
    readonly authorUserId: FieldRef<"BlogPost", 'String'>
    readonly content: FieldRef<"BlogPost", 'String'>
    readonly tags: FieldRef<"BlogPost", 'String'>
    readonly author: FieldRef<"BlogPost", 'String'>
    readonly createdAt: FieldRef<"BlogPost", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogPost findUnique
   */
  export type BlogPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findUniqueOrThrow
   */
  export type BlogPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findFirst
   */
  export type BlogPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findFirstOrThrow
   */
  export type BlogPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findMany
   */
  export type BlogPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPosts to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost create
   */
  export type BlogPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPost.
     */
    data: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
  }

  /**
   * BlogPost createMany
   */
  export type BlogPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPost createManyAndReturn
   */
  export type BlogPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost update
   */
  export type BlogPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPost.
     */
    data: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
    /**
     * Choose, which BlogPost to update.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost updateMany
   */
  export type BlogPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to update.
     */
    limit?: number
  }

  /**
   * BlogPost updateManyAndReturn
   */
  export type BlogPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost upsert
   */
  export type BlogPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPost to update in case it exists.
     */
    where: BlogPostWhereUniqueInput
    /**
     * In case the BlogPost found by the `where` argument doesn't exist, create a new BlogPost with this data.
     */
    create: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
    /**
     * In case the BlogPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
  }

  /**
   * BlogPost delete
   */
  export type BlogPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter which BlogPost to delete.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost deleteMany
   */
  export type BlogPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPosts to delete
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to delete.
     */
    limit?: number
  }

  /**
   * BlogPost.authorUser
   */
  export type BlogPost$authorUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * BlogPost without action
   */
  export type BlogPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userEmail: string | null
    walletAddress: string | null
    tradeType: string | null
    amount: string | null
    market: string | null
    timestamp: Date | null
    read: boolean | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userEmail: string | null
    walletAddress: string | null
    tradeType: string | null
    amount: string | null
    market: string | null
    timestamp: Date | null
    read: boolean | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    userEmail: number
    walletAddress: number
    tradeType: number
    amount: number
    market: number
    timestamp: number
    read: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    walletAddress?: true
    tradeType?: true
    amount?: true
    market?: true
    timestamp?: true
    read?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    walletAddress?: true
    tradeType?: true
    amount?: true
    market?: true
    timestamp?: true
    read?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    walletAddress?: true
    tradeType?: true
    amount?: true
    market?: true
    timestamp?: true
    read?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    userEmail: string
    walletAddress: string
    tradeType: string
    amount: string
    market: string
    timestamp: Date
    read: boolean
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    walletAddress?: boolean
    tradeType?: boolean
    amount?: boolean
    market?: boolean
    timestamp?: boolean
    read?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    walletAddress?: boolean
    tradeType?: boolean
    amount?: boolean
    market?: boolean
    timestamp?: boolean
    read?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    walletAddress?: boolean
    tradeType?: boolean
    amount?: boolean
    market?: boolean
    timestamp?: boolean
    read?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    walletAddress?: boolean
    tradeType?: boolean
    amount?: boolean
    market?: boolean
    timestamp?: boolean
    read?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "userEmail" | "walletAddress" | "tradeType" | "amount" | "market" | "timestamp" | "read", ExtArgs["result"]["notification"]>

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      userEmail: string
      walletAddress: string
      tradeType: string
      amount: string
      market: string
      timestamp: Date
      read: boolean
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly userEmail: FieldRef<"Notification", 'String'>
    readonly walletAddress: FieldRef<"Notification", 'String'>
    readonly tradeType: FieldRef<"Notification", 'String'>
    readonly amount: FieldRef<"Notification", 'String'>
    readonly market: FieldRef<"Notification", 'String'>
    readonly timestamp: FieldRef<"Notification", 'DateTime'>
    readonly read: FieldRef<"Notification", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    password: 'password',
    verifyToken: 'verifyToken',
    verifyTokenExpiry: 'verifyTokenExpiry',
    walletAddress: 'walletAddress',
    clobApiKey: 'clobApiKey',
    clobSecret: 'clobSecret',
    clobPassphrase: 'clobPassphrase',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    accessToken: 'accessToken',
    telegramIntegrationId: 'telegramIntegrationId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    userId: 'userId',
    type: 'type',
    providerId: 'providerId',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    refreshToken: 'refreshToken',
    access_token: 'access_token',
    accessToken: 'accessToken',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    idToken: 'idToken',
    session_state: 'session_state',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sessionToken: 'sessionToken'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userEmail: 'userEmail',
    walletAddress: 'walletAddress',
    tradeType: 'tradeType',
    minAmount: 'minAmount',
    market: 'market',
    notifyVia: 'notifyVia',
    telegramNotify: 'telegramNotify',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const TelegramIntegrationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userName: 'userName',
    chatId: 'chatId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type TelegramIntegrationScalarFieldEnum = (typeof TelegramIntegrationScalarFieldEnum)[keyof typeof TelegramIntegrationScalarFieldEnum]


  export const MonitoredWalletScalarFieldEnum: {
    id: 'id',
    proxyWallet: 'proxyWallet',
    alertId: 'alertId',
    lastActivityTimestamp: 'lastActivityTimestamp',
    lastActivityHash: 'lastActivityHash',
    totalActivities: 'totalActivities',
    lastCheckedAt: 'lastCheckedAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MonitoredWalletScalarFieldEnum = (typeof MonitoredWalletScalarFieldEnum)[keyof typeof MonitoredWalletScalarFieldEnum]


  export const PolymarketActivityScalarFieldEnum: {
    id: 'id',
    proxyWallet: 'proxyWallet',
    timestamp: 'timestamp',
    conditionId: 'conditionId',
    type: 'type',
    size: 'size',
    usdcSize: 'usdcSize',
    transactionHash: 'transactionHash',
    price: 'price',
    asset: 'asset',
    side: 'side',
    outcomeIndex: 'outcomeIndex',
    title: 'title',
    slug: 'slug',
    icon: 'icon',
    eventSlug: 'eventSlug',
    outcome: 'outcome',
    processed: 'processed',
    notificationSent: 'notificationSent',
    createdAt: 'createdAt'
  };

  export type PolymarketActivityScalarFieldEnum = (typeof PolymarketActivityScalarFieldEnum)[keyof typeof PolymarketActivityScalarFieldEnum]


  export const MonitoringJobLogScalarFieldEnum: {
    id: 'id',
    jobType: 'jobType',
    status: 'status',
    walletsChecked: 'walletsChecked',
    activitiesFound: 'activitiesFound',
    activitiesProcessed: 'activitiesProcessed',
    notificationsQueued: 'notificationsQueued',
    duration: 'duration',
    error: 'error',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type MonitoringJobLogScalarFieldEnum = (typeof MonitoringJobLogScalarFieldEnum)[keyof typeof MonitoringJobLogScalarFieldEnum]


  export const NotificationQueueScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userEmail: 'userEmail',
    alertId: 'alertId',
    walletAddress: 'walletAddress',
    activityId: 'activityId',
    tradeType: 'tradeType',
    amount: 'amount',
    market: 'market',
    marketId: 'marketId',
    marketUrl: 'marketUrl',
    marketIcon: 'marketIcon',
    notifyVia: 'notifyVia',
    status: 'status',
    attempts: 'attempts',
    maxAttempts: 'maxAttempts',
    error: 'error',
    scheduledFor: 'scheduledFor',
    processedAt: 'processedAt',
    createdAt: 'createdAt'
  };

  export type NotificationQueueScalarFieldEnum = (typeof NotificationQueueScalarFieldEnum)[keyof typeof NotificationQueueScalarFieldEnum]


  export const NotificationLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userEmail: 'userEmail',
    alertId: 'alertId',
    walletAddress: 'walletAddress',
    activityId: 'activityId',
    tradeType: 'tradeType',
    amount: 'amount',
    market: 'market',
    notifyVia: 'notifyVia',
    status: 'status',
    error: 'error',
    sentAt: 'sentAt'
  };

  export type NotificationLogScalarFieldEnum = (typeof NotificationLogScalarFieldEnum)[keyof typeof NotificationLogScalarFieldEnum]


  export const CronJobLogScalarFieldEnum: {
    id: 'id',
    jobType: 'jobType',
    status: 'status',
    processed: 'processed',
    failed: 'failed',
    duration: 'duration',
    error: 'error',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type CronJobLogScalarFieldEnum = (typeof CronJobLogScalarFieldEnum)[keyof typeof CronJobLogScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    createdAt: 'createdAt',
    isFavorite: 'isFavorite',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    type: 'type',
    content: 'content',
    images: 'images',
    completed: 'completed',
    marketData: 'marketData',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const RulesConversationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    createdAt: 'createdAt',
    isFavorite: 'isFavorite',
    updatedAt: 'updatedAt'
  };

  export type RulesConversationScalarFieldEnum = (typeof RulesConversationScalarFieldEnum)[keyof typeof RulesConversationScalarFieldEnum]


  export const RulesMessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    type: 'type',
    content: 'content',
    images: 'images',
    completed: 'completed',
    marketData: 'marketData',
    createdAt: 'createdAt'
  };

  export type RulesMessageScalarFieldEnum = (typeof RulesMessageScalarFieldEnum)[keyof typeof RulesMessageScalarFieldEnum]


  export const WatchListScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    marketId: 'marketId',
    triggerType: 'triggerType',
    triggerValue: 'triggerValue',
    frequency: 'frequency',
    isActive: 'isActive',
    isEmailNotification: 'isEmailNotification',
    isTelegramNotification: 'isTelegramNotification',
    lastNotifiedAt: 'lastNotifiedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WatchListScalarFieldEnum = (typeof WatchListScalarFieldEnum)[keyof typeof WatchListScalarFieldEnum]


  export const MarketScalarFieldEnum: {
    id: 'id',
    conditionId: 'conditionId',
    marketId: 'marketId',
    question: 'question',
    slug: 'slug',
    liquidity: 'liquidity',
    volume: 'volume',
    volume24hr: 'volume24hr',
    active: 'active',
    closed: 'closed',
    archived: 'archived',
    image: 'image',
    category: 'category',
    tags: 'tags',
    outcomes: 'outcomes',
    outcomePrices: 'outcomePrices',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketScalarFieldEnum = (typeof MarketScalarFieldEnum)[keyof typeof MarketScalarFieldEnum]


  export const ProxyWalletScalarFieldEnum: {
    id: 'id',
    address: 'address',
    createdAt: 'createdAt'
  };

  export type ProxyWalletScalarFieldEnum = (typeof ProxyWalletScalarFieldEnum)[keyof typeof ProxyWalletScalarFieldEnum]


  export const SyncHistoryScalarFieldEnum: {
    id: 'id',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    marketsFound: 'marketsFound',
    marketsStored: 'marketsStored',
    marketsFailed: 'marketsFailed',
    walletsFound: 'walletsFound',
    walletsStored: 'walletsStored',
    status: 'status',
    error: 'error'
  };

  export type SyncHistoryScalarFieldEnum = (typeof SyncHistoryScalarFieldEnum)[keyof typeof SyncHistoryScalarFieldEnum]


  export const UserAnalyticsScalarFieldEnum: {
    id: 'id',
    address: 'address',
    totalVolume: 'totalVolume',
    totalProfit: 'totalProfit',
    positionValue: 'positionValue',
    totalTrades: 'totalTrades',
    totalPositions: 'totalPositions',
    averageWinRate: 'averageWinRate',
    avgMonthlyProfit: 'avgMonthlyProfit',
    avgMonthlyTrades: 'avgMonthlyTrades',
    mostTradedCategory: 'mostTradedCategory',
    tradingStyle: 'tradingStyle',
    riskProfile: 'riskProfile',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastSyncedAt: 'lastSyncedAt'
  };

  export type UserAnalyticsScalarFieldEnum = (typeof UserAnalyticsScalarFieldEnum)[keyof typeof UserAnalyticsScalarFieldEnum]


  export const MarketDistributionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    market: 'market',
    value: 'value',
    trades: 'trades',
    volume: 'volume',
    uniqueMarkets: 'uniqueMarkets',
    createdAt: 'createdAt'
  };

  export type MarketDistributionScalarFieldEnum = (typeof MarketDistributionScalarFieldEnum)[keyof typeof MarketDistributionScalarFieldEnum]


  export const BuySellDataScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    buyPercentage: 'buyPercentage',
    sellPercentage: 'sellPercentage',
    buyVolume: 'buyVolume',
    sellVolume: 'sellVolume',
    buyCount: 'buyCount',
    sellCount: 'sellCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BuySellDataScalarFieldEnum = (typeof BuySellDataScalarFieldEnum)[keyof typeof BuySellDataScalarFieldEnum]


  export const TradeSizeDataScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    averageSize: 'averageSize',
    medianSize: 'medianSize',
    minSize: 'minSize',
    maxSize: 'maxSize',
    smallTrades: 'smallTrades',
    mediumTrades: 'mediumTrades',
    largeTrades: 'largeTrades',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TradeSizeDataScalarFieldEnum = (typeof TradeSizeDataScalarFieldEnum)[keyof typeof TradeSizeDataScalarFieldEnum]


  export const PriceStatsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    averagePrice: 'averagePrice',
    minPrice: 'minPrice',
    maxPrice: 'maxPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PriceStatsScalarFieldEnum = (typeof PriceStatsScalarFieldEnum)[keyof typeof PriceStatsScalarFieldEnum]


  export const MonthlyPerformanceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    month: 'month',
    yearMonth: 'yearMonth',
    profit: 'profit',
    volume: 'volume',
    trades: 'trades',
    createdAt: 'createdAt'
  };

  export type MonthlyPerformanceScalarFieldEnum = (typeof MonthlyPerformanceScalarFieldEnum)[keyof typeof MonthlyPerformanceScalarFieldEnum]


  export const WeeklyWinRateScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    week: 'week',
    weekDate: 'weekDate',
    winRate: 'winRate',
    totalTrades: 'totalTrades',
    createdAt: 'createdAt'
  };

  export type WeeklyWinRateScalarFieldEnum = (typeof WeeklyWinRateScalarFieldEnum)[keyof typeof WeeklyWinRateScalarFieldEnum]


  export const BlogPostScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    description: 'description',
    date: 'date',
    tagsArray: 'tagsArray',
    thumbnail: 'thumbnail',
    featured: 'featured',
    readTime: 'readTime',
    published: 'published',
    authorUserId: 'authorUserId',
    content: 'content',
    tags: 'tags',
    author: 'author',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogPostScalarFieldEnum = (typeof BlogPostScalarFieldEnum)[keyof typeof BlogPostScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userEmail: 'userEmail',
    walletAddress: 'walletAddress',
    tradeType: 'tradeType',
    amount: 'amount',
    market: 'market',
    timestamp: 'timestamp',
    read: 'read'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


  /**
   * Reference to a field of type 'NotificationStatus[]'
   */
  export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'SyncStatus'
   */
  export type EnumSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncStatus'>
    


  /**
   * Reference to a field of type 'SyncStatus[]'
   */
  export type ListEnumSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: BoolNullableFilter<"User"> | boolean | null
    password?: StringNullableFilter<"User"> | string | null
    verifyToken?: StringNullableFilter<"User"> | string | null
    verifyTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    walletAddress?: StringNullableFilter<"User"> | string | null
    clobApiKey?: StringNullableFilter<"User"> | string | null
    clobSecret?: StringNullableFilter<"User"> | string | null
    clobPassphrase?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accessToken?: StringNullableFilter<"User"> | string | null
    telegramIntegrationId?: StringNullableFilter<"User"> | string | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    blogPost?: BlogPostListRelationFilter
    telegramIntegration?: XOR<TelegramIntegrationNullableScalarRelationFilter, TelegramIntegrationWhereInput> | null
    watchLists?: WatchListListRelationFilter
    conversations?: ConversationListRelationFilter
    rulesConversations?: RulesConversationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    verifyToken?: SortOrderInput | SortOrder
    verifyTokenExpiry?: SortOrderInput | SortOrder
    walletAddress?: SortOrderInput | SortOrder
    clobApiKey?: SortOrderInput | SortOrder
    clobSecret?: SortOrderInput | SortOrder
    clobPassphrase?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    telegramIntegrationId?: SortOrderInput | SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    blogPost?: BlogPostOrderByRelationAggregateInput
    telegramIntegration?: TelegramIntegrationOrderByWithRelationInput
    watchLists?: WatchListOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
    rulesConversations?: RulesConversationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    walletAddress?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolNullableFilter<"User"> | boolean | null
    password?: StringNullableFilter<"User"> | string | null
    verifyToken?: StringNullableFilter<"User"> | string | null
    verifyTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    clobApiKey?: StringNullableFilter<"User"> | string | null
    clobSecret?: StringNullableFilter<"User"> | string | null
    clobPassphrase?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accessToken?: StringNullableFilter<"User"> | string | null
    telegramIntegrationId?: StringNullableFilter<"User"> | string | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    blogPost?: BlogPostListRelationFilter
    telegramIntegration?: XOR<TelegramIntegrationNullableScalarRelationFilter, TelegramIntegrationWhereInput> | null
    watchLists?: WatchListListRelationFilter
    conversations?: ConversationListRelationFilter
    rulesConversations?: RulesConversationListRelationFilter
  }, "id" | "email" | "walletAddress">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    verifyToken?: SortOrderInput | SortOrder
    verifyTokenExpiry?: SortOrderInput | SortOrder
    walletAddress?: SortOrderInput | SortOrder
    clobApiKey?: SortOrderInput | SortOrder
    clobSecret?: SortOrderInput | SortOrder
    clobPassphrase?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    telegramIntegrationId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    verifyToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    verifyTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    walletAddress?: StringNullableWithAggregatesFilter<"User"> | string | null
    clobApiKey?: StringNullableWithAggregatesFilter<"User"> | string | null
    clobSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    clobPassphrase?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    accessToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    telegramIntegrationId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringNullableFilter<"Account"> | string | null
    userId?: StringFilter<"Account"> | string
    type?: StringNullableFilter<"Account"> | string | null
    providerId?: StringNullableFilter<"Account"> | string | null
    providerAccountId?: StringNullableFilter<"Account"> | string | null
    refresh_token?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    accessToken?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    sessionToken?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrderInput | SortOrder
    userId?: SortOrder
    type?: SortOrderInput | SortOrder
    providerId?: SortOrderInput | SortOrder
    providerAccountId?: SortOrderInput | SortOrder
    refresh_token?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    sessionToken?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    providerId_providerAccountId?: AccountProviderIdProviderAccountIdCompoundUniqueInput
    providerId_accountId?: AccountProviderIdAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringNullableFilter<"Account"> | string | null
    userId?: StringFilter<"Account"> | string
    type?: StringNullableFilter<"Account"> | string | null
    providerId?: StringNullableFilter<"Account"> | string | null
    providerAccountId?: StringNullableFilter<"Account"> | string | null
    refresh_token?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    accessToken?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    sessionToken?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "providerId_providerAccountId" | "providerId_accountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrderInput | SortOrder
    userId?: SortOrder
    type?: SortOrderInput | SortOrder
    providerId?: SortOrderInput | SortOrder
    providerAccountId?: SortOrderInput | SortOrder
    refresh_token?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    sessionToken?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringNullableWithAggregatesFilter<"Account"> | string | null
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    providerId?: StringNullableWithAggregatesFilter<"Account"> | string | null
    providerAccountId?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    sessionToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringNullableFilter<"Session"> | string | null
    token?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrderInput | SortOrder
    token?: SortOrderInput | SortOrder
    userId?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrderInput | SortOrder
    token?: SortOrderInput | SortOrder
    userId?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringNullableWithAggregatesFilter<"Session"> | string | null
    token?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userId?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    identifier_value?: VerificationIdentifierValueCompoundUniqueInput
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id" | "identifier_value">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type AlertWhereInput = {
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    id?: StringFilter<"Alert"> | string
    userId?: StringFilter<"Alert"> | string
    userEmail?: StringFilter<"Alert"> | string
    walletAddress?: StringFilter<"Alert"> | string
    tradeType?: StringFilter<"Alert"> | string
    minAmount?: StringNullableFilter<"Alert"> | string | null
    market?: StringFilter<"Alert"> | string
    notifyVia?: StringFilter<"Alert"> | string
    telegramNotify?: BoolFilter<"Alert"> | boolean
    isActive?: BoolFilter<"Alert"> | boolean
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    notifications?: NotificationLogListRelationFilter
    monitoredWallet?: XOR<MonitoredWalletNullableScalarRelationFilter, MonitoredWalletWhereInput> | null
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    walletAddress?: SortOrder
    tradeType?: SortOrder
    minAmount?: SortOrderInput | SortOrder
    market?: SortOrder
    notifyVia?: SortOrder
    telegramNotify?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notifications?: NotificationLogOrderByRelationAggregateInput
    monitoredWallet?: MonitoredWalletOrderByWithRelationInput
  }

  export type AlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    userId?: StringFilter<"Alert"> | string
    userEmail?: StringFilter<"Alert"> | string
    walletAddress?: StringFilter<"Alert"> | string
    tradeType?: StringFilter<"Alert"> | string
    minAmount?: StringNullableFilter<"Alert"> | string | null
    market?: StringFilter<"Alert"> | string
    notifyVia?: StringFilter<"Alert"> | string
    telegramNotify?: BoolFilter<"Alert"> | boolean
    isActive?: BoolFilter<"Alert"> | boolean
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    notifications?: NotificationLogListRelationFilter
    monitoredWallet?: XOR<MonitoredWalletNullableScalarRelationFilter, MonitoredWalletWhereInput> | null
  }, "id">

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    walletAddress?: SortOrder
    tradeType?: SortOrder
    minAmount?: SortOrderInput | SortOrder
    market?: SortOrder
    notifyVia?: SortOrder
    telegramNotify?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AlertCountOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    OR?: AlertScalarWhereWithAggregatesInput[]
    NOT?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alert"> | string
    userId?: StringWithAggregatesFilter<"Alert"> | string
    userEmail?: StringWithAggregatesFilter<"Alert"> | string
    walletAddress?: StringWithAggregatesFilter<"Alert"> | string
    tradeType?: StringWithAggregatesFilter<"Alert"> | string
    minAmount?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    market?: StringWithAggregatesFilter<"Alert"> | string
    notifyVia?: StringWithAggregatesFilter<"Alert"> | string
    telegramNotify?: BoolWithAggregatesFilter<"Alert"> | boolean
    isActive?: BoolWithAggregatesFilter<"Alert"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
  }

  export type TelegramIntegrationWhereInput = {
    AND?: TelegramIntegrationWhereInput | TelegramIntegrationWhereInput[]
    OR?: TelegramIntegrationWhereInput[]
    NOT?: TelegramIntegrationWhereInput | TelegramIntegrationWhereInput[]
    id?: StringFilter<"TelegramIntegration"> | string
    userId?: StringFilter<"TelegramIntegration"> | string
    userName?: StringFilter<"TelegramIntegration"> | string
    chatId?: StringFilter<"TelegramIntegration"> | string
    createdAt?: DateTimeFilter<"TelegramIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramIntegration"> | Date | string
    createdById?: StringFilter<"TelegramIntegration"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TelegramIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    chatId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
  }

  export type TelegramIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chatId?: string
    createdById?: string
    AND?: TelegramIntegrationWhereInput | TelegramIntegrationWhereInput[]
    OR?: TelegramIntegrationWhereInput[]
    NOT?: TelegramIntegrationWhereInput | TelegramIntegrationWhereInput[]
    userId?: StringFilter<"TelegramIntegration"> | string
    userName?: StringFilter<"TelegramIntegration"> | string
    createdAt?: DateTimeFilter<"TelegramIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramIntegration"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "chatId" | "createdById">

  export type TelegramIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    chatId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: TelegramIntegrationCountOrderByAggregateInput
    _max?: TelegramIntegrationMaxOrderByAggregateInput
    _min?: TelegramIntegrationMinOrderByAggregateInput
  }

  export type TelegramIntegrationScalarWhereWithAggregatesInput = {
    AND?: TelegramIntegrationScalarWhereWithAggregatesInput | TelegramIntegrationScalarWhereWithAggregatesInput[]
    OR?: TelegramIntegrationScalarWhereWithAggregatesInput[]
    NOT?: TelegramIntegrationScalarWhereWithAggregatesInput | TelegramIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TelegramIntegration"> | string
    userId?: StringWithAggregatesFilter<"TelegramIntegration"> | string
    userName?: StringWithAggregatesFilter<"TelegramIntegration"> | string
    chatId?: StringWithAggregatesFilter<"TelegramIntegration"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TelegramIntegration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TelegramIntegration"> | Date | string
    createdById?: StringWithAggregatesFilter<"TelegramIntegration"> | string
  }

  export type MonitoredWalletWhereInput = {
    AND?: MonitoredWalletWhereInput | MonitoredWalletWhereInput[]
    OR?: MonitoredWalletWhereInput[]
    NOT?: MonitoredWalletWhereInput | MonitoredWalletWhereInput[]
    id?: StringFilter<"MonitoredWallet"> | string
    proxyWallet?: StringFilter<"MonitoredWallet"> | string
    alertId?: StringFilter<"MonitoredWallet"> | string
    lastActivityTimestamp?: IntNullableFilter<"MonitoredWallet"> | number | null
    lastActivityHash?: StringNullableFilter<"MonitoredWallet"> | string | null
    totalActivities?: IntFilter<"MonitoredWallet"> | number
    lastCheckedAt?: DateTimeFilter<"MonitoredWallet"> | Date | string
    isActive?: BoolFilter<"MonitoredWallet"> | boolean
    createdAt?: DateTimeFilter<"MonitoredWallet"> | Date | string
    updatedAt?: DateTimeFilter<"MonitoredWallet"> | Date | string
    alert?: XOR<AlertScalarRelationFilter, AlertWhereInput>
  }

  export type MonitoredWalletOrderByWithRelationInput = {
    id?: SortOrder
    proxyWallet?: SortOrder
    alertId?: SortOrder
    lastActivityTimestamp?: SortOrderInput | SortOrder
    lastActivityHash?: SortOrderInput | SortOrder
    totalActivities?: SortOrder
    lastCheckedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    alert?: AlertOrderByWithRelationInput
  }

  export type MonitoredWalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    proxyWallet?: string
    alertId?: string
    AND?: MonitoredWalletWhereInput | MonitoredWalletWhereInput[]
    OR?: MonitoredWalletWhereInput[]
    NOT?: MonitoredWalletWhereInput | MonitoredWalletWhereInput[]
    lastActivityTimestamp?: IntNullableFilter<"MonitoredWallet"> | number | null
    lastActivityHash?: StringNullableFilter<"MonitoredWallet"> | string | null
    totalActivities?: IntFilter<"MonitoredWallet"> | number
    lastCheckedAt?: DateTimeFilter<"MonitoredWallet"> | Date | string
    isActive?: BoolFilter<"MonitoredWallet"> | boolean
    createdAt?: DateTimeFilter<"MonitoredWallet"> | Date | string
    updatedAt?: DateTimeFilter<"MonitoredWallet"> | Date | string
    alert?: XOR<AlertScalarRelationFilter, AlertWhereInput>
  }, "id" | "proxyWallet" | "alertId">

  export type MonitoredWalletOrderByWithAggregationInput = {
    id?: SortOrder
    proxyWallet?: SortOrder
    alertId?: SortOrder
    lastActivityTimestamp?: SortOrderInput | SortOrder
    lastActivityHash?: SortOrderInput | SortOrder
    totalActivities?: SortOrder
    lastCheckedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MonitoredWalletCountOrderByAggregateInput
    _avg?: MonitoredWalletAvgOrderByAggregateInput
    _max?: MonitoredWalletMaxOrderByAggregateInput
    _min?: MonitoredWalletMinOrderByAggregateInput
    _sum?: MonitoredWalletSumOrderByAggregateInput
  }

  export type MonitoredWalletScalarWhereWithAggregatesInput = {
    AND?: MonitoredWalletScalarWhereWithAggregatesInput | MonitoredWalletScalarWhereWithAggregatesInput[]
    OR?: MonitoredWalletScalarWhereWithAggregatesInput[]
    NOT?: MonitoredWalletScalarWhereWithAggregatesInput | MonitoredWalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MonitoredWallet"> | string
    proxyWallet?: StringWithAggregatesFilter<"MonitoredWallet"> | string
    alertId?: StringWithAggregatesFilter<"MonitoredWallet"> | string
    lastActivityTimestamp?: IntNullableWithAggregatesFilter<"MonitoredWallet"> | number | null
    lastActivityHash?: StringNullableWithAggregatesFilter<"MonitoredWallet"> | string | null
    totalActivities?: IntWithAggregatesFilter<"MonitoredWallet"> | number
    lastCheckedAt?: DateTimeWithAggregatesFilter<"MonitoredWallet"> | Date | string
    isActive?: BoolWithAggregatesFilter<"MonitoredWallet"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MonitoredWallet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MonitoredWallet"> | Date | string
  }

  export type PolymarketActivityWhereInput = {
    AND?: PolymarketActivityWhereInput | PolymarketActivityWhereInput[]
    OR?: PolymarketActivityWhereInput[]
    NOT?: PolymarketActivityWhereInput | PolymarketActivityWhereInput[]
    id?: StringFilter<"PolymarketActivity"> | string
    proxyWallet?: StringFilter<"PolymarketActivity"> | string
    timestamp?: IntFilter<"PolymarketActivity"> | number
    conditionId?: StringFilter<"PolymarketActivity"> | string
    type?: StringFilter<"PolymarketActivity"> | string
    size?: FloatFilter<"PolymarketActivity"> | number
    usdcSize?: FloatFilter<"PolymarketActivity"> | number
    transactionHash?: StringFilter<"PolymarketActivity"> | string
    price?: FloatNullableFilter<"PolymarketActivity"> | number | null
    asset?: StringNullableFilter<"PolymarketActivity"> | string | null
    side?: StringNullableFilter<"PolymarketActivity"> | string | null
    outcomeIndex?: IntNullableFilter<"PolymarketActivity"> | number | null
    title?: StringFilter<"PolymarketActivity"> | string
    slug?: StringFilter<"PolymarketActivity"> | string
    icon?: StringNullableFilter<"PolymarketActivity"> | string | null
    eventSlug?: StringNullableFilter<"PolymarketActivity"> | string | null
    outcome?: StringNullableFilter<"PolymarketActivity"> | string | null
    processed?: BoolFilter<"PolymarketActivity"> | boolean
    notificationSent?: BoolFilter<"PolymarketActivity"> | boolean
    createdAt?: DateTimeFilter<"PolymarketActivity"> | Date | string
  }

  export type PolymarketActivityOrderByWithRelationInput = {
    id?: SortOrder
    proxyWallet?: SortOrder
    timestamp?: SortOrder
    conditionId?: SortOrder
    type?: SortOrder
    size?: SortOrder
    usdcSize?: SortOrder
    transactionHash?: SortOrder
    price?: SortOrderInput | SortOrder
    asset?: SortOrderInput | SortOrder
    side?: SortOrderInput | SortOrder
    outcomeIndex?: SortOrderInput | SortOrder
    title?: SortOrder
    slug?: SortOrder
    icon?: SortOrderInput | SortOrder
    eventSlug?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    processed?: SortOrder
    notificationSent?: SortOrder
    createdAt?: SortOrder
  }

  export type PolymarketActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionHash?: string
    AND?: PolymarketActivityWhereInput | PolymarketActivityWhereInput[]
    OR?: PolymarketActivityWhereInput[]
    NOT?: PolymarketActivityWhereInput | PolymarketActivityWhereInput[]
    proxyWallet?: StringFilter<"PolymarketActivity"> | string
    timestamp?: IntFilter<"PolymarketActivity"> | number
    conditionId?: StringFilter<"PolymarketActivity"> | string
    type?: StringFilter<"PolymarketActivity"> | string
    size?: FloatFilter<"PolymarketActivity"> | number
    usdcSize?: FloatFilter<"PolymarketActivity"> | number
    price?: FloatNullableFilter<"PolymarketActivity"> | number | null
    asset?: StringNullableFilter<"PolymarketActivity"> | string | null
    side?: StringNullableFilter<"PolymarketActivity"> | string | null
    outcomeIndex?: IntNullableFilter<"PolymarketActivity"> | number | null
    title?: StringFilter<"PolymarketActivity"> | string
    slug?: StringFilter<"PolymarketActivity"> | string
    icon?: StringNullableFilter<"PolymarketActivity"> | string | null
    eventSlug?: StringNullableFilter<"PolymarketActivity"> | string | null
    outcome?: StringNullableFilter<"PolymarketActivity"> | string | null
    processed?: BoolFilter<"PolymarketActivity"> | boolean
    notificationSent?: BoolFilter<"PolymarketActivity"> | boolean
    createdAt?: DateTimeFilter<"PolymarketActivity"> | Date | string
  }, "id" | "transactionHash">

  export type PolymarketActivityOrderByWithAggregationInput = {
    id?: SortOrder
    proxyWallet?: SortOrder
    timestamp?: SortOrder
    conditionId?: SortOrder
    type?: SortOrder
    size?: SortOrder
    usdcSize?: SortOrder
    transactionHash?: SortOrder
    price?: SortOrderInput | SortOrder
    asset?: SortOrderInput | SortOrder
    side?: SortOrderInput | SortOrder
    outcomeIndex?: SortOrderInput | SortOrder
    title?: SortOrder
    slug?: SortOrder
    icon?: SortOrderInput | SortOrder
    eventSlug?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    processed?: SortOrder
    notificationSent?: SortOrder
    createdAt?: SortOrder
    _count?: PolymarketActivityCountOrderByAggregateInput
    _avg?: PolymarketActivityAvgOrderByAggregateInput
    _max?: PolymarketActivityMaxOrderByAggregateInput
    _min?: PolymarketActivityMinOrderByAggregateInput
    _sum?: PolymarketActivitySumOrderByAggregateInput
  }

  export type PolymarketActivityScalarWhereWithAggregatesInput = {
    AND?: PolymarketActivityScalarWhereWithAggregatesInput | PolymarketActivityScalarWhereWithAggregatesInput[]
    OR?: PolymarketActivityScalarWhereWithAggregatesInput[]
    NOT?: PolymarketActivityScalarWhereWithAggregatesInput | PolymarketActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PolymarketActivity"> | string
    proxyWallet?: StringWithAggregatesFilter<"PolymarketActivity"> | string
    timestamp?: IntWithAggregatesFilter<"PolymarketActivity"> | number
    conditionId?: StringWithAggregatesFilter<"PolymarketActivity"> | string
    type?: StringWithAggregatesFilter<"PolymarketActivity"> | string
    size?: FloatWithAggregatesFilter<"PolymarketActivity"> | number
    usdcSize?: FloatWithAggregatesFilter<"PolymarketActivity"> | number
    transactionHash?: StringWithAggregatesFilter<"PolymarketActivity"> | string
    price?: FloatNullableWithAggregatesFilter<"PolymarketActivity"> | number | null
    asset?: StringNullableWithAggregatesFilter<"PolymarketActivity"> | string | null
    side?: StringNullableWithAggregatesFilter<"PolymarketActivity"> | string | null
    outcomeIndex?: IntNullableWithAggregatesFilter<"PolymarketActivity"> | number | null
    title?: StringWithAggregatesFilter<"PolymarketActivity"> | string
    slug?: StringWithAggregatesFilter<"PolymarketActivity"> | string
    icon?: StringNullableWithAggregatesFilter<"PolymarketActivity"> | string | null
    eventSlug?: StringNullableWithAggregatesFilter<"PolymarketActivity"> | string | null
    outcome?: StringNullableWithAggregatesFilter<"PolymarketActivity"> | string | null
    processed?: BoolWithAggregatesFilter<"PolymarketActivity"> | boolean
    notificationSent?: BoolWithAggregatesFilter<"PolymarketActivity"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PolymarketActivity"> | Date | string
  }

  export type MonitoringJobLogWhereInput = {
    AND?: MonitoringJobLogWhereInput | MonitoringJobLogWhereInput[]
    OR?: MonitoringJobLogWhereInput[]
    NOT?: MonitoringJobLogWhereInput | MonitoringJobLogWhereInput[]
    id?: StringFilter<"MonitoringJobLog"> | string
    jobType?: StringFilter<"MonitoringJobLog"> | string
    status?: StringFilter<"MonitoringJobLog"> | string
    walletsChecked?: IntFilter<"MonitoringJobLog"> | number
    activitiesFound?: IntFilter<"MonitoringJobLog"> | number
    activitiesProcessed?: IntFilter<"MonitoringJobLog"> | number
    notificationsQueued?: IntFilter<"MonitoringJobLog"> | number
    duration?: IntNullableFilter<"MonitoringJobLog"> | number | null
    error?: StringNullableFilter<"MonitoringJobLog"> | string | null
    startedAt?: DateTimeFilter<"MonitoringJobLog"> | Date | string
    completedAt?: DateTimeNullableFilter<"MonitoringJobLog"> | Date | string | null
  }

  export type MonitoringJobLogOrderByWithRelationInput = {
    id?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    walletsChecked?: SortOrder
    activitiesFound?: SortOrder
    activitiesProcessed?: SortOrder
    notificationsQueued?: SortOrder
    duration?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
  }

  export type MonitoringJobLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MonitoringJobLogWhereInput | MonitoringJobLogWhereInput[]
    OR?: MonitoringJobLogWhereInput[]
    NOT?: MonitoringJobLogWhereInput | MonitoringJobLogWhereInput[]
    jobType?: StringFilter<"MonitoringJobLog"> | string
    status?: StringFilter<"MonitoringJobLog"> | string
    walletsChecked?: IntFilter<"MonitoringJobLog"> | number
    activitiesFound?: IntFilter<"MonitoringJobLog"> | number
    activitiesProcessed?: IntFilter<"MonitoringJobLog"> | number
    notificationsQueued?: IntFilter<"MonitoringJobLog"> | number
    duration?: IntNullableFilter<"MonitoringJobLog"> | number | null
    error?: StringNullableFilter<"MonitoringJobLog"> | string | null
    startedAt?: DateTimeFilter<"MonitoringJobLog"> | Date | string
    completedAt?: DateTimeNullableFilter<"MonitoringJobLog"> | Date | string | null
  }, "id">

  export type MonitoringJobLogOrderByWithAggregationInput = {
    id?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    walletsChecked?: SortOrder
    activitiesFound?: SortOrder
    activitiesProcessed?: SortOrder
    notificationsQueued?: SortOrder
    duration?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: MonitoringJobLogCountOrderByAggregateInput
    _avg?: MonitoringJobLogAvgOrderByAggregateInput
    _max?: MonitoringJobLogMaxOrderByAggregateInput
    _min?: MonitoringJobLogMinOrderByAggregateInput
    _sum?: MonitoringJobLogSumOrderByAggregateInput
  }

  export type MonitoringJobLogScalarWhereWithAggregatesInput = {
    AND?: MonitoringJobLogScalarWhereWithAggregatesInput | MonitoringJobLogScalarWhereWithAggregatesInput[]
    OR?: MonitoringJobLogScalarWhereWithAggregatesInput[]
    NOT?: MonitoringJobLogScalarWhereWithAggregatesInput | MonitoringJobLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MonitoringJobLog"> | string
    jobType?: StringWithAggregatesFilter<"MonitoringJobLog"> | string
    status?: StringWithAggregatesFilter<"MonitoringJobLog"> | string
    walletsChecked?: IntWithAggregatesFilter<"MonitoringJobLog"> | number
    activitiesFound?: IntWithAggregatesFilter<"MonitoringJobLog"> | number
    activitiesProcessed?: IntWithAggregatesFilter<"MonitoringJobLog"> | number
    notificationsQueued?: IntWithAggregatesFilter<"MonitoringJobLog"> | number
    duration?: IntNullableWithAggregatesFilter<"MonitoringJobLog"> | number | null
    error?: StringNullableWithAggregatesFilter<"MonitoringJobLog"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"MonitoringJobLog"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"MonitoringJobLog"> | Date | string | null
  }

  export type NotificationQueueWhereInput = {
    AND?: NotificationQueueWhereInput | NotificationQueueWhereInput[]
    OR?: NotificationQueueWhereInput[]
    NOT?: NotificationQueueWhereInput | NotificationQueueWhereInput[]
    id?: StringFilter<"NotificationQueue"> | string
    userId?: StringFilter<"NotificationQueue"> | string
    userEmail?: StringFilter<"NotificationQueue"> | string
    alertId?: StringFilter<"NotificationQueue"> | string
    walletAddress?: StringFilter<"NotificationQueue"> | string
    activityId?: StringNullableFilter<"NotificationQueue"> | string | null
    tradeType?: StringFilter<"NotificationQueue"> | string
    amount?: StringFilter<"NotificationQueue"> | string
    market?: StringFilter<"NotificationQueue"> | string
    marketId?: StringNullableFilter<"NotificationQueue"> | string | null
    marketUrl?: StringNullableFilter<"NotificationQueue"> | string | null
    marketIcon?: StringNullableFilter<"NotificationQueue"> | string | null
    notifyVia?: StringFilter<"NotificationQueue"> | string
    status?: EnumNotificationStatusFilter<"NotificationQueue"> | $Enums.NotificationStatus
    attempts?: IntFilter<"NotificationQueue"> | number
    maxAttempts?: IntFilter<"NotificationQueue"> | number
    error?: StringNullableFilter<"NotificationQueue"> | string | null
    scheduledFor?: DateTimeFilter<"NotificationQueue"> | Date | string
    processedAt?: DateTimeNullableFilter<"NotificationQueue"> | Date | string | null
    createdAt?: DateTimeFilter<"NotificationQueue"> | Date | string
  }

  export type NotificationQueueOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    alertId?: SortOrder
    walletAddress?: SortOrder
    activityId?: SortOrderInput | SortOrder
    tradeType?: SortOrder
    amount?: SortOrder
    market?: SortOrder
    marketId?: SortOrderInput | SortOrder
    marketUrl?: SortOrderInput | SortOrder
    marketIcon?: SortOrderInput | SortOrder
    notifyVia?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    error?: SortOrderInput | SortOrder
    scheduledFor?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type NotificationQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationQueueWhereInput | NotificationQueueWhereInput[]
    OR?: NotificationQueueWhereInput[]
    NOT?: NotificationQueueWhereInput | NotificationQueueWhereInput[]
    userId?: StringFilter<"NotificationQueue"> | string
    userEmail?: StringFilter<"NotificationQueue"> | string
    alertId?: StringFilter<"NotificationQueue"> | string
    walletAddress?: StringFilter<"NotificationQueue"> | string
    activityId?: StringNullableFilter<"NotificationQueue"> | string | null
    tradeType?: StringFilter<"NotificationQueue"> | string
    amount?: StringFilter<"NotificationQueue"> | string
    market?: StringFilter<"NotificationQueue"> | string
    marketId?: StringNullableFilter<"NotificationQueue"> | string | null
    marketUrl?: StringNullableFilter<"NotificationQueue"> | string | null
    marketIcon?: StringNullableFilter<"NotificationQueue"> | string | null
    notifyVia?: StringFilter<"NotificationQueue"> | string
    status?: EnumNotificationStatusFilter<"NotificationQueue"> | $Enums.NotificationStatus
    attempts?: IntFilter<"NotificationQueue"> | number
    maxAttempts?: IntFilter<"NotificationQueue"> | number
    error?: StringNullableFilter<"NotificationQueue"> | string | null
    scheduledFor?: DateTimeFilter<"NotificationQueue"> | Date | string
    processedAt?: DateTimeNullableFilter<"NotificationQueue"> | Date | string | null
    createdAt?: DateTimeFilter<"NotificationQueue"> | Date | string
  }, "id">

  export type NotificationQueueOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    alertId?: SortOrder
    walletAddress?: SortOrder
    activityId?: SortOrderInput | SortOrder
    tradeType?: SortOrder
    amount?: SortOrder
    market?: SortOrder
    marketId?: SortOrderInput | SortOrder
    marketUrl?: SortOrderInput | SortOrder
    marketIcon?: SortOrderInput | SortOrder
    notifyVia?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    error?: SortOrderInput | SortOrder
    scheduledFor?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationQueueCountOrderByAggregateInput
    _avg?: NotificationQueueAvgOrderByAggregateInput
    _max?: NotificationQueueMaxOrderByAggregateInput
    _min?: NotificationQueueMinOrderByAggregateInput
    _sum?: NotificationQueueSumOrderByAggregateInput
  }

  export type NotificationQueueScalarWhereWithAggregatesInput = {
    AND?: NotificationQueueScalarWhereWithAggregatesInput | NotificationQueueScalarWhereWithAggregatesInput[]
    OR?: NotificationQueueScalarWhereWithAggregatesInput[]
    NOT?: NotificationQueueScalarWhereWithAggregatesInput | NotificationQueueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationQueue"> | string
    userId?: StringWithAggregatesFilter<"NotificationQueue"> | string
    userEmail?: StringWithAggregatesFilter<"NotificationQueue"> | string
    alertId?: StringWithAggregatesFilter<"NotificationQueue"> | string
    walletAddress?: StringWithAggregatesFilter<"NotificationQueue"> | string
    activityId?: StringNullableWithAggregatesFilter<"NotificationQueue"> | string | null
    tradeType?: StringWithAggregatesFilter<"NotificationQueue"> | string
    amount?: StringWithAggregatesFilter<"NotificationQueue"> | string
    market?: StringWithAggregatesFilter<"NotificationQueue"> | string
    marketId?: StringNullableWithAggregatesFilter<"NotificationQueue"> | string | null
    marketUrl?: StringNullableWithAggregatesFilter<"NotificationQueue"> | string | null
    marketIcon?: StringNullableWithAggregatesFilter<"NotificationQueue"> | string | null
    notifyVia?: StringWithAggregatesFilter<"NotificationQueue"> | string
    status?: EnumNotificationStatusWithAggregatesFilter<"NotificationQueue"> | $Enums.NotificationStatus
    attempts?: IntWithAggregatesFilter<"NotificationQueue"> | number
    maxAttempts?: IntWithAggregatesFilter<"NotificationQueue"> | number
    error?: StringNullableWithAggregatesFilter<"NotificationQueue"> | string | null
    scheduledFor?: DateTimeWithAggregatesFilter<"NotificationQueue"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"NotificationQueue"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NotificationQueue"> | Date | string
  }

  export type NotificationLogWhereInput = {
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    id?: StringFilter<"NotificationLog"> | string
    userId?: StringFilter<"NotificationLog"> | string
    userEmail?: StringFilter<"NotificationLog"> | string
    alertId?: StringFilter<"NotificationLog"> | string
    walletAddress?: StringFilter<"NotificationLog"> | string
    activityId?: StringNullableFilter<"NotificationLog"> | string | null
    tradeType?: StringFilter<"NotificationLog"> | string
    amount?: StringFilter<"NotificationLog"> | string
    market?: StringFilter<"NotificationLog"> | string
    notifyVia?: StringFilter<"NotificationLog"> | string
    status?: StringFilter<"NotificationLog"> | string
    error?: StringNullableFilter<"NotificationLog"> | string | null
    sentAt?: DateTimeFilter<"NotificationLog"> | Date | string
    alert?: XOR<AlertScalarRelationFilter, AlertWhereInput>
  }

  export type NotificationLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    alertId?: SortOrder
    walletAddress?: SortOrder
    activityId?: SortOrderInput | SortOrder
    tradeType?: SortOrder
    amount?: SortOrder
    market?: SortOrder
    notifyVia?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    sentAt?: SortOrder
    alert?: AlertOrderByWithRelationInput
  }

  export type NotificationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    userId?: StringFilter<"NotificationLog"> | string
    userEmail?: StringFilter<"NotificationLog"> | string
    alertId?: StringFilter<"NotificationLog"> | string
    walletAddress?: StringFilter<"NotificationLog"> | string
    activityId?: StringNullableFilter<"NotificationLog"> | string | null
    tradeType?: StringFilter<"NotificationLog"> | string
    amount?: StringFilter<"NotificationLog"> | string
    market?: StringFilter<"NotificationLog"> | string
    notifyVia?: StringFilter<"NotificationLog"> | string
    status?: StringFilter<"NotificationLog"> | string
    error?: StringNullableFilter<"NotificationLog"> | string | null
    sentAt?: DateTimeFilter<"NotificationLog"> | Date | string
    alert?: XOR<AlertScalarRelationFilter, AlertWhereInput>
  }, "id">

  export type NotificationLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    alertId?: SortOrder
    walletAddress?: SortOrder
    activityId?: SortOrderInput | SortOrder
    tradeType?: SortOrder
    amount?: SortOrder
    market?: SortOrder
    notifyVia?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    sentAt?: SortOrder
    _count?: NotificationLogCountOrderByAggregateInput
    _max?: NotificationLogMaxOrderByAggregateInput
    _min?: NotificationLogMinOrderByAggregateInput
  }

  export type NotificationLogScalarWhereWithAggregatesInput = {
    AND?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    OR?: NotificationLogScalarWhereWithAggregatesInput[]
    NOT?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationLog"> | string
    userId?: StringWithAggregatesFilter<"NotificationLog"> | string
    userEmail?: StringWithAggregatesFilter<"NotificationLog"> | string
    alertId?: StringWithAggregatesFilter<"NotificationLog"> | string
    walletAddress?: StringWithAggregatesFilter<"NotificationLog"> | string
    activityId?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    tradeType?: StringWithAggregatesFilter<"NotificationLog"> | string
    amount?: StringWithAggregatesFilter<"NotificationLog"> | string
    market?: StringWithAggregatesFilter<"NotificationLog"> | string
    notifyVia?: StringWithAggregatesFilter<"NotificationLog"> | string
    status?: StringWithAggregatesFilter<"NotificationLog"> | string
    error?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    sentAt?: DateTimeWithAggregatesFilter<"NotificationLog"> | Date | string
  }

  export type CronJobLogWhereInput = {
    AND?: CronJobLogWhereInput | CronJobLogWhereInput[]
    OR?: CronJobLogWhereInput[]
    NOT?: CronJobLogWhereInput | CronJobLogWhereInput[]
    id?: StringFilter<"CronJobLog"> | string
    jobType?: StringFilter<"CronJobLog"> | string
    status?: StringFilter<"CronJobLog"> | string
    processed?: IntFilter<"CronJobLog"> | number
    failed?: IntFilter<"CronJobLog"> | number
    duration?: IntNullableFilter<"CronJobLog"> | number | null
    error?: StringNullableFilter<"CronJobLog"> | string | null
    startedAt?: DateTimeFilter<"CronJobLog"> | Date | string
    completedAt?: DateTimeNullableFilter<"CronJobLog"> | Date | string | null
  }

  export type CronJobLogOrderByWithRelationInput = {
    id?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    processed?: SortOrder
    failed?: SortOrder
    duration?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
  }

  export type CronJobLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CronJobLogWhereInput | CronJobLogWhereInput[]
    OR?: CronJobLogWhereInput[]
    NOT?: CronJobLogWhereInput | CronJobLogWhereInput[]
    jobType?: StringFilter<"CronJobLog"> | string
    status?: StringFilter<"CronJobLog"> | string
    processed?: IntFilter<"CronJobLog"> | number
    failed?: IntFilter<"CronJobLog"> | number
    duration?: IntNullableFilter<"CronJobLog"> | number | null
    error?: StringNullableFilter<"CronJobLog"> | string | null
    startedAt?: DateTimeFilter<"CronJobLog"> | Date | string
    completedAt?: DateTimeNullableFilter<"CronJobLog"> | Date | string | null
  }, "id">

  export type CronJobLogOrderByWithAggregationInput = {
    id?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    processed?: SortOrder
    failed?: SortOrder
    duration?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: CronJobLogCountOrderByAggregateInput
    _avg?: CronJobLogAvgOrderByAggregateInput
    _max?: CronJobLogMaxOrderByAggregateInput
    _min?: CronJobLogMinOrderByAggregateInput
    _sum?: CronJobLogSumOrderByAggregateInput
  }

  export type CronJobLogScalarWhereWithAggregatesInput = {
    AND?: CronJobLogScalarWhereWithAggregatesInput | CronJobLogScalarWhereWithAggregatesInput[]
    OR?: CronJobLogScalarWhereWithAggregatesInput[]
    NOT?: CronJobLogScalarWhereWithAggregatesInput | CronJobLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CronJobLog"> | string
    jobType?: StringWithAggregatesFilter<"CronJobLog"> | string
    status?: StringWithAggregatesFilter<"CronJobLog"> | string
    processed?: IntWithAggregatesFilter<"CronJobLog"> | number
    failed?: IntWithAggregatesFilter<"CronJobLog"> | number
    duration?: IntNullableWithAggregatesFilter<"CronJobLog"> | number | null
    error?: StringNullableWithAggregatesFilter<"CronJobLog"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"CronJobLog"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"CronJobLog"> | Date | string | null
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    userId?: StringFilter<"Conversation"> | string
    title?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    isFavorite?: BoolFilter<"Conversation"> | boolean
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    isFavorite?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    userId?: StringFilter<"Conversation"> | string
    title?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    isFavorite?: BoolFilter<"Conversation"> | boolean
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    isFavorite?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    userId?: StringWithAggregatesFilter<"Conversation"> | string
    title?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    isFavorite?: BoolWithAggregatesFilter<"Conversation"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    type?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    images?: StringNullableListFilter<"Message">
    completed?: BoolFilter<"Message"> | boolean
    marketData?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    images?: SortOrder
    completed?: SortOrder
    marketData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: StringFilter<"Message"> | string
    type?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    images?: StringNullableListFilter<"Message">
    completed?: BoolFilter<"Message"> | boolean
    marketData?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    images?: SortOrder
    completed?: SortOrder
    marketData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    type?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    images?: StringNullableListFilter<"Message">
    completed?: BoolWithAggregatesFilter<"Message"> | boolean
    marketData?: JsonNullableWithAggregatesFilter<"Message">
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type RulesConversationWhereInput = {
    AND?: RulesConversationWhereInput | RulesConversationWhereInput[]
    OR?: RulesConversationWhereInput[]
    NOT?: RulesConversationWhereInput | RulesConversationWhereInput[]
    id?: StringFilter<"RulesConversation"> | string
    userId?: StringFilter<"RulesConversation"> | string
    title?: StringNullableFilter<"RulesConversation"> | string | null
    createdAt?: DateTimeFilter<"RulesConversation"> | Date | string
    isFavorite?: BoolFilter<"RulesConversation"> | boolean
    updatedAt?: DateTimeFilter<"RulesConversation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: RulesMessageListRelationFilter
  }

  export type RulesConversationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    isFavorite?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    messages?: RulesMessageOrderByRelationAggregateInput
  }

  export type RulesConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RulesConversationWhereInput | RulesConversationWhereInput[]
    OR?: RulesConversationWhereInput[]
    NOT?: RulesConversationWhereInput | RulesConversationWhereInput[]
    userId?: StringFilter<"RulesConversation"> | string
    title?: StringNullableFilter<"RulesConversation"> | string | null
    createdAt?: DateTimeFilter<"RulesConversation"> | Date | string
    isFavorite?: BoolFilter<"RulesConversation"> | boolean
    updatedAt?: DateTimeFilter<"RulesConversation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: RulesMessageListRelationFilter
  }, "id">

  export type RulesConversationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    isFavorite?: SortOrder
    updatedAt?: SortOrder
    _count?: RulesConversationCountOrderByAggregateInput
    _max?: RulesConversationMaxOrderByAggregateInput
    _min?: RulesConversationMinOrderByAggregateInput
  }

  export type RulesConversationScalarWhereWithAggregatesInput = {
    AND?: RulesConversationScalarWhereWithAggregatesInput | RulesConversationScalarWhereWithAggregatesInput[]
    OR?: RulesConversationScalarWhereWithAggregatesInput[]
    NOT?: RulesConversationScalarWhereWithAggregatesInput | RulesConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RulesConversation"> | string
    userId?: StringWithAggregatesFilter<"RulesConversation"> | string
    title?: StringNullableWithAggregatesFilter<"RulesConversation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RulesConversation"> | Date | string
    isFavorite?: BoolWithAggregatesFilter<"RulesConversation"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"RulesConversation"> | Date | string
  }

  export type RulesMessageWhereInput = {
    AND?: RulesMessageWhereInput | RulesMessageWhereInput[]
    OR?: RulesMessageWhereInput[]
    NOT?: RulesMessageWhereInput | RulesMessageWhereInput[]
    id?: StringFilter<"RulesMessage"> | string
    conversationId?: StringFilter<"RulesMessage"> | string
    type?: StringFilter<"RulesMessage"> | string
    content?: StringFilter<"RulesMessage"> | string
    images?: StringNullableListFilter<"RulesMessage">
    completed?: BoolFilter<"RulesMessage"> | boolean
    marketData?: JsonNullableFilter<"RulesMessage">
    createdAt?: DateTimeFilter<"RulesMessage"> | Date | string
    conversation?: XOR<RulesConversationScalarRelationFilter, RulesConversationWhereInput>
  }

  export type RulesMessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    images?: SortOrder
    completed?: SortOrder
    marketData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    conversation?: RulesConversationOrderByWithRelationInput
  }

  export type RulesMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RulesMessageWhereInput | RulesMessageWhereInput[]
    OR?: RulesMessageWhereInput[]
    NOT?: RulesMessageWhereInput | RulesMessageWhereInput[]
    conversationId?: StringFilter<"RulesMessage"> | string
    type?: StringFilter<"RulesMessage"> | string
    content?: StringFilter<"RulesMessage"> | string
    images?: StringNullableListFilter<"RulesMessage">
    completed?: BoolFilter<"RulesMessage"> | boolean
    marketData?: JsonNullableFilter<"RulesMessage">
    createdAt?: DateTimeFilter<"RulesMessage"> | Date | string
    conversation?: XOR<RulesConversationScalarRelationFilter, RulesConversationWhereInput>
  }, "id">

  export type RulesMessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    images?: SortOrder
    completed?: SortOrder
    marketData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RulesMessageCountOrderByAggregateInput
    _max?: RulesMessageMaxOrderByAggregateInput
    _min?: RulesMessageMinOrderByAggregateInput
  }

  export type RulesMessageScalarWhereWithAggregatesInput = {
    AND?: RulesMessageScalarWhereWithAggregatesInput | RulesMessageScalarWhereWithAggregatesInput[]
    OR?: RulesMessageScalarWhereWithAggregatesInput[]
    NOT?: RulesMessageScalarWhereWithAggregatesInput | RulesMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RulesMessage"> | string
    conversationId?: StringWithAggregatesFilter<"RulesMessage"> | string
    type?: StringWithAggregatesFilter<"RulesMessage"> | string
    content?: StringWithAggregatesFilter<"RulesMessage"> | string
    images?: StringNullableListFilter<"RulesMessage">
    completed?: BoolWithAggregatesFilter<"RulesMessage"> | boolean
    marketData?: JsonNullableWithAggregatesFilter<"RulesMessage">
    createdAt?: DateTimeWithAggregatesFilter<"RulesMessage"> | Date | string
  }

  export type WatchListWhereInput = {
    AND?: WatchListWhereInput | WatchListWhereInput[]
    OR?: WatchListWhereInput[]
    NOT?: WatchListWhereInput | WatchListWhereInput[]
    id?: StringFilter<"WatchList"> | string
    userId?: StringFilter<"WatchList"> | string
    marketId?: StringFilter<"WatchList"> | string
    triggerType?: StringFilter<"WatchList"> | string
    triggerValue?: FloatNullableFilter<"WatchList"> | number | null
    frequency?: StringFilter<"WatchList"> | string
    isActive?: BoolFilter<"WatchList"> | boolean
    isEmailNotification?: BoolFilter<"WatchList"> | boolean
    isTelegramNotification?: BoolFilter<"WatchList"> | boolean
    lastNotifiedAt?: DateTimeNullableFilter<"WatchList"> | Date | string | null
    createdAt?: DateTimeFilter<"WatchList"> | Date | string
    updatedAt?: DateTimeFilter<"WatchList"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WatchListOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    marketId?: SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrderInput | SortOrder
    frequency?: SortOrder
    isActive?: SortOrder
    isEmailNotification?: SortOrder
    isTelegramNotification?: SortOrder
    lastNotifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WatchListWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WatchListWhereInput | WatchListWhereInput[]
    OR?: WatchListWhereInput[]
    NOT?: WatchListWhereInput | WatchListWhereInput[]
    userId?: StringFilter<"WatchList"> | string
    marketId?: StringFilter<"WatchList"> | string
    triggerType?: StringFilter<"WatchList"> | string
    triggerValue?: FloatNullableFilter<"WatchList"> | number | null
    frequency?: StringFilter<"WatchList"> | string
    isActive?: BoolFilter<"WatchList"> | boolean
    isEmailNotification?: BoolFilter<"WatchList"> | boolean
    isTelegramNotification?: BoolFilter<"WatchList"> | boolean
    lastNotifiedAt?: DateTimeNullableFilter<"WatchList"> | Date | string | null
    createdAt?: DateTimeFilter<"WatchList"> | Date | string
    updatedAt?: DateTimeFilter<"WatchList"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type WatchListOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    marketId?: SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrderInput | SortOrder
    frequency?: SortOrder
    isActive?: SortOrder
    isEmailNotification?: SortOrder
    isTelegramNotification?: SortOrder
    lastNotifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WatchListCountOrderByAggregateInput
    _avg?: WatchListAvgOrderByAggregateInput
    _max?: WatchListMaxOrderByAggregateInput
    _min?: WatchListMinOrderByAggregateInput
    _sum?: WatchListSumOrderByAggregateInput
  }

  export type WatchListScalarWhereWithAggregatesInput = {
    AND?: WatchListScalarWhereWithAggregatesInput | WatchListScalarWhereWithAggregatesInput[]
    OR?: WatchListScalarWhereWithAggregatesInput[]
    NOT?: WatchListScalarWhereWithAggregatesInput | WatchListScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WatchList"> | string
    userId?: StringWithAggregatesFilter<"WatchList"> | string
    marketId?: StringWithAggregatesFilter<"WatchList"> | string
    triggerType?: StringWithAggregatesFilter<"WatchList"> | string
    triggerValue?: FloatNullableWithAggregatesFilter<"WatchList"> | number | null
    frequency?: StringWithAggregatesFilter<"WatchList"> | string
    isActive?: BoolWithAggregatesFilter<"WatchList"> | boolean
    isEmailNotification?: BoolWithAggregatesFilter<"WatchList"> | boolean
    isTelegramNotification?: BoolWithAggregatesFilter<"WatchList"> | boolean
    lastNotifiedAt?: DateTimeNullableWithAggregatesFilter<"WatchList"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WatchList"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WatchList"> | Date | string
  }

  export type MarketWhereInput = {
    AND?: MarketWhereInput | MarketWhereInput[]
    OR?: MarketWhereInput[]
    NOT?: MarketWhereInput | MarketWhereInput[]
    id?: StringFilter<"Market"> | string
    conditionId?: StringFilter<"Market"> | string
    marketId?: StringNullableFilter<"Market"> | string | null
    question?: StringFilter<"Market"> | string
    slug?: StringNullableFilter<"Market"> | string | null
    liquidity?: FloatFilter<"Market"> | number
    volume?: FloatFilter<"Market"> | number
    volume24hr?: FloatFilter<"Market"> | number
    active?: BoolFilter<"Market"> | boolean
    closed?: BoolFilter<"Market"> | boolean
    archived?: BoolFilter<"Market"> | boolean
    image?: StringNullableFilter<"Market"> | string | null
    category?: StringNullableFilter<"Market"> | string | null
    tags?: StringNullableListFilter<"Market">
    outcomes?: StringNullableListFilter<"Market">
    outcomePrices?: FloatNullableListFilter<"Market">
    startDate?: DateTimeNullableFilter<"Market"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Market"> | Date | string | null
    createdAt?: DateTimeFilter<"Market"> | Date | string
    updatedAt?: DateTimeFilter<"Market"> | Date | string
  }

  export type MarketOrderByWithRelationInput = {
    id?: SortOrder
    conditionId?: SortOrder
    marketId?: SortOrderInput | SortOrder
    question?: SortOrder
    slug?: SortOrderInput | SortOrder
    liquidity?: SortOrder
    volume?: SortOrder
    volume24hr?: SortOrder
    active?: SortOrder
    closed?: SortOrder
    archived?: SortOrder
    image?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    outcomes?: SortOrder
    outcomePrices?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conditionId?: string
    AND?: MarketWhereInput | MarketWhereInput[]
    OR?: MarketWhereInput[]
    NOT?: MarketWhereInput | MarketWhereInput[]
    marketId?: StringNullableFilter<"Market"> | string | null
    question?: StringFilter<"Market"> | string
    slug?: StringNullableFilter<"Market"> | string | null
    liquidity?: FloatFilter<"Market"> | number
    volume?: FloatFilter<"Market"> | number
    volume24hr?: FloatFilter<"Market"> | number
    active?: BoolFilter<"Market"> | boolean
    closed?: BoolFilter<"Market"> | boolean
    archived?: BoolFilter<"Market"> | boolean
    image?: StringNullableFilter<"Market"> | string | null
    category?: StringNullableFilter<"Market"> | string | null
    tags?: StringNullableListFilter<"Market">
    outcomes?: StringNullableListFilter<"Market">
    outcomePrices?: FloatNullableListFilter<"Market">
    startDate?: DateTimeNullableFilter<"Market"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Market"> | Date | string | null
    createdAt?: DateTimeFilter<"Market"> | Date | string
    updatedAt?: DateTimeFilter<"Market"> | Date | string
  }, "id" | "conditionId">

  export type MarketOrderByWithAggregationInput = {
    id?: SortOrder
    conditionId?: SortOrder
    marketId?: SortOrderInput | SortOrder
    question?: SortOrder
    slug?: SortOrderInput | SortOrder
    liquidity?: SortOrder
    volume?: SortOrder
    volume24hr?: SortOrder
    active?: SortOrder
    closed?: SortOrder
    archived?: SortOrder
    image?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    outcomes?: SortOrder
    outcomePrices?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketCountOrderByAggregateInput
    _avg?: MarketAvgOrderByAggregateInput
    _max?: MarketMaxOrderByAggregateInput
    _min?: MarketMinOrderByAggregateInput
    _sum?: MarketSumOrderByAggregateInput
  }

  export type MarketScalarWhereWithAggregatesInput = {
    AND?: MarketScalarWhereWithAggregatesInput | MarketScalarWhereWithAggregatesInput[]
    OR?: MarketScalarWhereWithAggregatesInput[]
    NOT?: MarketScalarWhereWithAggregatesInput | MarketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Market"> | string
    conditionId?: StringWithAggregatesFilter<"Market"> | string
    marketId?: StringNullableWithAggregatesFilter<"Market"> | string | null
    question?: StringWithAggregatesFilter<"Market"> | string
    slug?: StringNullableWithAggregatesFilter<"Market"> | string | null
    liquidity?: FloatWithAggregatesFilter<"Market"> | number
    volume?: FloatWithAggregatesFilter<"Market"> | number
    volume24hr?: FloatWithAggregatesFilter<"Market"> | number
    active?: BoolWithAggregatesFilter<"Market"> | boolean
    closed?: BoolWithAggregatesFilter<"Market"> | boolean
    archived?: BoolWithAggregatesFilter<"Market"> | boolean
    image?: StringNullableWithAggregatesFilter<"Market"> | string | null
    category?: StringNullableWithAggregatesFilter<"Market"> | string | null
    tags?: StringNullableListFilter<"Market">
    outcomes?: StringNullableListFilter<"Market">
    outcomePrices?: FloatNullableListFilter<"Market">
    startDate?: DateTimeNullableWithAggregatesFilter<"Market"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Market"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Market"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Market"> | Date | string
  }

  export type ProxyWalletWhereInput = {
    AND?: ProxyWalletWhereInput | ProxyWalletWhereInput[]
    OR?: ProxyWalletWhereInput[]
    NOT?: ProxyWalletWhereInput | ProxyWalletWhereInput[]
    id?: StringFilter<"ProxyWallet"> | string
    address?: StringFilter<"ProxyWallet"> | string
    createdAt?: DateTimeFilter<"ProxyWallet"> | Date | string
  }

  export type ProxyWalletOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type ProxyWalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    address?: string
    AND?: ProxyWalletWhereInput | ProxyWalletWhereInput[]
    OR?: ProxyWalletWhereInput[]
    NOT?: ProxyWalletWhereInput | ProxyWalletWhereInput[]
    createdAt?: DateTimeFilter<"ProxyWallet"> | Date | string
  }, "id" | "address">

  export type ProxyWalletOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    _count?: ProxyWalletCountOrderByAggregateInput
    _max?: ProxyWalletMaxOrderByAggregateInput
    _min?: ProxyWalletMinOrderByAggregateInput
  }

  export type ProxyWalletScalarWhereWithAggregatesInput = {
    AND?: ProxyWalletScalarWhereWithAggregatesInput | ProxyWalletScalarWhereWithAggregatesInput[]
    OR?: ProxyWalletScalarWhereWithAggregatesInput[]
    NOT?: ProxyWalletScalarWhereWithAggregatesInput | ProxyWalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProxyWallet"> | string
    address?: StringWithAggregatesFilter<"ProxyWallet"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProxyWallet"> | Date | string
  }

  export type SyncHistoryWhereInput = {
    AND?: SyncHistoryWhereInput | SyncHistoryWhereInput[]
    OR?: SyncHistoryWhereInput[]
    NOT?: SyncHistoryWhereInput | SyncHistoryWhereInput[]
    id?: StringFilter<"SyncHistory"> | string
    startedAt?: DateTimeFilter<"SyncHistory"> | Date | string
    completedAt?: DateTimeNullableFilter<"SyncHistory"> | Date | string | null
    marketsFound?: IntFilter<"SyncHistory"> | number
    marketsStored?: IntFilter<"SyncHistory"> | number
    marketsFailed?: IntFilter<"SyncHistory"> | number
    walletsFound?: IntFilter<"SyncHistory"> | number
    walletsStored?: IntFilter<"SyncHistory"> | number
    status?: EnumSyncStatusFilter<"SyncHistory"> | $Enums.SyncStatus
    error?: StringNullableFilter<"SyncHistory"> | string | null
  }

  export type SyncHistoryOrderByWithRelationInput = {
    id?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    marketsFound?: SortOrder
    marketsStored?: SortOrder
    marketsFailed?: SortOrder
    walletsFound?: SortOrder
    walletsStored?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
  }

  export type SyncHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SyncHistoryWhereInput | SyncHistoryWhereInput[]
    OR?: SyncHistoryWhereInput[]
    NOT?: SyncHistoryWhereInput | SyncHistoryWhereInput[]
    startedAt?: DateTimeFilter<"SyncHistory"> | Date | string
    completedAt?: DateTimeNullableFilter<"SyncHistory"> | Date | string | null
    marketsFound?: IntFilter<"SyncHistory"> | number
    marketsStored?: IntFilter<"SyncHistory"> | number
    marketsFailed?: IntFilter<"SyncHistory"> | number
    walletsFound?: IntFilter<"SyncHistory"> | number
    walletsStored?: IntFilter<"SyncHistory"> | number
    status?: EnumSyncStatusFilter<"SyncHistory"> | $Enums.SyncStatus
    error?: StringNullableFilter<"SyncHistory"> | string | null
  }, "id">

  export type SyncHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    marketsFound?: SortOrder
    marketsStored?: SortOrder
    marketsFailed?: SortOrder
    walletsFound?: SortOrder
    walletsStored?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    _count?: SyncHistoryCountOrderByAggregateInput
    _avg?: SyncHistoryAvgOrderByAggregateInput
    _max?: SyncHistoryMaxOrderByAggregateInput
    _min?: SyncHistoryMinOrderByAggregateInput
    _sum?: SyncHistorySumOrderByAggregateInput
  }

  export type SyncHistoryScalarWhereWithAggregatesInput = {
    AND?: SyncHistoryScalarWhereWithAggregatesInput | SyncHistoryScalarWhereWithAggregatesInput[]
    OR?: SyncHistoryScalarWhereWithAggregatesInput[]
    NOT?: SyncHistoryScalarWhereWithAggregatesInput | SyncHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SyncHistory"> | string
    startedAt?: DateTimeWithAggregatesFilter<"SyncHistory"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"SyncHistory"> | Date | string | null
    marketsFound?: IntWithAggregatesFilter<"SyncHistory"> | number
    marketsStored?: IntWithAggregatesFilter<"SyncHistory"> | number
    marketsFailed?: IntWithAggregatesFilter<"SyncHistory"> | number
    walletsFound?: IntWithAggregatesFilter<"SyncHistory"> | number
    walletsStored?: IntWithAggregatesFilter<"SyncHistory"> | number
    status?: EnumSyncStatusWithAggregatesFilter<"SyncHistory"> | $Enums.SyncStatus
    error?: StringNullableWithAggregatesFilter<"SyncHistory"> | string | null
  }

  export type UserAnalyticsWhereInput = {
    AND?: UserAnalyticsWhereInput | UserAnalyticsWhereInput[]
    OR?: UserAnalyticsWhereInput[]
    NOT?: UserAnalyticsWhereInput | UserAnalyticsWhereInput[]
    id?: StringFilter<"UserAnalytics"> | string
    address?: StringFilter<"UserAnalytics"> | string
    totalVolume?: FloatFilter<"UserAnalytics"> | number
    totalProfit?: FloatFilter<"UserAnalytics"> | number
    positionValue?: FloatFilter<"UserAnalytics"> | number
    totalTrades?: IntFilter<"UserAnalytics"> | number
    totalPositions?: IntFilter<"UserAnalytics"> | number
    averageWinRate?: FloatFilter<"UserAnalytics"> | number
    avgMonthlyProfit?: FloatFilter<"UserAnalytics"> | number
    avgMonthlyTrades?: IntFilter<"UserAnalytics"> | number
    mostTradedCategory?: StringNullableFilter<"UserAnalytics"> | string | null
    tradingStyle?: StringNullableFilter<"UserAnalytics"> | string | null
    riskProfile?: StringNullableFilter<"UserAnalytics"> | string | null
    createdAt?: DateTimeFilter<"UserAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"UserAnalytics"> | Date | string
    lastSyncedAt?: DateTimeNullableFilter<"UserAnalytics"> | Date | string | null
    marketDistribution?: MarketDistributionListRelationFilter
    buySellData?: XOR<BuySellDataNullableScalarRelationFilter, BuySellDataWhereInput> | null
    tradeSizeData?: XOR<TradeSizeDataNullableScalarRelationFilter, TradeSizeDataWhereInput> | null
    priceStats?: XOR<PriceStatsNullableScalarRelationFilter, PriceStatsWhereInput> | null
    monthlyPerformance?: MonthlyPerformanceListRelationFilter
    weeklyWinRate?: WeeklyWinRateListRelationFilter
  }

  export type UserAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    totalVolume?: SortOrder
    totalProfit?: SortOrder
    positionValue?: SortOrder
    totalTrades?: SortOrder
    totalPositions?: SortOrder
    averageWinRate?: SortOrder
    avgMonthlyProfit?: SortOrder
    avgMonthlyTrades?: SortOrder
    mostTradedCategory?: SortOrderInput | SortOrder
    tradingStyle?: SortOrderInput | SortOrder
    riskProfile?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    marketDistribution?: MarketDistributionOrderByRelationAggregateInput
    buySellData?: BuySellDataOrderByWithRelationInput
    tradeSizeData?: TradeSizeDataOrderByWithRelationInput
    priceStats?: PriceStatsOrderByWithRelationInput
    monthlyPerformance?: MonthlyPerformanceOrderByRelationAggregateInput
    weeklyWinRate?: WeeklyWinRateOrderByRelationAggregateInput
  }

  export type UserAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    address?: string
    AND?: UserAnalyticsWhereInput | UserAnalyticsWhereInput[]
    OR?: UserAnalyticsWhereInput[]
    NOT?: UserAnalyticsWhereInput | UserAnalyticsWhereInput[]
    totalVolume?: FloatFilter<"UserAnalytics"> | number
    totalProfit?: FloatFilter<"UserAnalytics"> | number
    positionValue?: FloatFilter<"UserAnalytics"> | number
    totalTrades?: IntFilter<"UserAnalytics"> | number
    totalPositions?: IntFilter<"UserAnalytics"> | number
    averageWinRate?: FloatFilter<"UserAnalytics"> | number
    avgMonthlyProfit?: FloatFilter<"UserAnalytics"> | number
    avgMonthlyTrades?: IntFilter<"UserAnalytics"> | number
    mostTradedCategory?: StringNullableFilter<"UserAnalytics"> | string | null
    tradingStyle?: StringNullableFilter<"UserAnalytics"> | string | null
    riskProfile?: StringNullableFilter<"UserAnalytics"> | string | null
    createdAt?: DateTimeFilter<"UserAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"UserAnalytics"> | Date | string
    lastSyncedAt?: DateTimeNullableFilter<"UserAnalytics"> | Date | string | null
    marketDistribution?: MarketDistributionListRelationFilter
    buySellData?: XOR<BuySellDataNullableScalarRelationFilter, BuySellDataWhereInput> | null
    tradeSizeData?: XOR<TradeSizeDataNullableScalarRelationFilter, TradeSizeDataWhereInput> | null
    priceStats?: XOR<PriceStatsNullableScalarRelationFilter, PriceStatsWhereInput> | null
    monthlyPerformance?: MonthlyPerformanceListRelationFilter
    weeklyWinRate?: WeeklyWinRateListRelationFilter
  }, "id" | "address">

  export type UserAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    totalVolume?: SortOrder
    totalProfit?: SortOrder
    positionValue?: SortOrder
    totalTrades?: SortOrder
    totalPositions?: SortOrder
    averageWinRate?: SortOrder
    avgMonthlyProfit?: SortOrder
    avgMonthlyTrades?: SortOrder
    mostTradedCategory?: SortOrderInput | SortOrder
    tradingStyle?: SortOrderInput | SortOrder
    riskProfile?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    _count?: UserAnalyticsCountOrderByAggregateInput
    _avg?: UserAnalyticsAvgOrderByAggregateInput
    _max?: UserAnalyticsMaxOrderByAggregateInput
    _min?: UserAnalyticsMinOrderByAggregateInput
    _sum?: UserAnalyticsSumOrderByAggregateInput
  }

  export type UserAnalyticsScalarWhereWithAggregatesInput = {
    AND?: UserAnalyticsScalarWhereWithAggregatesInput | UserAnalyticsScalarWhereWithAggregatesInput[]
    OR?: UserAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: UserAnalyticsScalarWhereWithAggregatesInput | UserAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAnalytics"> | string
    address?: StringWithAggregatesFilter<"UserAnalytics"> | string
    totalVolume?: FloatWithAggregatesFilter<"UserAnalytics"> | number
    totalProfit?: FloatWithAggregatesFilter<"UserAnalytics"> | number
    positionValue?: FloatWithAggregatesFilter<"UserAnalytics"> | number
    totalTrades?: IntWithAggregatesFilter<"UserAnalytics"> | number
    totalPositions?: IntWithAggregatesFilter<"UserAnalytics"> | number
    averageWinRate?: FloatWithAggregatesFilter<"UserAnalytics"> | number
    avgMonthlyProfit?: FloatWithAggregatesFilter<"UserAnalytics"> | number
    avgMonthlyTrades?: IntWithAggregatesFilter<"UserAnalytics"> | number
    mostTradedCategory?: StringNullableWithAggregatesFilter<"UserAnalytics"> | string | null
    tradingStyle?: StringNullableWithAggregatesFilter<"UserAnalytics"> | string | null
    riskProfile?: StringNullableWithAggregatesFilter<"UserAnalytics"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserAnalytics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserAnalytics"> | Date | string
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"UserAnalytics"> | Date | string | null
  }

  export type MarketDistributionWhereInput = {
    AND?: MarketDistributionWhereInput | MarketDistributionWhereInput[]
    OR?: MarketDistributionWhereInput[]
    NOT?: MarketDistributionWhereInput | MarketDistributionWhereInput[]
    id?: StringFilter<"MarketDistribution"> | string
    userId?: StringFilter<"MarketDistribution"> | string
    market?: StringFilter<"MarketDistribution"> | string
    value?: IntFilter<"MarketDistribution"> | number
    trades?: IntFilter<"MarketDistribution"> | number
    volume?: FloatFilter<"MarketDistribution"> | number
    uniqueMarkets?: IntFilter<"MarketDistribution"> | number
    createdAt?: DateTimeFilter<"MarketDistribution"> | Date | string
    user?: XOR<UserAnalyticsScalarRelationFilter, UserAnalyticsWhereInput>
  }

  export type MarketDistributionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    market?: SortOrder
    value?: SortOrder
    trades?: SortOrder
    volume?: SortOrder
    uniqueMarkets?: SortOrder
    createdAt?: SortOrder
    user?: UserAnalyticsOrderByWithRelationInput
  }

  export type MarketDistributionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_market?: MarketDistributionUserIdMarketCompoundUniqueInput
    AND?: MarketDistributionWhereInput | MarketDistributionWhereInput[]
    OR?: MarketDistributionWhereInput[]
    NOT?: MarketDistributionWhereInput | MarketDistributionWhereInput[]
    userId?: StringFilter<"MarketDistribution"> | string
    market?: StringFilter<"MarketDistribution"> | string
    value?: IntFilter<"MarketDistribution"> | number
    trades?: IntFilter<"MarketDistribution"> | number
    volume?: FloatFilter<"MarketDistribution"> | number
    uniqueMarkets?: IntFilter<"MarketDistribution"> | number
    createdAt?: DateTimeFilter<"MarketDistribution"> | Date | string
    user?: XOR<UserAnalyticsScalarRelationFilter, UserAnalyticsWhereInput>
  }, "id" | "userId_market">

  export type MarketDistributionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    market?: SortOrder
    value?: SortOrder
    trades?: SortOrder
    volume?: SortOrder
    uniqueMarkets?: SortOrder
    createdAt?: SortOrder
    _count?: MarketDistributionCountOrderByAggregateInput
    _avg?: MarketDistributionAvgOrderByAggregateInput
    _max?: MarketDistributionMaxOrderByAggregateInput
    _min?: MarketDistributionMinOrderByAggregateInput
    _sum?: MarketDistributionSumOrderByAggregateInput
  }

  export type MarketDistributionScalarWhereWithAggregatesInput = {
    AND?: MarketDistributionScalarWhereWithAggregatesInput | MarketDistributionScalarWhereWithAggregatesInput[]
    OR?: MarketDistributionScalarWhereWithAggregatesInput[]
    NOT?: MarketDistributionScalarWhereWithAggregatesInput | MarketDistributionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketDistribution"> | string
    userId?: StringWithAggregatesFilter<"MarketDistribution"> | string
    market?: StringWithAggregatesFilter<"MarketDistribution"> | string
    value?: IntWithAggregatesFilter<"MarketDistribution"> | number
    trades?: IntWithAggregatesFilter<"MarketDistribution"> | number
    volume?: FloatWithAggregatesFilter<"MarketDistribution"> | number
    uniqueMarkets?: IntWithAggregatesFilter<"MarketDistribution"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MarketDistribution"> | Date | string
  }

  export type BuySellDataWhereInput = {
    AND?: BuySellDataWhereInput | BuySellDataWhereInput[]
    OR?: BuySellDataWhereInput[]
    NOT?: BuySellDataWhereInput | BuySellDataWhereInput[]
    id?: StringFilter<"BuySellData"> | string
    userId?: StringFilter<"BuySellData"> | string
    buyPercentage?: IntFilter<"BuySellData"> | number
    sellPercentage?: IntFilter<"BuySellData"> | number
    buyVolume?: FloatFilter<"BuySellData"> | number
    sellVolume?: FloatFilter<"BuySellData"> | number
    buyCount?: IntFilter<"BuySellData"> | number
    sellCount?: IntFilter<"BuySellData"> | number
    createdAt?: DateTimeFilter<"BuySellData"> | Date | string
    updatedAt?: DateTimeFilter<"BuySellData"> | Date | string
    user?: XOR<UserAnalyticsScalarRelationFilter, UserAnalyticsWhereInput>
  }

  export type BuySellDataOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    buyPercentage?: SortOrder
    sellPercentage?: SortOrder
    buyVolume?: SortOrder
    sellVolume?: SortOrder
    buyCount?: SortOrder
    sellCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserAnalyticsOrderByWithRelationInput
  }

  export type BuySellDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: BuySellDataWhereInput | BuySellDataWhereInput[]
    OR?: BuySellDataWhereInput[]
    NOT?: BuySellDataWhereInput | BuySellDataWhereInput[]
    buyPercentage?: IntFilter<"BuySellData"> | number
    sellPercentage?: IntFilter<"BuySellData"> | number
    buyVolume?: FloatFilter<"BuySellData"> | number
    sellVolume?: FloatFilter<"BuySellData"> | number
    buyCount?: IntFilter<"BuySellData"> | number
    sellCount?: IntFilter<"BuySellData"> | number
    createdAt?: DateTimeFilter<"BuySellData"> | Date | string
    updatedAt?: DateTimeFilter<"BuySellData"> | Date | string
    user?: XOR<UserAnalyticsScalarRelationFilter, UserAnalyticsWhereInput>
  }, "id" | "userId">

  export type BuySellDataOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    buyPercentage?: SortOrder
    sellPercentage?: SortOrder
    buyVolume?: SortOrder
    sellVolume?: SortOrder
    buyCount?: SortOrder
    sellCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BuySellDataCountOrderByAggregateInput
    _avg?: BuySellDataAvgOrderByAggregateInput
    _max?: BuySellDataMaxOrderByAggregateInput
    _min?: BuySellDataMinOrderByAggregateInput
    _sum?: BuySellDataSumOrderByAggregateInput
  }

  export type BuySellDataScalarWhereWithAggregatesInput = {
    AND?: BuySellDataScalarWhereWithAggregatesInput | BuySellDataScalarWhereWithAggregatesInput[]
    OR?: BuySellDataScalarWhereWithAggregatesInput[]
    NOT?: BuySellDataScalarWhereWithAggregatesInput | BuySellDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BuySellData"> | string
    userId?: StringWithAggregatesFilter<"BuySellData"> | string
    buyPercentage?: IntWithAggregatesFilter<"BuySellData"> | number
    sellPercentage?: IntWithAggregatesFilter<"BuySellData"> | number
    buyVolume?: FloatWithAggregatesFilter<"BuySellData"> | number
    sellVolume?: FloatWithAggregatesFilter<"BuySellData"> | number
    buyCount?: IntWithAggregatesFilter<"BuySellData"> | number
    sellCount?: IntWithAggregatesFilter<"BuySellData"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BuySellData"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BuySellData"> | Date | string
  }

  export type TradeSizeDataWhereInput = {
    AND?: TradeSizeDataWhereInput | TradeSizeDataWhereInput[]
    OR?: TradeSizeDataWhereInput[]
    NOT?: TradeSizeDataWhereInput | TradeSizeDataWhereInput[]
    id?: StringFilter<"TradeSizeData"> | string
    userId?: StringFilter<"TradeSizeData"> | string
    averageSize?: FloatFilter<"TradeSizeData"> | number
    medianSize?: FloatFilter<"TradeSizeData"> | number
    minSize?: FloatFilter<"TradeSizeData"> | number
    maxSize?: FloatFilter<"TradeSizeData"> | number
    smallTrades?: IntFilter<"TradeSizeData"> | number
    mediumTrades?: IntFilter<"TradeSizeData"> | number
    largeTrades?: IntFilter<"TradeSizeData"> | number
    createdAt?: DateTimeFilter<"TradeSizeData"> | Date | string
    updatedAt?: DateTimeFilter<"TradeSizeData"> | Date | string
    user?: XOR<UserAnalyticsScalarRelationFilter, UserAnalyticsWhereInput>
  }

  export type TradeSizeDataOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    averageSize?: SortOrder
    medianSize?: SortOrder
    minSize?: SortOrder
    maxSize?: SortOrder
    smallTrades?: SortOrder
    mediumTrades?: SortOrder
    largeTrades?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserAnalyticsOrderByWithRelationInput
  }

  export type TradeSizeDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: TradeSizeDataWhereInput | TradeSizeDataWhereInput[]
    OR?: TradeSizeDataWhereInput[]
    NOT?: TradeSizeDataWhereInput | TradeSizeDataWhereInput[]
    averageSize?: FloatFilter<"TradeSizeData"> | number
    medianSize?: FloatFilter<"TradeSizeData"> | number
    minSize?: FloatFilter<"TradeSizeData"> | number
    maxSize?: FloatFilter<"TradeSizeData"> | number
    smallTrades?: IntFilter<"TradeSizeData"> | number
    mediumTrades?: IntFilter<"TradeSizeData"> | number
    largeTrades?: IntFilter<"TradeSizeData"> | number
    createdAt?: DateTimeFilter<"TradeSizeData"> | Date | string
    updatedAt?: DateTimeFilter<"TradeSizeData"> | Date | string
    user?: XOR<UserAnalyticsScalarRelationFilter, UserAnalyticsWhereInput>
  }, "id" | "userId">

  export type TradeSizeDataOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    averageSize?: SortOrder
    medianSize?: SortOrder
    minSize?: SortOrder
    maxSize?: SortOrder
    smallTrades?: SortOrder
    mediumTrades?: SortOrder
    largeTrades?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TradeSizeDataCountOrderByAggregateInput
    _avg?: TradeSizeDataAvgOrderByAggregateInput
    _max?: TradeSizeDataMaxOrderByAggregateInput
    _min?: TradeSizeDataMinOrderByAggregateInput
    _sum?: TradeSizeDataSumOrderByAggregateInput
  }

  export type TradeSizeDataScalarWhereWithAggregatesInput = {
    AND?: TradeSizeDataScalarWhereWithAggregatesInput | TradeSizeDataScalarWhereWithAggregatesInput[]
    OR?: TradeSizeDataScalarWhereWithAggregatesInput[]
    NOT?: TradeSizeDataScalarWhereWithAggregatesInput | TradeSizeDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TradeSizeData"> | string
    userId?: StringWithAggregatesFilter<"TradeSizeData"> | string
    averageSize?: FloatWithAggregatesFilter<"TradeSizeData"> | number
    medianSize?: FloatWithAggregatesFilter<"TradeSizeData"> | number
    minSize?: FloatWithAggregatesFilter<"TradeSizeData"> | number
    maxSize?: FloatWithAggregatesFilter<"TradeSizeData"> | number
    smallTrades?: IntWithAggregatesFilter<"TradeSizeData"> | number
    mediumTrades?: IntWithAggregatesFilter<"TradeSizeData"> | number
    largeTrades?: IntWithAggregatesFilter<"TradeSizeData"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TradeSizeData"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TradeSizeData"> | Date | string
  }

  export type PriceStatsWhereInput = {
    AND?: PriceStatsWhereInput | PriceStatsWhereInput[]
    OR?: PriceStatsWhereInput[]
    NOT?: PriceStatsWhereInput | PriceStatsWhereInput[]
    id?: StringFilter<"PriceStats"> | string
    userId?: StringFilter<"PriceStats"> | string
    averagePrice?: FloatFilter<"PriceStats"> | number
    minPrice?: FloatFilter<"PriceStats"> | number
    maxPrice?: FloatFilter<"PriceStats"> | number
    createdAt?: DateTimeFilter<"PriceStats"> | Date | string
    updatedAt?: DateTimeFilter<"PriceStats"> | Date | string
    user?: XOR<UserAnalyticsScalarRelationFilter, UserAnalyticsWhereInput>
  }

  export type PriceStatsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    averagePrice?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserAnalyticsOrderByWithRelationInput
  }

  export type PriceStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: PriceStatsWhereInput | PriceStatsWhereInput[]
    OR?: PriceStatsWhereInput[]
    NOT?: PriceStatsWhereInput | PriceStatsWhereInput[]
    averagePrice?: FloatFilter<"PriceStats"> | number
    minPrice?: FloatFilter<"PriceStats"> | number
    maxPrice?: FloatFilter<"PriceStats"> | number
    createdAt?: DateTimeFilter<"PriceStats"> | Date | string
    updatedAt?: DateTimeFilter<"PriceStats"> | Date | string
    user?: XOR<UserAnalyticsScalarRelationFilter, UserAnalyticsWhereInput>
  }, "id" | "userId">

  export type PriceStatsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    averagePrice?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PriceStatsCountOrderByAggregateInput
    _avg?: PriceStatsAvgOrderByAggregateInput
    _max?: PriceStatsMaxOrderByAggregateInput
    _min?: PriceStatsMinOrderByAggregateInput
    _sum?: PriceStatsSumOrderByAggregateInput
  }

  export type PriceStatsScalarWhereWithAggregatesInput = {
    AND?: PriceStatsScalarWhereWithAggregatesInput | PriceStatsScalarWhereWithAggregatesInput[]
    OR?: PriceStatsScalarWhereWithAggregatesInput[]
    NOT?: PriceStatsScalarWhereWithAggregatesInput | PriceStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PriceStats"> | string
    userId?: StringWithAggregatesFilter<"PriceStats"> | string
    averagePrice?: FloatWithAggregatesFilter<"PriceStats"> | number
    minPrice?: FloatWithAggregatesFilter<"PriceStats"> | number
    maxPrice?: FloatWithAggregatesFilter<"PriceStats"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PriceStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PriceStats"> | Date | string
  }

  export type MonthlyPerformanceWhereInput = {
    AND?: MonthlyPerformanceWhereInput | MonthlyPerformanceWhereInput[]
    OR?: MonthlyPerformanceWhereInput[]
    NOT?: MonthlyPerformanceWhereInput | MonthlyPerformanceWhereInput[]
    id?: StringFilter<"MonthlyPerformance"> | string
    userId?: StringFilter<"MonthlyPerformance"> | string
    month?: StringFilter<"MonthlyPerformance"> | string
    yearMonth?: StringFilter<"MonthlyPerformance"> | string
    profit?: FloatFilter<"MonthlyPerformance"> | number
    volume?: FloatFilter<"MonthlyPerformance"> | number
    trades?: IntFilter<"MonthlyPerformance"> | number
    createdAt?: DateTimeFilter<"MonthlyPerformance"> | Date | string
    user?: XOR<UserAnalyticsScalarRelationFilter, UserAnalyticsWhereInput>
  }

  export type MonthlyPerformanceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    yearMonth?: SortOrder
    profit?: SortOrder
    volume?: SortOrder
    trades?: SortOrder
    createdAt?: SortOrder
    user?: UserAnalyticsOrderByWithRelationInput
  }

  export type MonthlyPerformanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_yearMonth?: MonthlyPerformanceUserIdYearMonthCompoundUniqueInput
    AND?: MonthlyPerformanceWhereInput | MonthlyPerformanceWhereInput[]
    OR?: MonthlyPerformanceWhereInput[]
    NOT?: MonthlyPerformanceWhereInput | MonthlyPerformanceWhereInput[]
    userId?: StringFilter<"MonthlyPerformance"> | string
    month?: StringFilter<"MonthlyPerformance"> | string
    yearMonth?: StringFilter<"MonthlyPerformance"> | string
    profit?: FloatFilter<"MonthlyPerformance"> | number
    volume?: FloatFilter<"MonthlyPerformance"> | number
    trades?: IntFilter<"MonthlyPerformance"> | number
    createdAt?: DateTimeFilter<"MonthlyPerformance"> | Date | string
    user?: XOR<UserAnalyticsScalarRelationFilter, UserAnalyticsWhereInput>
  }, "id" | "userId_yearMonth">

  export type MonthlyPerformanceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    yearMonth?: SortOrder
    profit?: SortOrder
    volume?: SortOrder
    trades?: SortOrder
    createdAt?: SortOrder
    _count?: MonthlyPerformanceCountOrderByAggregateInput
    _avg?: MonthlyPerformanceAvgOrderByAggregateInput
    _max?: MonthlyPerformanceMaxOrderByAggregateInput
    _min?: MonthlyPerformanceMinOrderByAggregateInput
    _sum?: MonthlyPerformanceSumOrderByAggregateInput
  }

  export type MonthlyPerformanceScalarWhereWithAggregatesInput = {
    AND?: MonthlyPerformanceScalarWhereWithAggregatesInput | MonthlyPerformanceScalarWhereWithAggregatesInput[]
    OR?: MonthlyPerformanceScalarWhereWithAggregatesInput[]
    NOT?: MonthlyPerformanceScalarWhereWithAggregatesInput | MonthlyPerformanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MonthlyPerformance"> | string
    userId?: StringWithAggregatesFilter<"MonthlyPerformance"> | string
    month?: StringWithAggregatesFilter<"MonthlyPerformance"> | string
    yearMonth?: StringWithAggregatesFilter<"MonthlyPerformance"> | string
    profit?: FloatWithAggregatesFilter<"MonthlyPerformance"> | number
    volume?: FloatWithAggregatesFilter<"MonthlyPerformance"> | number
    trades?: IntWithAggregatesFilter<"MonthlyPerformance"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MonthlyPerformance"> | Date | string
  }

  export type WeeklyWinRateWhereInput = {
    AND?: WeeklyWinRateWhereInput | WeeklyWinRateWhereInput[]
    OR?: WeeklyWinRateWhereInput[]
    NOT?: WeeklyWinRateWhereInput | WeeklyWinRateWhereInput[]
    id?: StringFilter<"WeeklyWinRate"> | string
    userId?: StringFilter<"WeeklyWinRate"> | string
    week?: StringFilter<"WeeklyWinRate"> | string
    weekDate?: DateTimeFilter<"WeeklyWinRate"> | Date | string
    winRate?: FloatFilter<"WeeklyWinRate"> | number
    totalTrades?: IntFilter<"WeeklyWinRate"> | number
    createdAt?: DateTimeFilter<"WeeklyWinRate"> | Date | string
    user?: XOR<UserAnalyticsScalarRelationFilter, UserAnalyticsWhereInput>
  }

  export type WeeklyWinRateOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    week?: SortOrder
    weekDate?: SortOrder
    winRate?: SortOrder
    totalTrades?: SortOrder
    createdAt?: SortOrder
    user?: UserAnalyticsOrderByWithRelationInput
  }

  export type WeeklyWinRateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_weekDate?: WeeklyWinRateUserIdWeekDateCompoundUniqueInput
    AND?: WeeklyWinRateWhereInput | WeeklyWinRateWhereInput[]
    OR?: WeeklyWinRateWhereInput[]
    NOT?: WeeklyWinRateWhereInput | WeeklyWinRateWhereInput[]
    userId?: StringFilter<"WeeklyWinRate"> | string
    week?: StringFilter<"WeeklyWinRate"> | string
    weekDate?: DateTimeFilter<"WeeklyWinRate"> | Date | string
    winRate?: FloatFilter<"WeeklyWinRate"> | number
    totalTrades?: IntFilter<"WeeklyWinRate"> | number
    createdAt?: DateTimeFilter<"WeeklyWinRate"> | Date | string
    user?: XOR<UserAnalyticsScalarRelationFilter, UserAnalyticsWhereInput>
  }, "id" | "userId_weekDate">

  export type WeeklyWinRateOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    week?: SortOrder
    weekDate?: SortOrder
    winRate?: SortOrder
    totalTrades?: SortOrder
    createdAt?: SortOrder
    _count?: WeeklyWinRateCountOrderByAggregateInput
    _avg?: WeeklyWinRateAvgOrderByAggregateInput
    _max?: WeeklyWinRateMaxOrderByAggregateInput
    _min?: WeeklyWinRateMinOrderByAggregateInput
    _sum?: WeeklyWinRateSumOrderByAggregateInput
  }

  export type WeeklyWinRateScalarWhereWithAggregatesInput = {
    AND?: WeeklyWinRateScalarWhereWithAggregatesInput | WeeklyWinRateScalarWhereWithAggregatesInput[]
    OR?: WeeklyWinRateScalarWhereWithAggregatesInput[]
    NOT?: WeeklyWinRateScalarWhereWithAggregatesInput | WeeklyWinRateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeeklyWinRate"> | string
    userId?: StringWithAggregatesFilter<"WeeklyWinRate"> | string
    week?: StringWithAggregatesFilter<"WeeklyWinRate"> | string
    weekDate?: DateTimeWithAggregatesFilter<"WeeklyWinRate"> | Date | string
    winRate?: FloatWithAggregatesFilter<"WeeklyWinRate"> | number
    totalTrades?: IntWithAggregatesFilter<"WeeklyWinRate"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WeeklyWinRate"> | Date | string
  }

  export type BlogPostWhereInput = {
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    slug?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    description?: StringNullableFilter<"BlogPost"> | string | null
    date?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    tagsArray?: StringNullableListFilter<"BlogPost">
    thumbnail?: StringNullableFilter<"BlogPost"> | string | null
    featured?: BoolFilter<"BlogPost"> | boolean
    readTime?: StringNullableFilter<"BlogPost"> | string | null
    published?: BoolFilter<"BlogPost"> | boolean
    authorUserId?: StringNullableFilter<"BlogPost"> | string | null
    content?: StringFilter<"BlogPost"> | string
    tags?: StringFilter<"BlogPost"> | string
    author?: StringNullableFilter<"BlogPost"> | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    authorUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type BlogPostOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    tagsArray?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    featured?: SortOrder
    readTime?: SortOrderInput | SortOrder
    published?: SortOrder
    authorUserId?: SortOrderInput | SortOrder
    content?: SortOrder
    tags?: SortOrder
    author?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorUser?: UserOrderByWithRelationInput
  }

  export type BlogPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    title?: StringFilter<"BlogPost"> | string
    description?: StringNullableFilter<"BlogPost"> | string | null
    date?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    tagsArray?: StringNullableListFilter<"BlogPost">
    thumbnail?: StringNullableFilter<"BlogPost"> | string | null
    featured?: BoolFilter<"BlogPost"> | boolean
    readTime?: StringNullableFilter<"BlogPost"> | string | null
    published?: BoolFilter<"BlogPost"> | boolean
    authorUserId?: StringNullableFilter<"BlogPost"> | string | null
    content?: StringFilter<"BlogPost"> | string
    tags?: StringFilter<"BlogPost"> | string
    author?: StringNullableFilter<"BlogPost"> | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    authorUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "slug">

  export type BlogPostOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    tagsArray?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    featured?: SortOrder
    readTime?: SortOrderInput | SortOrder
    published?: SortOrder
    authorUserId?: SortOrderInput | SortOrder
    content?: SortOrder
    tags?: SortOrder
    author?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogPostCountOrderByAggregateInput
    _max?: BlogPostMaxOrderByAggregateInput
    _min?: BlogPostMinOrderByAggregateInput
  }

  export type BlogPostScalarWhereWithAggregatesInput = {
    AND?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    OR?: BlogPostScalarWhereWithAggregatesInput[]
    NOT?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogPost"> | string
    slug?: StringWithAggregatesFilter<"BlogPost"> | string
    title?: StringWithAggregatesFilter<"BlogPost"> | string
    description?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"BlogPost"> | Date | string | null
    tagsArray?: StringNullableListFilter<"BlogPost">
    thumbnail?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    featured?: BoolWithAggregatesFilter<"BlogPost"> | boolean
    readTime?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    published?: BoolWithAggregatesFilter<"BlogPost"> | boolean
    authorUserId?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    content?: StringWithAggregatesFilter<"BlogPost"> | string
    tags?: StringWithAggregatesFilter<"BlogPost"> | string
    author?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    userEmail?: StringFilter<"Notification"> | string
    walletAddress?: StringFilter<"Notification"> | string
    tradeType?: StringFilter<"Notification"> | string
    amount?: StringFilter<"Notification"> | string
    market?: StringFilter<"Notification"> | string
    timestamp?: DateTimeFilter<"Notification"> | Date | string
    read?: BoolFilter<"Notification"> | boolean
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    walletAddress?: SortOrder
    tradeType?: SortOrder
    amount?: SortOrder
    market?: SortOrder
    timestamp?: SortOrder
    read?: SortOrder
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    userEmail?: StringFilter<"Notification"> | string
    walletAddress?: StringFilter<"Notification"> | string
    tradeType?: StringFilter<"Notification"> | string
    amount?: StringFilter<"Notification"> | string
    market?: StringFilter<"Notification"> | string
    timestamp?: DateTimeFilter<"Notification"> | Date | string
    read?: BoolFilter<"Notification"> | boolean
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    walletAddress?: SortOrder
    tradeType?: SortOrder
    amount?: SortOrder
    market?: SortOrder
    timestamp?: SortOrder
    read?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    userEmail?: StringWithAggregatesFilter<"Notification"> | string
    walletAddress?: StringWithAggregatesFilter<"Notification"> | string
    tradeType?: StringWithAggregatesFilter<"Notification"> | string
    amount?: StringWithAggregatesFilter<"Notification"> | string
    market?: StringWithAggregatesFilter<"Notification"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    password?: string | null
    verifyToken?: string | null
    verifyTokenExpiry?: Date | string | null
    walletAddress?: string | null
    clobApiKey?: string | null
    clobSecret?: string | null
    clobPassphrase?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken?: string | null
    telegramIntegrationId?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    blogPost?: BlogPostCreateNestedManyWithoutAuthorUserInput
    telegramIntegration?: TelegramIntegrationCreateNestedOneWithoutCreatedByInput
    watchLists?: WatchListCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    rulesConversations?: RulesConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    password?: string | null
    verifyToken?: string | null
    verifyTokenExpiry?: Date | string | null
    walletAddress?: string | null
    clobApiKey?: string | null
    clobSecret?: string | null
    clobPassphrase?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken?: string | null
    telegramIntegrationId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    blogPost?: BlogPostUncheckedCreateNestedManyWithoutAuthorUserInput
    telegramIntegration?: TelegramIntegrationUncheckedCreateNestedOneWithoutCreatedByInput
    watchLists?: WatchListUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    rulesConversations?: RulesConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clobApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    clobSecret?: NullableStringFieldUpdateOperationsInput | string | null
    clobPassphrase?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    telegramIntegrationId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    blogPost?: BlogPostUpdateManyWithoutAuthorUserNestedInput
    telegramIntegration?: TelegramIntegrationUpdateOneWithoutCreatedByNestedInput
    watchLists?: WatchListUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    rulesConversations?: RulesConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clobApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    clobSecret?: NullableStringFieldUpdateOperationsInput | string | null
    clobPassphrase?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    telegramIntegrationId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    blogPost?: BlogPostUncheckedUpdateManyWithoutAuthorUserNestedInput
    telegramIntegration?: TelegramIntegrationUncheckedUpdateOneWithoutCreatedByNestedInput
    watchLists?: WatchListUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    rulesConversations?: RulesConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    password?: string | null
    verifyToken?: string | null
    verifyTokenExpiry?: Date | string | null
    walletAddress?: string | null
    clobApiKey?: string | null
    clobSecret?: string | null
    clobPassphrase?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken?: string | null
    telegramIntegrationId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clobApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    clobSecret?: NullableStringFieldUpdateOperationsInput | string | null
    clobPassphrase?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    telegramIntegrationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clobApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    clobSecret?: NullableStringFieldUpdateOperationsInput | string | null
    clobPassphrase?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    telegramIntegrationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    id?: string
    accountId?: string | null
    type?: string | null
    providerId?: string | null
    providerAccountId?: string | null
    refresh_token?: string | null
    refreshToken?: string | null
    access_token?: string | null
    accessToken?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    idToken?: string | null
    session_state?: string | null
    accessTokenExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sessionToken?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    accountId?: string | null
    userId: string
    type?: string | null
    providerId?: string | null
    providerAccountId?: string | null
    refresh_token?: string | null
    refreshToken?: string | null
    access_token?: string | null
    accessToken?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    idToken?: string | null
    session_state?: string | null
    accessTokenExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sessionToken?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    accountId?: string | null
    userId: string
    type?: string | null
    providerId?: string | null
    providerAccountId?: string | null
    refresh_token?: string | null
    refreshToken?: string | null
    access_token?: string | null
    accessToken?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    idToken?: string | null
    session_state?: string | null
    accessTokenExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sessionToken?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken?: string | null
    token?: string | null
    expiresAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken?: string | null
    token?: string | null
    userId: string
    expiresAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken?: string | null
    token?: string | null
    userId: string
    expiresAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateInput = {
    id?: string
    userId: string
    userEmail: string
    walletAddress: string
    tradeType: string
    minAmount?: string | null
    market: string
    notifyVia: string
    telegramNotify?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationLogCreateNestedManyWithoutAlertInput
    monitoredWallet?: MonitoredWalletCreateNestedOneWithoutAlertInput
  }

  export type AlertUncheckedCreateInput = {
    id?: string
    userId: string
    userEmail: string
    walletAddress: string
    tradeType: string
    minAmount?: string | null
    market: string
    notifyVia: string
    telegramNotify?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationLogUncheckedCreateNestedManyWithoutAlertInput
    monitoredWallet?: MonitoredWalletUncheckedCreateNestedOneWithoutAlertInput
  }

  export type AlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    tradeType?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    notifyVia?: StringFieldUpdateOperationsInput | string
    telegramNotify?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationLogUpdateManyWithoutAlertNestedInput
    monitoredWallet?: MonitoredWalletUpdateOneWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    tradeType?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    notifyVia?: StringFieldUpdateOperationsInput | string
    telegramNotify?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationLogUncheckedUpdateManyWithoutAlertNestedInput
    monitoredWallet?: MonitoredWalletUncheckedUpdateOneWithoutAlertNestedInput
  }

  export type AlertCreateManyInput = {
    id?: string
    userId: string
    userEmail: string
    walletAddress: string
    tradeType: string
    minAmount?: string | null
    market: string
    notifyVia: string
    telegramNotify?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    tradeType?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    notifyVia?: StringFieldUpdateOperationsInput | string
    telegramNotify?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    tradeType?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    notifyVia?: StringFieldUpdateOperationsInput | string
    telegramNotify?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramIntegrationCreateInput = {
    id?: string
    userId: string
    userName: string
    chatId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutTelegramIntegrationInput
  }

  export type TelegramIntegrationUncheckedCreateInput = {
    id?: string
    userId: string
    userName: string
    chatId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type TelegramIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutTelegramIntegrationNestedInput
  }

  export type TelegramIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type TelegramIntegrationCreateManyInput = {
    id?: string
    userId: string
    userName: string
    chatId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type TelegramIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type MonitoredWalletCreateInput = {
    id?: string
    proxyWallet: string
    lastActivityTimestamp?: number | null
    lastActivityHash?: string | null
    totalActivities?: number
    lastCheckedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    alert: AlertCreateNestedOneWithoutMonitoredWalletInput
  }

  export type MonitoredWalletUncheckedCreateInput = {
    id?: string
    proxyWallet: string
    alertId: string
    lastActivityTimestamp?: number | null
    lastActivityHash?: string | null
    totalActivities?: number
    lastCheckedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonitoredWalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proxyWallet?: StringFieldUpdateOperationsInput | string
    lastActivityTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    lastActivityHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalActivities?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alert?: AlertUpdateOneRequiredWithoutMonitoredWalletNestedInput
  }

  export type MonitoredWalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proxyWallet?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    lastActivityTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    lastActivityHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalActivities?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitoredWalletCreateManyInput = {
    id?: string
    proxyWallet: string
    alertId: string
    lastActivityTimestamp?: number | null
    lastActivityHash?: string | null
    totalActivities?: number
    lastCheckedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonitoredWalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    proxyWallet?: StringFieldUpdateOperationsInput | string
    lastActivityTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    lastActivityHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalActivities?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitoredWalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    proxyWallet?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    lastActivityTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    lastActivityHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalActivities?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolymarketActivityCreateInput = {
    id?: string
    proxyWallet: string
    timestamp: number
    conditionId: string
    type: string
    size: number
    usdcSize: number
    transactionHash: string
    price?: number | null
    asset?: string | null
    side?: string | null
    outcomeIndex?: number | null
    title: string
    slug: string
    icon?: string | null
    eventSlug?: string | null
    outcome?: string | null
    processed?: boolean
    notificationSent?: boolean
    createdAt?: Date | string
  }

  export type PolymarketActivityUncheckedCreateInput = {
    id?: string
    proxyWallet: string
    timestamp: number
    conditionId: string
    type: string
    size: number
    usdcSize: number
    transactionHash: string
    price?: number | null
    asset?: string | null
    side?: string | null
    outcomeIndex?: number | null
    title: string
    slug: string
    icon?: string | null
    eventSlug?: string | null
    outcome?: string | null
    processed?: boolean
    notificationSent?: boolean
    createdAt?: Date | string
  }

  export type PolymarketActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proxyWallet?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    conditionId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    usdcSize?: FloatFieldUpdateOperationsInput | number
    transactionHash?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    asset?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    outcomeIndex?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    eventSlug?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    notificationSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolymarketActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proxyWallet?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    conditionId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    usdcSize?: FloatFieldUpdateOperationsInput | number
    transactionHash?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    asset?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    outcomeIndex?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    eventSlug?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    notificationSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolymarketActivityCreateManyInput = {
    id?: string
    proxyWallet: string
    timestamp: number
    conditionId: string
    type: string
    size: number
    usdcSize: number
    transactionHash: string
    price?: number | null
    asset?: string | null
    side?: string | null
    outcomeIndex?: number | null
    title: string
    slug: string
    icon?: string | null
    eventSlug?: string | null
    outcome?: string | null
    processed?: boolean
    notificationSent?: boolean
    createdAt?: Date | string
  }

  export type PolymarketActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    proxyWallet?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    conditionId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    usdcSize?: FloatFieldUpdateOperationsInput | number
    transactionHash?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    asset?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    outcomeIndex?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    eventSlug?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    notificationSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolymarketActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    proxyWallet?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    conditionId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    usdcSize?: FloatFieldUpdateOperationsInput | number
    transactionHash?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    asset?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    outcomeIndex?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    eventSlug?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    notificationSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitoringJobLogCreateInput = {
    id?: string
    jobType?: string
    status: string
    walletsChecked?: number
    activitiesFound?: number
    activitiesProcessed?: number
    notificationsQueued?: number
    duration?: number | null
    error?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type MonitoringJobLogUncheckedCreateInput = {
    id?: string
    jobType?: string
    status: string
    walletsChecked?: number
    activitiesFound?: number
    activitiesProcessed?: number
    notificationsQueued?: number
    duration?: number | null
    error?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type MonitoringJobLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    walletsChecked?: IntFieldUpdateOperationsInput | number
    activitiesFound?: IntFieldUpdateOperationsInput | number
    activitiesProcessed?: IntFieldUpdateOperationsInput | number
    notificationsQueued?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MonitoringJobLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    walletsChecked?: IntFieldUpdateOperationsInput | number
    activitiesFound?: IntFieldUpdateOperationsInput | number
    activitiesProcessed?: IntFieldUpdateOperationsInput | number
    notificationsQueued?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MonitoringJobLogCreateManyInput = {
    id?: string
    jobType?: string
    status: string
    walletsChecked?: number
    activitiesFound?: number
    activitiesProcessed?: number
    notificationsQueued?: number
    duration?: number | null
    error?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type MonitoringJobLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    walletsChecked?: IntFieldUpdateOperationsInput | number
    activitiesFound?: IntFieldUpdateOperationsInput | number
    activitiesProcessed?: IntFieldUpdateOperationsInput | number
    notificationsQueued?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MonitoringJobLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    walletsChecked?: IntFieldUpdateOperationsInput | number
    activitiesFound?: IntFieldUpdateOperationsInput | number
    activitiesProcessed?: IntFieldUpdateOperationsInput | number
    notificationsQueued?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationQueueCreateInput = {
    id?: string
    userId: string
    userEmail: string
    alertId: string
    walletAddress: string
    activityId?: string | null
    tradeType: string
    amount: string
    market: string
    marketId?: string | null
    marketUrl?: string | null
    marketIcon?: string | null
    notifyVia: string
    status?: $Enums.NotificationStatus
    attempts?: number
    maxAttempts?: number
    error?: string | null
    scheduledFor?: Date | string
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationQueueUncheckedCreateInput = {
    id?: string
    userId: string
    userEmail: string
    alertId: string
    walletAddress: string
    activityId?: string | null
    tradeType: string
    amount: string
    market: string
    marketId?: string | null
    marketUrl?: string | null
    marketIcon?: string | null
    notifyVia: string
    status?: $Enums.NotificationStatus
    attempts?: number
    maxAttempts?: number
    error?: string | null
    scheduledFor?: Date | string
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeType?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    marketId?: NullableStringFieldUpdateOperationsInput | string | null
    marketUrl?: NullableStringFieldUpdateOperationsInput | string | null
    marketIcon?: NullableStringFieldUpdateOperationsInput | string | null
    notifyVia?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeType?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    marketId?: NullableStringFieldUpdateOperationsInput | string | null
    marketUrl?: NullableStringFieldUpdateOperationsInput | string | null
    marketIcon?: NullableStringFieldUpdateOperationsInput | string | null
    notifyVia?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationQueueCreateManyInput = {
    id?: string
    userId: string
    userEmail: string
    alertId: string
    walletAddress: string
    activityId?: string | null
    tradeType: string
    amount: string
    market: string
    marketId?: string | null
    marketUrl?: string | null
    marketIcon?: string | null
    notifyVia: string
    status?: $Enums.NotificationStatus
    attempts?: number
    maxAttempts?: number
    error?: string | null
    scheduledFor?: Date | string
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeType?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    marketId?: NullableStringFieldUpdateOperationsInput | string | null
    marketUrl?: NullableStringFieldUpdateOperationsInput | string | null
    marketIcon?: NullableStringFieldUpdateOperationsInput | string | null
    notifyVia?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeType?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    marketId?: NullableStringFieldUpdateOperationsInput | string | null
    marketUrl?: NullableStringFieldUpdateOperationsInput | string | null
    marketIcon?: NullableStringFieldUpdateOperationsInput | string | null
    notifyVia?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateInput = {
    id?: string
    userId: string
    userEmail: string
    walletAddress: string
    activityId?: string | null
    tradeType: string
    amount: string
    market: string
    notifyVia: string
    status: string
    error?: string | null
    sentAt?: Date | string
    alert: AlertCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationLogUncheckedCreateInput = {
    id?: string
    userId: string
    userEmail: string
    alertId: string
    walletAddress: string
    activityId?: string | null
    tradeType: string
    amount: string
    market: string
    notifyVia: string
    status: string
    error?: string | null
    sentAt?: Date | string
  }

  export type NotificationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeType?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    notifyVia?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alert?: AlertUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeType?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    notifyVia?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateManyInput = {
    id?: string
    userId: string
    userEmail: string
    alertId: string
    walletAddress: string
    activityId?: string | null
    tradeType: string
    amount: string
    market: string
    notifyVia: string
    status: string
    error?: string | null
    sentAt?: Date | string
  }

  export type NotificationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeType?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    notifyVia?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeType?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    notifyVia?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CronJobLogCreateInput = {
    id?: string
    jobType: string
    status: string
    processed?: number
    failed?: number
    duration?: number | null
    error?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type CronJobLogUncheckedCreateInput = {
    id?: string
    jobType: string
    status: string
    processed?: number
    failed?: number
    duration?: number | null
    error?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type CronJobLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processed?: IntFieldUpdateOperationsInput | number
    failed?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CronJobLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processed?: IntFieldUpdateOperationsInput | number
    failed?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CronJobLogCreateManyInput = {
    id?: string
    jobType: string
    status: string
    processed?: number
    failed?: number
    duration?: number | null
    error?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type CronJobLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processed?: IntFieldUpdateOperationsInput | number
    failed?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CronJobLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processed?: IntFieldUpdateOperationsInput | number
    failed?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConversationCreateInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    isFavorite?: boolean
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    userId: string
    title?: string | null
    createdAt?: Date | string
    isFavorite?: boolean
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    userId: string
    title?: string | null
    createdAt?: Date | string
    isFavorite?: boolean
    updatedAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    type: string
    content: string
    images?: MessageCreateimagesInput | string[]
    completed?: boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    type: string
    content: string
    images?: MessageCreateimagesInput | string[]
    completed?: boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: MessageUpdateimagesInput | string[]
    completed?: BoolFieldUpdateOperationsInput | boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: MessageUpdateimagesInput | string[]
    completed?: BoolFieldUpdateOperationsInput | boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    type: string
    content: string
    images?: MessageCreateimagesInput | string[]
    completed?: boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: MessageUpdateimagesInput | string[]
    completed?: BoolFieldUpdateOperationsInput | boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: MessageUpdateimagesInput | string[]
    completed?: BoolFieldUpdateOperationsInput | boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RulesConversationCreateInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    isFavorite?: boolean
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRulesConversationsInput
    messages?: RulesMessageCreateNestedManyWithoutConversationInput
  }

  export type RulesConversationUncheckedCreateInput = {
    id?: string
    userId: string
    title?: string | null
    createdAt?: Date | string
    isFavorite?: boolean
    updatedAt?: Date | string
    messages?: RulesMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type RulesConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRulesConversationsNestedInput
    messages?: RulesMessageUpdateManyWithoutConversationNestedInput
  }

  export type RulesConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: RulesMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type RulesConversationCreateManyInput = {
    id?: string
    userId: string
    title?: string | null
    createdAt?: Date | string
    isFavorite?: boolean
    updatedAt?: Date | string
  }

  export type RulesConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RulesConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RulesMessageCreateInput = {
    id?: string
    type: string
    content: string
    images?: RulesMessageCreateimagesInput | string[]
    completed?: boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    conversation: RulesConversationCreateNestedOneWithoutMessagesInput
  }

  export type RulesMessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    type: string
    content: string
    images?: RulesMessageCreateimagesInput | string[]
    completed?: boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RulesMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: RulesMessageUpdateimagesInput | string[]
    completed?: BoolFieldUpdateOperationsInput | boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: RulesConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type RulesMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: RulesMessageUpdateimagesInput | string[]
    completed?: BoolFieldUpdateOperationsInput | boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RulesMessageCreateManyInput = {
    id?: string
    conversationId: string
    type: string
    content: string
    images?: RulesMessageCreateimagesInput | string[]
    completed?: boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RulesMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: RulesMessageUpdateimagesInput | string[]
    completed?: BoolFieldUpdateOperationsInput | boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RulesMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: RulesMessageUpdateimagesInput | string[]
    completed?: BoolFieldUpdateOperationsInput | boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchListCreateInput = {
    id?: string
    marketId: string
    triggerType: string
    triggerValue?: number | null
    frequency?: string
    isActive?: boolean
    isEmailNotification?: boolean
    isTelegramNotification?: boolean
    lastNotifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWatchListsInput
  }

  export type WatchListUncheckedCreateInput = {
    id?: string
    userId: string
    marketId: string
    triggerType: string
    triggerValue?: number | null
    frequency?: string
    isActive?: boolean
    isEmailNotification?: boolean
    isTelegramNotification?: boolean
    lastNotifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WatchListUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailNotification?: BoolFieldUpdateOperationsInput | boolean
    isTelegramNotification?: BoolFieldUpdateOperationsInput | boolean
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWatchListsNestedInput
  }

  export type WatchListUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailNotification?: BoolFieldUpdateOperationsInput | boolean
    isTelegramNotification?: BoolFieldUpdateOperationsInput | boolean
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchListCreateManyInput = {
    id?: string
    userId: string
    marketId: string
    triggerType: string
    triggerValue?: number | null
    frequency?: string
    isActive?: boolean
    isEmailNotification?: boolean
    isTelegramNotification?: boolean
    lastNotifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WatchListUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailNotification?: BoolFieldUpdateOperationsInput | boolean
    isTelegramNotification?: BoolFieldUpdateOperationsInput | boolean
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchListUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailNotification?: BoolFieldUpdateOperationsInput | boolean
    isTelegramNotification?: BoolFieldUpdateOperationsInput | boolean
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketCreateInput = {
    id?: string
    conditionId: string
    marketId?: string | null
    question: string
    slug?: string | null
    liquidity?: number
    volume?: number
    volume24hr?: number
    active?: boolean
    closed?: boolean
    archived?: boolean
    image?: string | null
    category?: string | null
    tags?: MarketCreatetagsInput | string[]
    outcomes?: MarketCreateoutcomesInput | string[]
    outcomePrices?: MarketCreateoutcomePricesInput | number[]
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketUncheckedCreateInput = {
    id?: string
    conditionId: string
    marketId?: string | null
    question: string
    slug?: string | null
    liquidity?: number
    volume?: number
    volume24hr?: number
    active?: boolean
    closed?: boolean
    archived?: boolean
    image?: string | null
    category?: string | null
    tags?: MarketCreatetagsInput | string[]
    outcomes?: MarketCreateoutcomesInput | string[]
    outcomePrices?: MarketCreateoutcomePricesInput | number[]
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conditionId?: StringFieldUpdateOperationsInput | string
    marketId?: NullableStringFieldUpdateOperationsInput | string | null
    question?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    liquidity?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    volume24hr?: FloatFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    closed?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MarketUpdatetagsInput | string[]
    outcomes?: MarketUpdateoutcomesInput | string[]
    outcomePrices?: MarketUpdateoutcomePricesInput | number[]
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conditionId?: StringFieldUpdateOperationsInput | string
    marketId?: NullableStringFieldUpdateOperationsInput | string | null
    question?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    liquidity?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    volume24hr?: FloatFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    closed?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MarketUpdatetagsInput | string[]
    outcomes?: MarketUpdateoutcomesInput | string[]
    outcomePrices?: MarketUpdateoutcomePricesInput | number[]
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketCreateManyInput = {
    id?: string
    conditionId: string
    marketId?: string | null
    question: string
    slug?: string | null
    liquidity?: number
    volume?: number
    volume24hr?: number
    active?: boolean
    closed?: boolean
    archived?: boolean
    image?: string | null
    category?: string | null
    tags?: MarketCreatetagsInput | string[]
    outcomes?: MarketCreateoutcomesInput | string[]
    outcomePrices?: MarketCreateoutcomePricesInput | number[]
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    conditionId?: StringFieldUpdateOperationsInput | string
    marketId?: NullableStringFieldUpdateOperationsInput | string | null
    question?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    liquidity?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    volume24hr?: FloatFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    closed?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MarketUpdatetagsInput | string[]
    outcomes?: MarketUpdateoutcomesInput | string[]
    outcomePrices?: MarketUpdateoutcomePricesInput | number[]
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conditionId?: StringFieldUpdateOperationsInput | string
    marketId?: NullableStringFieldUpdateOperationsInput | string | null
    question?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    liquidity?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    volume24hr?: FloatFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    closed?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MarketUpdatetagsInput | string[]
    outcomes?: MarketUpdateoutcomesInput | string[]
    outcomePrices?: MarketUpdateoutcomePricesInput | number[]
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxyWalletCreateInput = {
    id?: string
    address: string
    createdAt?: Date | string
  }

  export type ProxyWalletUncheckedCreateInput = {
    id?: string
    address: string
    createdAt?: Date | string
  }

  export type ProxyWalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxyWalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxyWalletCreateManyInput = {
    id?: string
    address: string
    createdAt?: Date | string
  }

  export type ProxyWalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxyWalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncHistoryCreateInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    marketsFound?: number
    marketsStored?: number
    marketsFailed?: number
    walletsFound?: number
    walletsStored?: number
    status?: $Enums.SyncStatus
    error?: string | null
  }

  export type SyncHistoryUncheckedCreateInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    marketsFound?: number
    marketsStored?: number
    marketsFailed?: number
    walletsFound?: number
    walletsStored?: number
    status?: $Enums.SyncStatus
    error?: string | null
  }

  export type SyncHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketsFound?: IntFieldUpdateOperationsInput | number
    marketsStored?: IntFieldUpdateOperationsInput | number
    marketsFailed?: IntFieldUpdateOperationsInput | number
    walletsFound?: IntFieldUpdateOperationsInput | number
    walletsStored?: IntFieldUpdateOperationsInput | number
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyncHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketsFound?: IntFieldUpdateOperationsInput | number
    marketsStored?: IntFieldUpdateOperationsInput | number
    marketsFailed?: IntFieldUpdateOperationsInput | number
    walletsFound?: IntFieldUpdateOperationsInput | number
    walletsStored?: IntFieldUpdateOperationsInput | number
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyncHistoryCreateManyInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    marketsFound?: number
    marketsStored?: number
    marketsFailed?: number
    walletsFound?: number
    walletsStored?: number
    status?: $Enums.SyncStatus
    error?: string | null
  }

  export type SyncHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketsFound?: IntFieldUpdateOperationsInput | number
    marketsStored?: IntFieldUpdateOperationsInput | number
    marketsFailed?: IntFieldUpdateOperationsInput | number
    walletsFound?: IntFieldUpdateOperationsInput | number
    walletsStored?: IntFieldUpdateOperationsInput | number
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyncHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketsFound?: IntFieldUpdateOperationsInput | number
    marketsStored?: IntFieldUpdateOperationsInput | number
    marketsFailed?: IntFieldUpdateOperationsInput | number
    walletsFound?: IntFieldUpdateOperationsInput | number
    walletsStored?: IntFieldUpdateOperationsInput | number
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAnalyticsCreateInput = {
    id?: string
    address: string
    totalVolume?: number
    totalProfit?: number
    positionValue?: number
    totalTrades?: number
    totalPositions?: number
    averageWinRate?: number
    avgMonthlyProfit?: number
    avgMonthlyTrades?: number
    mostTradedCategory?: string | null
    tradingStyle?: string | null
    riskProfile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    marketDistribution?: MarketDistributionCreateNestedManyWithoutUserInput
    buySellData?: BuySellDataCreateNestedOneWithoutUserInput
    tradeSizeData?: TradeSizeDataCreateNestedOneWithoutUserInput
    priceStats?: PriceStatsCreateNestedOneWithoutUserInput
    monthlyPerformance?: MonthlyPerformanceCreateNestedManyWithoutUserInput
    weeklyWinRate?: WeeklyWinRateCreateNestedManyWithoutUserInput
  }

  export type UserAnalyticsUncheckedCreateInput = {
    id?: string
    address: string
    totalVolume?: number
    totalProfit?: number
    positionValue?: number
    totalTrades?: number
    totalPositions?: number
    averageWinRate?: number
    avgMonthlyProfit?: number
    avgMonthlyTrades?: number
    mostTradedCategory?: string | null
    tradingStyle?: string | null
    riskProfile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    marketDistribution?: MarketDistributionUncheckedCreateNestedManyWithoutUserInput
    buySellData?: BuySellDataUncheckedCreateNestedOneWithoutUserInput
    tradeSizeData?: TradeSizeDataUncheckedCreateNestedOneWithoutUserInput
    priceStats?: PriceStatsUncheckedCreateNestedOneWithoutUserInput
    monthlyPerformance?: MonthlyPerformanceUncheckedCreateNestedManyWithoutUserInput
    weeklyWinRate?: WeeklyWinRateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    positionValue?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    totalPositions?: IntFieldUpdateOperationsInput | number
    averageWinRate?: FloatFieldUpdateOperationsInput | number
    avgMonthlyProfit?: FloatFieldUpdateOperationsInput | number
    avgMonthlyTrades?: IntFieldUpdateOperationsInput | number
    mostTradedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    tradingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    riskProfile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketDistribution?: MarketDistributionUpdateManyWithoutUserNestedInput
    buySellData?: BuySellDataUpdateOneWithoutUserNestedInput
    tradeSizeData?: TradeSizeDataUpdateOneWithoutUserNestedInput
    priceStats?: PriceStatsUpdateOneWithoutUserNestedInput
    monthlyPerformance?: MonthlyPerformanceUpdateManyWithoutUserNestedInput
    weeklyWinRate?: WeeklyWinRateUpdateManyWithoutUserNestedInput
  }

  export type UserAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    positionValue?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    totalPositions?: IntFieldUpdateOperationsInput | number
    averageWinRate?: FloatFieldUpdateOperationsInput | number
    avgMonthlyProfit?: FloatFieldUpdateOperationsInput | number
    avgMonthlyTrades?: IntFieldUpdateOperationsInput | number
    mostTradedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    tradingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    riskProfile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketDistribution?: MarketDistributionUncheckedUpdateManyWithoutUserNestedInput
    buySellData?: BuySellDataUncheckedUpdateOneWithoutUserNestedInput
    tradeSizeData?: TradeSizeDataUncheckedUpdateOneWithoutUserNestedInput
    priceStats?: PriceStatsUncheckedUpdateOneWithoutUserNestedInput
    monthlyPerformance?: MonthlyPerformanceUncheckedUpdateManyWithoutUserNestedInput
    weeklyWinRate?: WeeklyWinRateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserAnalyticsCreateManyInput = {
    id?: string
    address: string
    totalVolume?: number
    totalProfit?: number
    positionValue?: number
    totalTrades?: number
    totalPositions?: number
    averageWinRate?: number
    avgMonthlyProfit?: number
    avgMonthlyTrades?: number
    mostTradedCategory?: string | null
    tradingStyle?: string | null
    riskProfile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
  }

  export type UserAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    positionValue?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    totalPositions?: IntFieldUpdateOperationsInput | number
    averageWinRate?: FloatFieldUpdateOperationsInput | number
    avgMonthlyProfit?: FloatFieldUpdateOperationsInput | number
    avgMonthlyTrades?: IntFieldUpdateOperationsInput | number
    mostTradedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    tradingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    riskProfile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    positionValue?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    totalPositions?: IntFieldUpdateOperationsInput | number
    averageWinRate?: FloatFieldUpdateOperationsInput | number
    avgMonthlyProfit?: FloatFieldUpdateOperationsInput | number
    avgMonthlyTrades?: IntFieldUpdateOperationsInput | number
    mostTradedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    tradingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    riskProfile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MarketDistributionCreateInput = {
    id?: string
    market: string
    value: number
    trades: number
    volume: number
    uniqueMarkets: number
    createdAt?: Date | string
    user: UserAnalyticsCreateNestedOneWithoutMarketDistributionInput
  }

  export type MarketDistributionUncheckedCreateInput = {
    id?: string
    userId: string
    market: string
    value: number
    trades: number
    volume: number
    uniqueMarkets: number
    createdAt?: Date | string
  }

  export type MarketDistributionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    uniqueMarkets?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserAnalyticsUpdateOneRequiredWithoutMarketDistributionNestedInput
  }

  export type MarketDistributionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    uniqueMarkets?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketDistributionCreateManyInput = {
    id?: string
    userId: string
    market: string
    value: number
    trades: number
    volume: number
    uniqueMarkets: number
    createdAt?: Date | string
  }

  export type MarketDistributionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    uniqueMarkets?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketDistributionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    uniqueMarkets?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuySellDataCreateInput = {
    id?: string
    buyPercentage: number
    sellPercentage: number
    buyVolume: number
    sellVolume: number
    buyCount: number
    sellCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserAnalyticsCreateNestedOneWithoutBuySellDataInput
  }

  export type BuySellDataUncheckedCreateInput = {
    id?: string
    userId: string
    buyPercentage: number
    sellPercentage: number
    buyVolume: number
    sellVolume: number
    buyCount: number
    sellCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuySellDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyPercentage?: IntFieldUpdateOperationsInput | number
    sellPercentage?: IntFieldUpdateOperationsInput | number
    buyVolume?: FloatFieldUpdateOperationsInput | number
    sellVolume?: FloatFieldUpdateOperationsInput | number
    buyCount?: IntFieldUpdateOperationsInput | number
    sellCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserAnalyticsUpdateOneRequiredWithoutBuySellDataNestedInput
  }

  export type BuySellDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    buyPercentage?: IntFieldUpdateOperationsInput | number
    sellPercentage?: IntFieldUpdateOperationsInput | number
    buyVolume?: FloatFieldUpdateOperationsInput | number
    sellVolume?: FloatFieldUpdateOperationsInput | number
    buyCount?: IntFieldUpdateOperationsInput | number
    sellCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuySellDataCreateManyInput = {
    id?: string
    userId: string
    buyPercentage: number
    sellPercentage: number
    buyVolume: number
    sellVolume: number
    buyCount: number
    sellCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuySellDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyPercentage?: IntFieldUpdateOperationsInput | number
    sellPercentage?: IntFieldUpdateOperationsInput | number
    buyVolume?: FloatFieldUpdateOperationsInput | number
    sellVolume?: FloatFieldUpdateOperationsInput | number
    buyCount?: IntFieldUpdateOperationsInput | number
    sellCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuySellDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    buyPercentage?: IntFieldUpdateOperationsInput | number
    sellPercentage?: IntFieldUpdateOperationsInput | number
    buyVolume?: FloatFieldUpdateOperationsInput | number
    sellVolume?: FloatFieldUpdateOperationsInput | number
    buyCount?: IntFieldUpdateOperationsInput | number
    sellCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeSizeDataCreateInput = {
    id?: string
    averageSize: number
    medianSize: number
    minSize: number
    maxSize: number
    smallTrades: number
    mediumTrades: number
    largeTrades: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserAnalyticsCreateNestedOneWithoutTradeSizeDataInput
  }

  export type TradeSizeDataUncheckedCreateInput = {
    id?: string
    userId: string
    averageSize: number
    medianSize: number
    minSize: number
    maxSize: number
    smallTrades: number
    mediumTrades: number
    largeTrades: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeSizeDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    averageSize?: FloatFieldUpdateOperationsInput | number
    medianSize?: FloatFieldUpdateOperationsInput | number
    minSize?: FloatFieldUpdateOperationsInput | number
    maxSize?: FloatFieldUpdateOperationsInput | number
    smallTrades?: IntFieldUpdateOperationsInput | number
    mediumTrades?: IntFieldUpdateOperationsInput | number
    largeTrades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserAnalyticsUpdateOneRequiredWithoutTradeSizeDataNestedInput
  }

  export type TradeSizeDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    averageSize?: FloatFieldUpdateOperationsInput | number
    medianSize?: FloatFieldUpdateOperationsInput | number
    minSize?: FloatFieldUpdateOperationsInput | number
    maxSize?: FloatFieldUpdateOperationsInput | number
    smallTrades?: IntFieldUpdateOperationsInput | number
    mediumTrades?: IntFieldUpdateOperationsInput | number
    largeTrades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeSizeDataCreateManyInput = {
    id?: string
    userId: string
    averageSize: number
    medianSize: number
    minSize: number
    maxSize: number
    smallTrades: number
    mediumTrades: number
    largeTrades: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeSizeDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    averageSize?: FloatFieldUpdateOperationsInput | number
    medianSize?: FloatFieldUpdateOperationsInput | number
    minSize?: FloatFieldUpdateOperationsInput | number
    maxSize?: FloatFieldUpdateOperationsInput | number
    smallTrades?: IntFieldUpdateOperationsInput | number
    mediumTrades?: IntFieldUpdateOperationsInput | number
    largeTrades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeSizeDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    averageSize?: FloatFieldUpdateOperationsInput | number
    medianSize?: FloatFieldUpdateOperationsInput | number
    minSize?: FloatFieldUpdateOperationsInput | number
    maxSize?: FloatFieldUpdateOperationsInput | number
    smallTrades?: IntFieldUpdateOperationsInput | number
    mediumTrades?: IntFieldUpdateOperationsInput | number
    largeTrades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceStatsCreateInput = {
    id?: string
    averagePrice: number
    minPrice: number
    maxPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserAnalyticsCreateNestedOneWithoutPriceStatsInput
  }

  export type PriceStatsUncheckedCreateInput = {
    id?: string
    userId: string
    averagePrice: number
    minPrice: number
    maxPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    averagePrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserAnalyticsUpdateOneRequiredWithoutPriceStatsNestedInput
  }

  export type PriceStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    averagePrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceStatsCreateManyInput = {
    id?: string
    userId: string
    averagePrice: number
    minPrice: number
    maxPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    averagePrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    averagePrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlyPerformanceCreateInput = {
    id?: string
    month: string
    yearMonth: string
    profit: number
    volume: number
    trades: number
    createdAt?: Date | string
    user: UserAnalyticsCreateNestedOneWithoutMonthlyPerformanceInput
  }

  export type MonthlyPerformanceUncheckedCreateInput = {
    id?: string
    userId: string
    month: string
    yearMonth: string
    profit: number
    volume: number
    trades: number
    createdAt?: Date | string
  }

  export type MonthlyPerformanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    yearMonth?: StringFieldUpdateOperationsInput | string
    profit?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserAnalyticsUpdateOneRequiredWithoutMonthlyPerformanceNestedInput
  }

  export type MonthlyPerformanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    yearMonth?: StringFieldUpdateOperationsInput | string
    profit?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlyPerformanceCreateManyInput = {
    id?: string
    userId: string
    month: string
    yearMonth: string
    profit: number
    volume: number
    trades: number
    createdAt?: Date | string
  }

  export type MonthlyPerformanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    yearMonth?: StringFieldUpdateOperationsInput | string
    profit?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlyPerformanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    yearMonth?: StringFieldUpdateOperationsInput | string
    profit?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyWinRateCreateInput = {
    id?: string
    week: string
    weekDate: Date | string
    winRate: number
    totalTrades: number
    createdAt?: Date | string
    user: UserAnalyticsCreateNestedOneWithoutWeeklyWinRateInput
  }

  export type WeeklyWinRateUncheckedCreateInput = {
    id?: string
    userId: string
    week: string
    weekDate: Date | string
    winRate: number
    totalTrades: number
    createdAt?: Date | string
  }

  export type WeeklyWinRateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: StringFieldUpdateOperationsInput | string
    weekDate?: DateTimeFieldUpdateOperationsInput | Date | string
    winRate?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserAnalyticsUpdateOneRequiredWithoutWeeklyWinRateNestedInput
  }

  export type WeeklyWinRateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    week?: StringFieldUpdateOperationsInput | string
    weekDate?: DateTimeFieldUpdateOperationsInput | Date | string
    winRate?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyWinRateCreateManyInput = {
    id?: string
    userId: string
    week: string
    weekDate: Date | string
    winRate: number
    totalTrades: number
    createdAt?: Date | string
  }

  export type WeeklyWinRateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: StringFieldUpdateOperationsInput | string
    weekDate?: DateTimeFieldUpdateOperationsInput | Date | string
    winRate?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyWinRateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    week?: StringFieldUpdateOperationsInput | string
    weekDate?: DateTimeFieldUpdateOperationsInput | Date | string
    winRate?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    date?: Date | string | null
    tagsArray?: BlogPostCreatetagsArrayInput | string[]
    thumbnail?: string | null
    featured?: boolean
    readTime?: string | null
    published?: boolean
    content: string
    tags: string
    author?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorUser?: UserCreateNestedOneWithoutBlogPostInput
  }

  export type BlogPostUncheckedCreateInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    date?: Date | string | null
    tagsArray?: BlogPostCreatetagsArrayInput | string[]
    thumbnail?: string | null
    featured?: boolean
    readTime?: string | null
    published?: boolean
    authorUserId?: string | null
    content: string
    tags: string
    author?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagsArray?: BlogPostUpdatetagsArrayInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    readTime?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    content?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorUser?: UserUpdateOneWithoutBlogPostNestedInput
  }

  export type BlogPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagsArray?: BlogPostUpdatetagsArrayInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    readTime?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateManyInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    date?: Date | string | null
    tagsArray?: BlogPostCreatetagsArrayInput | string[]
    thumbnail?: string | null
    featured?: boolean
    readTime?: string | null
    published?: boolean
    authorUserId?: string | null
    content: string
    tags: string
    author?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagsArray?: BlogPostUpdatetagsArrayInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    readTime?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    content?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagsArray?: BlogPostUpdatetagsArrayInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    readTime?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    userId: string
    userEmail: string
    walletAddress: string
    tradeType: string
    amount: string
    market: string
    timestamp?: Date | string
    read?: boolean
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    userEmail: string
    walletAddress: string
    tradeType: string
    amount: string
    market: string
    timestamp?: Date | string
    read?: boolean
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    tradeType?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    tradeType?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    userEmail: string
    walletAddress: string
    tradeType: string
    amount: string
    market: string
    timestamp?: Date | string
    read?: boolean
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    tradeType?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    tradeType?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type BlogPostListRelationFilter = {
    every?: BlogPostWhereInput
    some?: BlogPostWhereInput
    none?: BlogPostWhereInput
  }

  export type TelegramIntegrationNullableScalarRelationFilter = {
    is?: TelegramIntegrationWhereInput | null
    isNot?: TelegramIntegrationWhereInput | null
  }

  export type WatchListListRelationFilter = {
    every?: WatchListWhereInput
    some?: WatchListWhereInput
    none?: WatchListWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type RulesConversationListRelationFilter = {
    every?: RulesConversationWhereInput
    some?: RulesConversationWhereInput
    none?: RulesConversationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WatchListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RulesConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    verifyToken?: SortOrder
    verifyTokenExpiry?: SortOrder
    walletAddress?: SortOrder
    clobApiKey?: SortOrder
    clobSecret?: SortOrder
    clobPassphrase?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessToken?: SortOrder
    telegramIntegrationId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    verifyToken?: SortOrder
    verifyTokenExpiry?: SortOrder
    walletAddress?: SortOrder
    clobApiKey?: SortOrder
    clobSecret?: SortOrder
    clobPassphrase?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessToken?: SortOrder
    telegramIntegrationId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    verifyToken?: SortOrder
    verifyTokenExpiry?: SortOrder
    walletAddress?: SortOrder
    clobApiKey?: SortOrder
    clobSecret?: SortOrder
    clobPassphrase?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessToken?: SortOrder
    telegramIntegrationId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderIdProviderAccountIdCompoundUniqueInput = {
    providerId: string
    providerAccountId: string
  }

  export type AccountProviderIdAccountIdCompoundUniqueInput = {
    providerId: string
    accountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    providerId?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    refreshToken?: SortOrder
    access_token?: SortOrder
    accessToken?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    idToken?: SortOrder
    session_state?: SortOrder
    accessTokenExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessionToken?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    providerId?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    refreshToken?: SortOrder
    access_token?: SortOrder
    accessToken?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    idToken?: SortOrder
    session_state?: SortOrder
    accessTokenExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessionToken?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    providerId?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    refreshToken?: SortOrder
    access_token?: SortOrder
    accessToken?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    idToken?: SortOrder
    session_state?: SortOrder
    accessTokenExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessionToken?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationIdentifierValueCompoundUniqueInput = {
    identifier: string
    value: string
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NotificationLogListRelationFilter = {
    every?: NotificationLogWhereInput
    some?: NotificationLogWhereInput
    none?: NotificationLogWhereInput
  }

  export type MonitoredWalletNullableScalarRelationFilter = {
    is?: MonitoredWalletWhereInput | null
    isNot?: MonitoredWalletWhereInput | null
  }

  export type NotificationLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    walletAddress?: SortOrder
    tradeType?: SortOrder
    minAmount?: SortOrder
    market?: SortOrder
    notifyVia?: SortOrder
    telegramNotify?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    walletAddress?: SortOrder
    tradeType?: SortOrder
    minAmount?: SortOrder
    market?: SortOrder
    notifyVia?: SortOrder
    telegramNotify?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    walletAddress?: SortOrder
    tradeType?: SortOrder
    minAmount?: SortOrder
    market?: SortOrder
    notifyVia?: SortOrder
    telegramNotify?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type TelegramIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    chatId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type TelegramIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    chatId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type TelegramIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    chatId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AlertScalarRelationFilter = {
    is?: AlertWhereInput
    isNot?: AlertWhereInput
  }

  export type MonitoredWalletCountOrderByAggregateInput = {
    id?: SortOrder
    proxyWallet?: SortOrder
    alertId?: SortOrder
    lastActivityTimestamp?: SortOrder
    lastActivityHash?: SortOrder
    totalActivities?: SortOrder
    lastCheckedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonitoredWalletAvgOrderByAggregateInput = {
    lastActivityTimestamp?: SortOrder
    totalActivities?: SortOrder
  }

  export type MonitoredWalletMaxOrderByAggregateInput = {
    id?: SortOrder
    proxyWallet?: SortOrder
    alertId?: SortOrder
    lastActivityTimestamp?: SortOrder
    lastActivityHash?: SortOrder
    totalActivities?: SortOrder
    lastCheckedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonitoredWalletMinOrderByAggregateInput = {
    id?: SortOrder
    proxyWallet?: SortOrder
    alertId?: SortOrder
    lastActivityTimestamp?: SortOrder
    lastActivityHash?: SortOrder
    totalActivities?: SortOrder
    lastCheckedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonitoredWalletSumOrderByAggregateInput = {
    lastActivityTimestamp?: SortOrder
    totalActivities?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type PolymarketActivityCountOrderByAggregateInput = {
    id?: SortOrder
    proxyWallet?: SortOrder
    timestamp?: SortOrder
    conditionId?: SortOrder
    type?: SortOrder
    size?: SortOrder
    usdcSize?: SortOrder
    transactionHash?: SortOrder
    price?: SortOrder
    asset?: SortOrder
    side?: SortOrder
    outcomeIndex?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    eventSlug?: SortOrder
    outcome?: SortOrder
    processed?: SortOrder
    notificationSent?: SortOrder
    createdAt?: SortOrder
  }

  export type PolymarketActivityAvgOrderByAggregateInput = {
    timestamp?: SortOrder
    size?: SortOrder
    usdcSize?: SortOrder
    price?: SortOrder
    outcomeIndex?: SortOrder
  }

  export type PolymarketActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    proxyWallet?: SortOrder
    timestamp?: SortOrder
    conditionId?: SortOrder
    type?: SortOrder
    size?: SortOrder
    usdcSize?: SortOrder
    transactionHash?: SortOrder
    price?: SortOrder
    asset?: SortOrder
    side?: SortOrder
    outcomeIndex?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    eventSlug?: SortOrder
    outcome?: SortOrder
    processed?: SortOrder
    notificationSent?: SortOrder
    createdAt?: SortOrder
  }

  export type PolymarketActivityMinOrderByAggregateInput = {
    id?: SortOrder
    proxyWallet?: SortOrder
    timestamp?: SortOrder
    conditionId?: SortOrder
    type?: SortOrder
    size?: SortOrder
    usdcSize?: SortOrder
    transactionHash?: SortOrder
    price?: SortOrder
    asset?: SortOrder
    side?: SortOrder
    outcomeIndex?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    eventSlug?: SortOrder
    outcome?: SortOrder
    processed?: SortOrder
    notificationSent?: SortOrder
    createdAt?: SortOrder
  }

  export type PolymarketActivitySumOrderByAggregateInput = {
    timestamp?: SortOrder
    size?: SortOrder
    usdcSize?: SortOrder
    price?: SortOrder
    outcomeIndex?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type MonitoringJobLogCountOrderByAggregateInput = {
    id?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    walletsChecked?: SortOrder
    activitiesFound?: SortOrder
    activitiesProcessed?: SortOrder
    notificationsQueued?: SortOrder
    duration?: SortOrder
    error?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type MonitoringJobLogAvgOrderByAggregateInput = {
    walletsChecked?: SortOrder
    activitiesFound?: SortOrder
    activitiesProcessed?: SortOrder
    notificationsQueued?: SortOrder
    duration?: SortOrder
  }

  export type MonitoringJobLogMaxOrderByAggregateInput = {
    id?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    walletsChecked?: SortOrder
    activitiesFound?: SortOrder
    activitiesProcessed?: SortOrder
    notificationsQueued?: SortOrder
    duration?: SortOrder
    error?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type MonitoringJobLogMinOrderByAggregateInput = {
    id?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    walletsChecked?: SortOrder
    activitiesFound?: SortOrder
    activitiesProcessed?: SortOrder
    notificationsQueued?: SortOrder
    duration?: SortOrder
    error?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type MonitoringJobLogSumOrderByAggregateInput = {
    walletsChecked?: SortOrder
    activitiesFound?: SortOrder
    activitiesProcessed?: SortOrder
    notificationsQueued?: SortOrder
    duration?: SortOrder
  }

  export type EnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NotificationQueueCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    alertId?: SortOrder
    walletAddress?: SortOrder
    activityId?: SortOrder
    tradeType?: SortOrder
    amount?: SortOrder
    market?: SortOrder
    marketId?: SortOrder
    marketUrl?: SortOrder
    marketIcon?: SortOrder
    notifyVia?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    error?: SortOrder
    scheduledFor?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationQueueAvgOrderByAggregateInput = {
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type NotificationQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    alertId?: SortOrder
    walletAddress?: SortOrder
    activityId?: SortOrder
    tradeType?: SortOrder
    amount?: SortOrder
    market?: SortOrder
    marketId?: SortOrder
    marketUrl?: SortOrder
    marketIcon?: SortOrder
    notifyVia?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    error?: SortOrder
    scheduledFor?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationQueueMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    alertId?: SortOrder
    walletAddress?: SortOrder
    activityId?: SortOrder
    tradeType?: SortOrder
    amount?: SortOrder
    market?: SortOrder
    marketId?: SortOrder
    marketUrl?: SortOrder
    marketIcon?: SortOrder
    notifyVia?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    error?: SortOrder
    scheduledFor?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationQueueSumOrderByAggregateInput = {
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type EnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type NotificationLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    alertId?: SortOrder
    walletAddress?: SortOrder
    activityId?: SortOrder
    tradeType?: SortOrder
    amount?: SortOrder
    market?: SortOrder
    notifyVia?: SortOrder
    status?: SortOrder
    error?: SortOrder
    sentAt?: SortOrder
  }

  export type NotificationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    alertId?: SortOrder
    walletAddress?: SortOrder
    activityId?: SortOrder
    tradeType?: SortOrder
    amount?: SortOrder
    market?: SortOrder
    notifyVia?: SortOrder
    status?: SortOrder
    error?: SortOrder
    sentAt?: SortOrder
  }

  export type NotificationLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    alertId?: SortOrder
    walletAddress?: SortOrder
    activityId?: SortOrder
    tradeType?: SortOrder
    amount?: SortOrder
    market?: SortOrder
    notifyVia?: SortOrder
    status?: SortOrder
    error?: SortOrder
    sentAt?: SortOrder
  }

  export type CronJobLogCountOrderByAggregateInput = {
    id?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    processed?: SortOrder
    failed?: SortOrder
    duration?: SortOrder
    error?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CronJobLogAvgOrderByAggregateInput = {
    processed?: SortOrder
    failed?: SortOrder
    duration?: SortOrder
  }

  export type CronJobLogMaxOrderByAggregateInput = {
    id?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    processed?: SortOrder
    failed?: SortOrder
    duration?: SortOrder
    error?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CronJobLogMinOrderByAggregateInput = {
    id?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    processed?: SortOrder
    failed?: SortOrder
    duration?: SortOrder
    error?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CronJobLogSumOrderByAggregateInput = {
    processed?: SortOrder
    failed?: SortOrder
    duration?: SortOrder
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    isFavorite?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    isFavorite?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    isFavorite?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    images?: SortOrder
    completed?: SortOrder
    marketData?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type RulesMessageListRelationFilter = {
    every?: RulesMessageWhereInput
    some?: RulesMessageWhereInput
    none?: RulesMessageWhereInput
  }

  export type RulesMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RulesConversationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    isFavorite?: SortOrder
    updatedAt?: SortOrder
  }

  export type RulesConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    isFavorite?: SortOrder
    updatedAt?: SortOrder
  }

  export type RulesConversationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    isFavorite?: SortOrder
    updatedAt?: SortOrder
  }

  export type RulesConversationScalarRelationFilter = {
    is?: RulesConversationWhereInput
    isNot?: RulesConversationWhereInput
  }

  export type RulesMessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    images?: SortOrder
    completed?: SortOrder
    marketData?: SortOrder
    createdAt?: SortOrder
  }

  export type RulesMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
  }

  export type RulesMessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
  }

  export type WatchListCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    marketId?: SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrder
    frequency?: SortOrder
    isActive?: SortOrder
    isEmailNotification?: SortOrder
    isTelegramNotification?: SortOrder
    lastNotifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WatchListAvgOrderByAggregateInput = {
    triggerValue?: SortOrder
  }

  export type WatchListMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    marketId?: SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrder
    frequency?: SortOrder
    isActive?: SortOrder
    isEmailNotification?: SortOrder
    isTelegramNotification?: SortOrder
    lastNotifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WatchListMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    marketId?: SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrder
    frequency?: SortOrder
    isActive?: SortOrder
    isEmailNotification?: SortOrder
    isTelegramNotification?: SortOrder
    lastNotifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WatchListSumOrderByAggregateInput = {
    triggerValue?: SortOrder
  }

  export type FloatNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    has?: number | FloatFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListFloatFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListFloatFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type MarketCountOrderByAggregateInput = {
    id?: SortOrder
    conditionId?: SortOrder
    marketId?: SortOrder
    question?: SortOrder
    slug?: SortOrder
    liquidity?: SortOrder
    volume?: SortOrder
    volume24hr?: SortOrder
    active?: SortOrder
    closed?: SortOrder
    archived?: SortOrder
    image?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    outcomes?: SortOrder
    outcomePrices?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketAvgOrderByAggregateInput = {
    liquidity?: SortOrder
    volume?: SortOrder
    volume24hr?: SortOrder
    outcomePrices?: SortOrder
  }

  export type MarketMaxOrderByAggregateInput = {
    id?: SortOrder
    conditionId?: SortOrder
    marketId?: SortOrder
    question?: SortOrder
    slug?: SortOrder
    liquidity?: SortOrder
    volume?: SortOrder
    volume24hr?: SortOrder
    active?: SortOrder
    closed?: SortOrder
    archived?: SortOrder
    image?: SortOrder
    category?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketMinOrderByAggregateInput = {
    id?: SortOrder
    conditionId?: SortOrder
    marketId?: SortOrder
    question?: SortOrder
    slug?: SortOrder
    liquidity?: SortOrder
    volume?: SortOrder
    volume24hr?: SortOrder
    active?: SortOrder
    closed?: SortOrder
    archived?: SortOrder
    image?: SortOrder
    category?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketSumOrderByAggregateInput = {
    liquidity?: SortOrder
    volume?: SortOrder
    volume24hr?: SortOrder
    outcomePrices?: SortOrder
  }

  export type ProxyWalletCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type ProxyWalletMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type ProxyWalletMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusFilter<$PrismaModel> | $Enums.SyncStatus
  }

  export type SyncHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    marketsFound?: SortOrder
    marketsStored?: SortOrder
    marketsFailed?: SortOrder
    walletsFound?: SortOrder
    walletsStored?: SortOrder
    status?: SortOrder
    error?: SortOrder
  }

  export type SyncHistoryAvgOrderByAggregateInput = {
    marketsFound?: SortOrder
    marketsStored?: SortOrder
    marketsFailed?: SortOrder
    walletsFound?: SortOrder
    walletsStored?: SortOrder
  }

  export type SyncHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    marketsFound?: SortOrder
    marketsStored?: SortOrder
    marketsFailed?: SortOrder
    walletsFound?: SortOrder
    walletsStored?: SortOrder
    status?: SortOrder
    error?: SortOrder
  }

  export type SyncHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    marketsFound?: SortOrder
    marketsStored?: SortOrder
    marketsFailed?: SortOrder
    walletsFound?: SortOrder
    walletsStored?: SortOrder
    status?: SortOrder
    error?: SortOrder
  }

  export type SyncHistorySumOrderByAggregateInput = {
    marketsFound?: SortOrder
    marketsStored?: SortOrder
    marketsFailed?: SortOrder
    walletsFound?: SortOrder
    walletsStored?: SortOrder
  }

  export type EnumSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumSyncStatusFilter<$PrismaModel>
  }

  export type MarketDistributionListRelationFilter = {
    every?: MarketDistributionWhereInput
    some?: MarketDistributionWhereInput
    none?: MarketDistributionWhereInput
  }

  export type BuySellDataNullableScalarRelationFilter = {
    is?: BuySellDataWhereInput | null
    isNot?: BuySellDataWhereInput | null
  }

  export type TradeSizeDataNullableScalarRelationFilter = {
    is?: TradeSizeDataWhereInput | null
    isNot?: TradeSizeDataWhereInput | null
  }

  export type PriceStatsNullableScalarRelationFilter = {
    is?: PriceStatsWhereInput | null
    isNot?: PriceStatsWhereInput | null
  }

  export type MonthlyPerformanceListRelationFilter = {
    every?: MonthlyPerformanceWhereInput
    some?: MonthlyPerformanceWhereInput
    none?: MonthlyPerformanceWhereInput
  }

  export type WeeklyWinRateListRelationFilter = {
    every?: WeeklyWinRateWhereInput
    some?: WeeklyWinRateWhereInput
    none?: WeeklyWinRateWhereInput
  }

  export type MarketDistributionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MonthlyPerformanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeeklyWinRateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    totalVolume?: SortOrder
    totalProfit?: SortOrder
    positionValue?: SortOrder
    totalTrades?: SortOrder
    totalPositions?: SortOrder
    averageWinRate?: SortOrder
    avgMonthlyProfit?: SortOrder
    avgMonthlyTrades?: SortOrder
    mostTradedCategory?: SortOrder
    tradingStyle?: SortOrder
    riskProfile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncedAt?: SortOrder
  }

  export type UserAnalyticsAvgOrderByAggregateInput = {
    totalVolume?: SortOrder
    totalProfit?: SortOrder
    positionValue?: SortOrder
    totalTrades?: SortOrder
    totalPositions?: SortOrder
    averageWinRate?: SortOrder
    avgMonthlyProfit?: SortOrder
    avgMonthlyTrades?: SortOrder
  }

  export type UserAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    totalVolume?: SortOrder
    totalProfit?: SortOrder
    positionValue?: SortOrder
    totalTrades?: SortOrder
    totalPositions?: SortOrder
    averageWinRate?: SortOrder
    avgMonthlyProfit?: SortOrder
    avgMonthlyTrades?: SortOrder
    mostTradedCategory?: SortOrder
    tradingStyle?: SortOrder
    riskProfile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncedAt?: SortOrder
  }

  export type UserAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    totalVolume?: SortOrder
    totalProfit?: SortOrder
    positionValue?: SortOrder
    totalTrades?: SortOrder
    totalPositions?: SortOrder
    averageWinRate?: SortOrder
    avgMonthlyProfit?: SortOrder
    avgMonthlyTrades?: SortOrder
    mostTradedCategory?: SortOrder
    tradingStyle?: SortOrder
    riskProfile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncedAt?: SortOrder
  }

  export type UserAnalyticsSumOrderByAggregateInput = {
    totalVolume?: SortOrder
    totalProfit?: SortOrder
    positionValue?: SortOrder
    totalTrades?: SortOrder
    totalPositions?: SortOrder
    averageWinRate?: SortOrder
    avgMonthlyProfit?: SortOrder
    avgMonthlyTrades?: SortOrder
  }

  export type UserAnalyticsScalarRelationFilter = {
    is?: UserAnalyticsWhereInput
    isNot?: UserAnalyticsWhereInput
  }

  export type MarketDistributionUserIdMarketCompoundUniqueInput = {
    userId: string
    market: string
  }

  export type MarketDistributionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    market?: SortOrder
    value?: SortOrder
    trades?: SortOrder
    volume?: SortOrder
    uniqueMarkets?: SortOrder
    createdAt?: SortOrder
  }

  export type MarketDistributionAvgOrderByAggregateInput = {
    value?: SortOrder
    trades?: SortOrder
    volume?: SortOrder
    uniqueMarkets?: SortOrder
  }

  export type MarketDistributionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    market?: SortOrder
    value?: SortOrder
    trades?: SortOrder
    volume?: SortOrder
    uniqueMarkets?: SortOrder
    createdAt?: SortOrder
  }

  export type MarketDistributionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    market?: SortOrder
    value?: SortOrder
    trades?: SortOrder
    volume?: SortOrder
    uniqueMarkets?: SortOrder
    createdAt?: SortOrder
  }

  export type MarketDistributionSumOrderByAggregateInput = {
    value?: SortOrder
    trades?: SortOrder
    volume?: SortOrder
    uniqueMarkets?: SortOrder
  }

  export type BuySellDataCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    buyPercentage?: SortOrder
    sellPercentage?: SortOrder
    buyVolume?: SortOrder
    sellVolume?: SortOrder
    buyCount?: SortOrder
    sellCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuySellDataAvgOrderByAggregateInput = {
    buyPercentage?: SortOrder
    sellPercentage?: SortOrder
    buyVolume?: SortOrder
    sellVolume?: SortOrder
    buyCount?: SortOrder
    sellCount?: SortOrder
  }

  export type BuySellDataMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    buyPercentage?: SortOrder
    sellPercentage?: SortOrder
    buyVolume?: SortOrder
    sellVolume?: SortOrder
    buyCount?: SortOrder
    sellCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuySellDataMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    buyPercentage?: SortOrder
    sellPercentage?: SortOrder
    buyVolume?: SortOrder
    sellVolume?: SortOrder
    buyCount?: SortOrder
    sellCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuySellDataSumOrderByAggregateInput = {
    buyPercentage?: SortOrder
    sellPercentage?: SortOrder
    buyVolume?: SortOrder
    sellVolume?: SortOrder
    buyCount?: SortOrder
    sellCount?: SortOrder
  }

  export type TradeSizeDataCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    averageSize?: SortOrder
    medianSize?: SortOrder
    minSize?: SortOrder
    maxSize?: SortOrder
    smallTrades?: SortOrder
    mediumTrades?: SortOrder
    largeTrades?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradeSizeDataAvgOrderByAggregateInput = {
    averageSize?: SortOrder
    medianSize?: SortOrder
    minSize?: SortOrder
    maxSize?: SortOrder
    smallTrades?: SortOrder
    mediumTrades?: SortOrder
    largeTrades?: SortOrder
  }

  export type TradeSizeDataMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    averageSize?: SortOrder
    medianSize?: SortOrder
    minSize?: SortOrder
    maxSize?: SortOrder
    smallTrades?: SortOrder
    mediumTrades?: SortOrder
    largeTrades?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradeSizeDataMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    averageSize?: SortOrder
    medianSize?: SortOrder
    minSize?: SortOrder
    maxSize?: SortOrder
    smallTrades?: SortOrder
    mediumTrades?: SortOrder
    largeTrades?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradeSizeDataSumOrderByAggregateInput = {
    averageSize?: SortOrder
    medianSize?: SortOrder
    minSize?: SortOrder
    maxSize?: SortOrder
    smallTrades?: SortOrder
    mediumTrades?: SortOrder
    largeTrades?: SortOrder
  }

  export type PriceStatsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    averagePrice?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceStatsAvgOrderByAggregateInput = {
    averagePrice?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
  }

  export type PriceStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    averagePrice?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceStatsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    averagePrice?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceStatsSumOrderByAggregateInput = {
    averagePrice?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
  }

  export type MonthlyPerformanceUserIdYearMonthCompoundUniqueInput = {
    userId: string
    yearMonth: string
  }

  export type MonthlyPerformanceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    yearMonth?: SortOrder
    profit?: SortOrder
    volume?: SortOrder
    trades?: SortOrder
    createdAt?: SortOrder
  }

  export type MonthlyPerformanceAvgOrderByAggregateInput = {
    profit?: SortOrder
    volume?: SortOrder
    trades?: SortOrder
  }

  export type MonthlyPerformanceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    yearMonth?: SortOrder
    profit?: SortOrder
    volume?: SortOrder
    trades?: SortOrder
    createdAt?: SortOrder
  }

  export type MonthlyPerformanceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    yearMonth?: SortOrder
    profit?: SortOrder
    volume?: SortOrder
    trades?: SortOrder
    createdAt?: SortOrder
  }

  export type MonthlyPerformanceSumOrderByAggregateInput = {
    profit?: SortOrder
    volume?: SortOrder
    trades?: SortOrder
  }

  export type WeeklyWinRateUserIdWeekDateCompoundUniqueInput = {
    userId: string
    weekDate: Date | string
  }

  export type WeeklyWinRateCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    week?: SortOrder
    weekDate?: SortOrder
    winRate?: SortOrder
    totalTrades?: SortOrder
    createdAt?: SortOrder
  }

  export type WeeklyWinRateAvgOrderByAggregateInput = {
    winRate?: SortOrder
    totalTrades?: SortOrder
  }

  export type WeeklyWinRateMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    week?: SortOrder
    weekDate?: SortOrder
    winRate?: SortOrder
    totalTrades?: SortOrder
    createdAt?: SortOrder
  }

  export type WeeklyWinRateMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    week?: SortOrder
    weekDate?: SortOrder
    winRate?: SortOrder
    totalTrades?: SortOrder
    createdAt?: SortOrder
  }

  export type WeeklyWinRateSumOrderByAggregateInput = {
    winRate?: SortOrder
    totalTrades?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type BlogPostCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    tagsArray?: SortOrder
    thumbnail?: SortOrder
    featured?: SortOrder
    readTime?: SortOrder
    published?: SortOrder
    authorUserId?: SortOrder
    content?: SortOrder
    tags?: SortOrder
    author?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    thumbnail?: SortOrder
    featured?: SortOrder
    readTime?: SortOrder
    published?: SortOrder
    authorUserId?: SortOrder
    content?: SortOrder
    tags?: SortOrder
    author?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    thumbnail?: SortOrder
    featured?: SortOrder
    readTime?: SortOrder
    published?: SortOrder
    authorUserId?: SortOrder
    content?: SortOrder
    tags?: SortOrder
    author?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    walletAddress?: SortOrder
    tradeType?: SortOrder
    amount?: SortOrder
    market?: SortOrder
    timestamp?: SortOrder
    read?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    walletAddress?: SortOrder
    tradeType?: SortOrder
    amount?: SortOrder
    market?: SortOrder
    timestamp?: SortOrder
    read?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    walletAddress?: SortOrder
    tradeType?: SortOrder
    amount?: SortOrder
    market?: SortOrder
    timestamp?: SortOrder
    read?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type BlogPostCreateNestedManyWithoutAuthorUserInput = {
    create?: XOR<BlogPostCreateWithoutAuthorUserInput, BlogPostUncheckedCreateWithoutAuthorUserInput> | BlogPostCreateWithoutAuthorUserInput[] | BlogPostUncheckedCreateWithoutAuthorUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorUserInput | BlogPostCreateOrConnectWithoutAuthorUserInput[]
    createMany?: BlogPostCreateManyAuthorUserInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type TelegramIntegrationCreateNestedOneWithoutCreatedByInput = {
    create?: XOR<TelegramIntegrationCreateWithoutCreatedByInput, TelegramIntegrationUncheckedCreateWithoutCreatedByInput>
    connectOrCreate?: TelegramIntegrationCreateOrConnectWithoutCreatedByInput
    connect?: TelegramIntegrationWhereUniqueInput
  }

  export type WatchListCreateNestedManyWithoutUserInput = {
    create?: XOR<WatchListCreateWithoutUserInput, WatchListUncheckedCreateWithoutUserInput> | WatchListCreateWithoutUserInput[] | WatchListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchListCreateOrConnectWithoutUserInput | WatchListCreateOrConnectWithoutUserInput[]
    createMany?: WatchListCreateManyUserInputEnvelope
    connect?: WatchListWhereUniqueInput | WatchListWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type RulesConversationCreateNestedManyWithoutUserInput = {
    create?: XOR<RulesConversationCreateWithoutUserInput, RulesConversationUncheckedCreateWithoutUserInput> | RulesConversationCreateWithoutUserInput[] | RulesConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RulesConversationCreateOrConnectWithoutUserInput | RulesConversationCreateOrConnectWithoutUserInput[]
    createMany?: RulesConversationCreateManyUserInputEnvelope
    connect?: RulesConversationWhereUniqueInput | RulesConversationWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutAuthorUserInput = {
    create?: XOR<BlogPostCreateWithoutAuthorUserInput, BlogPostUncheckedCreateWithoutAuthorUserInput> | BlogPostCreateWithoutAuthorUserInput[] | BlogPostUncheckedCreateWithoutAuthorUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorUserInput | BlogPostCreateOrConnectWithoutAuthorUserInput[]
    createMany?: BlogPostCreateManyAuthorUserInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type TelegramIntegrationUncheckedCreateNestedOneWithoutCreatedByInput = {
    create?: XOR<TelegramIntegrationCreateWithoutCreatedByInput, TelegramIntegrationUncheckedCreateWithoutCreatedByInput>
    connectOrCreate?: TelegramIntegrationCreateOrConnectWithoutCreatedByInput
    connect?: TelegramIntegrationWhereUniqueInput
  }

  export type WatchListUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WatchListCreateWithoutUserInput, WatchListUncheckedCreateWithoutUserInput> | WatchListCreateWithoutUserInput[] | WatchListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchListCreateOrConnectWithoutUserInput | WatchListCreateOrConnectWithoutUserInput[]
    createMany?: WatchListCreateManyUserInputEnvelope
    connect?: WatchListWhereUniqueInput | WatchListWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type RulesConversationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RulesConversationCreateWithoutUserInput, RulesConversationUncheckedCreateWithoutUserInput> | RulesConversationCreateWithoutUserInput[] | RulesConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RulesConversationCreateOrConnectWithoutUserInput | RulesConversationCreateOrConnectWithoutUserInput[]
    createMany?: RulesConversationCreateManyUserInputEnvelope
    connect?: RulesConversationWhereUniqueInput | RulesConversationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type BlogPostUpdateManyWithoutAuthorUserNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorUserInput, BlogPostUncheckedCreateWithoutAuthorUserInput> | BlogPostCreateWithoutAuthorUserInput[] | BlogPostUncheckedCreateWithoutAuthorUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorUserInput | BlogPostCreateOrConnectWithoutAuthorUserInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorUserInput | BlogPostUpsertWithWhereUniqueWithoutAuthorUserInput[]
    createMany?: BlogPostCreateManyAuthorUserInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorUserInput | BlogPostUpdateWithWhereUniqueWithoutAuthorUserInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorUserInput | BlogPostUpdateManyWithWhereWithoutAuthorUserInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type TelegramIntegrationUpdateOneWithoutCreatedByNestedInput = {
    create?: XOR<TelegramIntegrationCreateWithoutCreatedByInput, TelegramIntegrationUncheckedCreateWithoutCreatedByInput>
    connectOrCreate?: TelegramIntegrationCreateOrConnectWithoutCreatedByInput
    upsert?: TelegramIntegrationUpsertWithoutCreatedByInput
    disconnect?: TelegramIntegrationWhereInput | boolean
    delete?: TelegramIntegrationWhereInput | boolean
    connect?: TelegramIntegrationWhereUniqueInput
    update?: XOR<XOR<TelegramIntegrationUpdateToOneWithWhereWithoutCreatedByInput, TelegramIntegrationUpdateWithoutCreatedByInput>, TelegramIntegrationUncheckedUpdateWithoutCreatedByInput>
  }

  export type WatchListUpdateManyWithoutUserNestedInput = {
    create?: XOR<WatchListCreateWithoutUserInput, WatchListUncheckedCreateWithoutUserInput> | WatchListCreateWithoutUserInput[] | WatchListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchListCreateOrConnectWithoutUserInput | WatchListCreateOrConnectWithoutUserInput[]
    upsert?: WatchListUpsertWithWhereUniqueWithoutUserInput | WatchListUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WatchListCreateManyUserInputEnvelope
    set?: WatchListWhereUniqueInput | WatchListWhereUniqueInput[]
    disconnect?: WatchListWhereUniqueInput | WatchListWhereUniqueInput[]
    delete?: WatchListWhereUniqueInput | WatchListWhereUniqueInput[]
    connect?: WatchListWhereUniqueInput | WatchListWhereUniqueInput[]
    update?: WatchListUpdateWithWhereUniqueWithoutUserInput | WatchListUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WatchListUpdateManyWithWhereWithoutUserInput | WatchListUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WatchListScalarWhereInput | WatchListScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type RulesConversationUpdateManyWithoutUserNestedInput = {
    create?: XOR<RulesConversationCreateWithoutUserInput, RulesConversationUncheckedCreateWithoutUserInput> | RulesConversationCreateWithoutUserInput[] | RulesConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RulesConversationCreateOrConnectWithoutUserInput | RulesConversationCreateOrConnectWithoutUserInput[]
    upsert?: RulesConversationUpsertWithWhereUniqueWithoutUserInput | RulesConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RulesConversationCreateManyUserInputEnvelope
    set?: RulesConversationWhereUniqueInput | RulesConversationWhereUniqueInput[]
    disconnect?: RulesConversationWhereUniqueInput | RulesConversationWhereUniqueInput[]
    delete?: RulesConversationWhereUniqueInput | RulesConversationWhereUniqueInput[]
    connect?: RulesConversationWhereUniqueInput | RulesConversationWhereUniqueInput[]
    update?: RulesConversationUpdateWithWhereUniqueWithoutUserInput | RulesConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RulesConversationUpdateManyWithWhereWithoutUserInput | RulesConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RulesConversationScalarWhereInput | RulesConversationScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorUserNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorUserInput, BlogPostUncheckedCreateWithoutAuthorUserInput> | BlogPostCreateWithoutAuthorUserInput[] | BlogPostUncheckedCreateWithoutAuthorUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorUserInput | BlogPostCreateOrConnectWithoutAuthorUserInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorUserInput | BlogPostUpsertWithWhereUniqueWithoutAuthorUserInput[]
    createMany?: BlogPostCreateManyAuthorUserInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorUserInput | BlogPostUpdateWithWhereUniqueWithoutAuthorUserInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorUserInput | BlogPostUpdateManyWithWhereWithoutAuthorUserInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type TelegramIntegrationUncheckedUpdateOneWithoutCreatedByNestedInput = {
    create?: XOR<TelegramIntegrationCreateWithoutCreatedByInput, TelegramIntegrationUncheckedCreateWithoutCreatedByInput>
    connectOrCreate?: TelegramIntegrationCreateOrConnectWithoutCreatedByInput
    upsert?: TelegramIntegrationUpsertWithoutCreatedByInput
    disconnect?: TelegramIntegrationWhereInput | boolean
    delete?: TelegramIntegrationWhereInput | boolean
    connect?: TelegramIntegrationWhereUniqueInput
    update?: XOR<XOR<TelegramIntegrationUpdateToOneWithWhereWithoutCreatedByInput, TelegramIntegrationUpdateWithoutCreatedByInput>, TelegramIntegrationUncheckedUpdateWithoutCreatedByInput>
  }

  export type WatchListUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WatchListCreateWithoutUserInput, WatchListUncheckedCreateWithoutUserInput> | WatchListCreateWithoutUserInput[] | WatchListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchListCreateOrConnectWithoutUserInput | WatchListCreateOrConnectWithoutUserInput[]
    upsert?: WatchListUpsertWithWhereUniqueWithoutUserInput | WatchListUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WatchListCreateManyUserInputEnvelope
    set?: WatchListWhereUniqueInput | WatchListWhereUniqueInput[]
    disconnect?: WatchListWhereUniqueInput | WatchListWhereUniqueInput[]
    delete?: WatchListWhereUniqueInput | WatchListWhereUniqueInput[]
    connect?: WatchListWhereUniqueInput | WatchListWhereUniqueInput[]
    update?: WatchListUpdateWithWhereUniqueWithoutUserInput | WatchListUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WatchListUpdateManyWithWhereWithoutUserInput | WatchListUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WatchListScalarWhereInput | WatchListScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type RulesConversationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RulesConversationCreateWithoutUserInput, RulesConversationUncheckedCreateWithoutUserInput> | RulesConversationCreateWithoutUserInput[] | RulesConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RulesConversationCreateOrConnectWithoutUserInput | RulesConversationCreateOrConnectWithoutUserInput[]
    upsert?: RulesConversationUpsertWithWhereUniqueWithoutUserInput | RulesConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RulesConversationCreateManyUserInputEnvelope
    set?: RulesConversationWhereUniqueInput | RulesConversationWhereUniqueInput[]
    disconnect?: RulesConversationWhereUniqueInput | RulesConversationWhereUniqueInput[]
    delete?: RulesConversationWhereUniqueInput | RulesConversationWhereUniqueInput[]
    connect?: RulesConversationWhereUniqueInput | RulesConversationWhereUniqueInput[]
    update?: RulesConversationUpdateWithWhereUniqueWithoutUserInput | RulesConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RulesConversationUpdateManyWithWhereWithoutUserInput | RulesConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RulesConversationScalarWhereInput | RulesConversationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type NotificationLogCreateNestedManyWithoutAlertInput = {
    create?: XOR<NotificationLogCreateWithoutAlertInput, NotificationLogUncheckedCreateWithoutAlertInput> | NotificationLogCreateWithoutAlertInput[] | NotificationLogUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutAlertInput | NotificationLogCreateOrConnectWithoutAlertInput[]
    createMany?: NotificationLogCreateManyAlertInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type MonitoredWalletCreateNestedOneWithoutAlertInput = {
    create?: XOR<MonitoredWalletCreateWithoutAlertInput, MonitoredWalletUncheckedCreateWithoutAlertInput>
    connectOrCreate?: MonitoredWalletCreateOrConnectWithoutAlertInput
    connect?: MonitoredWalletWhereUniqueInput
  }

  export type NotificationLogUncheckedCreateNestedManyWithoutAlertInput = {
    create?: XOR<NotificationLogCreateWithoutAlertInput, NotificationLogUncheckedCreateWithoutAlertInput> | NotificationLogCreateWithoutAlertInput[] | NotificationLogUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutAlertInput | NotificationLogCreateOrConnectWithoutAlertInput[]
    createMany?: NotificationLogCreateManyAlertInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type MonitoredWalletUncheckedCreateNestedOneWithoutAlertInput = {
    create?: XOR<MonitoredWalletCreateWithoutAlertInput, MonitoredWalletUncheckedCreateWithoutAlertInput>
    connectOrCreate?: MonitoredWalletCreateOrConnectWithoutAlertInput
    connect?: MonitoredWalletWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NotificationLogUpdateManyWithoutAlertNestedInput = {
    create?: XOR<NotificationLogCreateWithoutAlertInput, NotificationLogUncheckedCreateWithoutAlertInput> | NotificationLogCreateWithoutAlertInput[] | NotificationLogUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutAlertInput | NotificationLogCreateOrConnectWithoutAlertInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutAlertInput | NotificationLogUpsertWithWhereUniqueWithoutAlertInput[]
    createMany?: NotificationLogCreateManyAlertInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutAlertInput | NotificationLogUpdateWithWhereUniqueWithoutAlertInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutAlertInput | NotificationLogUpdateManyWithWhereWithoutAlertInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type MonitoredWalletUpdateOneWithoutAlertNestedInput = {
    create?: XOR<MonitoredWalletCreateWithoutAlertInput, MonitoredWalletUncheckedCreateWithoutAlertInput>
    connectOrCreate?: MonitoredWalletCreateOrConnectWithoutAlertInput
    upsert?: MonitoredWalletUpsertWithoutAlertInput
    disconnect?: MonitoredWalletWhereInput | boolean
    delete?: MonitoredWalletWhereInput | boolean
    connect?: MonitoredWalletWhereUniqueInput
    update?: XOR<XOR<MonitoredWalletUpdateToOneWithWhereWithoutAlertInput, MonitoredWalletUpdateWithoutAlertInput>, MonitoredWalletUncheckedUpdateWithoutAlertInput>
  }

  export type NotificationLogUncheckedUpdateManyWithoutAlertNestedInput = {
    create?: XOR<NotificationLogCreateWithoutAlertInput, NotificationLogUncheckedCreateWithoutAlertInput> | NotificationLogCreateWithoutAlertInput[] | NotificationLogUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutAlertInput | NotificationLogCreateOrConnectWithoutAlertInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutAlertInput | NotificationLogUpsertWithWhereUniqueWithoutAlertInput[]
    createMany?: NotificationLogCreateManyAlertInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutAlertInput | NotificationLogUpdateWithWhereUniqueWithoutAlertInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutAlertInput | NotificationLogUpdateManyWithWhereWithoutAlertInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type MonitoredWalletUncheckedUpdateOneWithoutAlertNestedInput = {
    create?: XOR<MonitoredWalletCreateWithoutAlertInput, MonitoredWalletUncheckedCreateWithoutAlertInput>
    connectOrCreate?: MonitoredWalletCreateOrConnectWithoutAlertInput
    upsert?: MonitoredWalletUpsertWithoutAlertInput
    disconnect?: MonitoredWalletWhereInput | boolean
    delete?: MonitoredWalletWhereInput | boolean
    connect?: MonitoredWalletWhereUniqueInput
    update?: XOR<XOR<MonitoredWalletUpdateToOneWithWhereWithoutAlertInput, MonitoredWalletUpdateWithoutAlertInput>, MonitoredWalletUncheckedUpdateWithoutAlertInput>
  }

  export type UserCreateNestedOneWithoutTelegramIntegrationInput = {
    create?: XOR<UserCreateWithoutTelegramIntegrationInput, UserUncheckedCreateWithoutTelegramIntegrationInput>
    connectOrCreate?: UserCreateOrConnectWithoutTelegramIntegrationInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTelegramIntegrationNestedInput = {
    create?: XOR<UserCreateWithoutTelegramIntegrationInput, UserUncheckedCreateWithoutTelegramIntegrationInput>
    connectOrCreate?: UserCreateOrConnectWithoutTelegramIntegrationInput
    upsert?: UserUpsertWithoutTelegramIntegrationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTelegramIntegrationInput, UserUpdateWithoutTelegramIntegrationInput>, UserUncheckedUpdateWithoutTelegramIntegrationInput>
  }

  export type AlertCreateNestedOneWithoutMonitoredWalletInput = {
    create?: XOR<AlertCreateWithoutMonitoredWalletInput, AlertUncheckedCreateWithoutMonitoredWalletInput>
    connectOrCreate?: AlertCreateOrConnectWithoutMonitoredWalletInput
    connect?: AlertWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AlertUpdateOneRequiredWithoutMonitoredWalletNestedInput = {
    create?: XOR<AlertCreateWithoutMonitoredWalletInput, AlertUncheckedCreateWithoutMonitoredWalletInput>
    connectOrCreate?: AlertCreateOrConnectWithoutMonitoredWalletInput
    upsert?: AlertUpsertWithoutMonitoredWalletInput
    connect?: AlertWhereUniqueInput
    update?: XOR<XOR<AlertUpdateToOneWithWhereWithoutMonitoredWalletInput, AlertUpdateWithoutMonitoredWalletInput>, AlertUncheckedUpdateWithoutMonitoredWalletInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus
  }

  export type AlertCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<AlertCreateWithoutNotificationsInput, AlertUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AlertCreateOrConnectWithoutNotificationsInput
    connect?: AlertWhereUniqueInput
  }

  export type AlertUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<AlertCreateWithoutNotificationsInput, AlertUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AlertCreateOrConnectWithoutNotificationsInput
    upsert?: AlertUpsertWithoutNotificationsInput
    connect?: AlertWhereUniqueInput
    update?: XOR<XOR<AlertUpdateToOneWithWhereWithoutNotificationsInput, AlertUpdateWithoutNotificationsInput>, AlertUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutConversationsInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    upsert?: UserUpsertWithoutConversationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationsInput, UserUpdateWithoutConversationsInput>, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageCreateimagesInput = {
    set: string[]
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type MessageUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutRulesConversationsInput = {
    create?: XOR<UserCreateWithoutRulesConversationsInput, UserUncheckedCreateWithoutRulesConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRulesConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type RulesMessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<RulesMessageCreateWithoutConversationInput, RulesMessageUncheckedCreateWithoutConversationInput> | RulesMessageCreateWithoutConversationInput[] | RulesMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: RulesMessageCreateOrConnectWithoutConversationInput | RulesMessageCreateOrConnectWithoutConversationInput[]
    createMany?: RulesMessageCreateManyConversationInputEnvelope
    connect?: RulesMessageWhereUniqueInput | RulesMessageWhereUniqueInput[]
  }

  export type RulesMessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<RulesMessageCreateWithoutConversationInput, RulesMessageUncheckedCreateWithoutConversationInput> | RulesMessageCreateWithoutConversationInput[] | RulesMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: RulesMessageCreateOrConnectWithoutConversationInput | RulesMessageCreateOrConnectWithoutConversationInput[]
    createMany?: RulesMessageCreateManyConversationInputEnvelope
    connect?: RulesMessageWhereUniqueInput | RulesMessageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutRulesConversationsNestedInput = {
    create?: XOR<UserCreateWithoutRulesConversationsInput, UserUncheckedCreateWithoutRulesConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRulesConversationsInput
    upsert?: UserUpsertWithoutRulesConversationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRulesConversationsInput, UserUpdateWithoutRulesConversationsInput>, UserUncheckedUpdateWithoutRulesConversationsInput>
  }

  export type RulesMessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<RulesMessageCreateWithoutConversationInput, RulesMessageUncheckedCreateWithoutConversationInput> | RulesMessageCreateWithoutConversationInput[] | RulesMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: RulesMessageCreateOrConnectWithoutConversationInput | RulesMessageCreateOrConnectWithoutConversationInput[]
    upsert?: RulesMessageUpsertWithWhereUniqueWithoutConversationInput | RulesMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: RulesMessageCreateManyConversationInputEnvelope
    set?: RulesMessageWhereUniqueInput | RulesMessageWhereUniqueInput[]
    disconnect?: RulesMessageWhereUniqueInput | RulesMessageWhereUniqueInput[]
    delete?: RulesMessageWhereUniqueInput | RulesMessageWhereUniqueInput[]
    connect?: RulesMessageWhereUniqueInput | RulesMessageWhereUniqueInput[]
    update?: RulesMessageUpdateWithWhereUniqueWithoutConversationInput | RulesMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: RulesMessageUpdateManyWithWhereWithoutConversationInput | RulesMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: RulesMessageScalarWhereInput | RulesMessageScalarWhereInput[]
  }

  export type RulesMessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<RulesMessageCreateWithoutConversationInput, RulesMessageUncheckedCreateWithoutConversationInput> | RulesMessageCreateWithoutConversationInput[] | RulesMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: RulesMessageCreateOrConnectWithoutConversationInput | RulesMessageCreateOrConnectWithoutConversationInput[]
    upsert?: RulesMessageUpsertWithWhereUniqueWithoutConversationInput | RulesMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: RulesMessageCreateManyConversationInputEnvelope
    set?: RulesMessageWhereUniqueInput | RulesMessageWhereUniqueInput[]
    disconnect?: RulesMessageWhereUniqueInput | RulesMessageWhereUniqueInput[]
    delete?: RulesMessageWhereUniqueInput | RulesMessageWhereUniqueInput[]
    connect?: RulesMessageWhereUniqueInput | RulesMessageWhereUniqueInput[]
    update?: RulesMessageUpdateWithWhereUniqueWithoutConversationInput | RulesMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: RulesMessageUpdateManyWithWhereWithoutConversationInput | RulesMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: RulesMessageScalarWhereInput | RulesMessageScalarWhereInput[]
  }

  export type RulesMessageCreateimagesInput = {
    set: string[]
  }

  export type RulesConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<RulesConversationCreateWithoutMessagesInput, RulesConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: RulesConversationCreateOrConnectWithoutMessagesInput
    connect?: RulesConversationWhereUniqueInput
  }

  export type RulesMessageUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RulesConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<RulesConversationCreateWithoutMessagesInput, RulesConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: RulesConversationCreateOrConnectWithoutMessagesInput
    upsert?: RulesConversationUpsertWithoutMessagesInput
    connect?: RulesConversationWhereUniqueInput
    update?: XOR<XOR<RulesConversationUpdateToOneWithWhereWithoutMessagesInput, RulesConversationUpdateWithoutMessagesInput>, RulesConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutWatchListsInput = {
    create?: XOR<UserCreateWithoutWatchListsInput, UserUncheckedCreateWithoutWatchListsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWatchListsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWatchListsNestedInput = {
    create?: XOR<UserCreateWithoutWatchListsInput, UserUncheckedCreateWithoutWatchListsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWatchListsInput
    upsert?: UserUpsertWithoutWatchListsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWatchListsInput, UserUpdateWithoutWatchListsInput>, UserUncheckedUpdateWithoutWatchListsInput>
  }

  export type MarketCreatetagsInput = {
    set: string[]
  }

  export type MarketCreateoutcomesInput = {
    set: string[]
  }

  export type MarketCreateoutcomePricesInput = {
    set: number[]
  }

  export type MarketUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MarketUpdateoutcomesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MarketUpdateoutcomePricesInput = {
    set?: number[]
    push?: number | number[]
  }

  export type EnumSyncStatusFieldUpdateOperationsInput = {
    set?: $Enums.SyncStatus
  }

  export type MarketDistributionCreateNestedManyWithoutUserInput = {
    create?: XOR<MarketDistributionCreateWithoutUserInput, MarketDistributionUncheckedCreateWithoutUserInput> | MarketDistributionCreateWithoutUserInput[] | MarketDistributionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MarketDistributionCreateOrConnectWithoutUserInput | MarketDistributionCreateOrConnectWithoutUserInput[]
    createMany?: MarketDistributionCreateManyUserInputEnvelope
    connect?: MarketDistributionWhereUniqueInput | MarketDistributionWhereUniqueInput[]
  }

  export type BuySellDataCreateNestedOneWithoutUserInput = {
    create?: XOR<BuySellDataCreateWithoutUserInput, BuySellDataUncheckedCreateWithoutUserInput>
    connectOrCreate?: BuySellDataCreateOrConnectWithoutUserInput
    connect?: BuySellDataWhereUniqueInput
  }

  export type TradeSizeDataCreateNestedOneWithoutUserInput = {
    create?: XOR<TradeSizeDataCreateWithoutUserInput, TradeSizeDataUncheckedCreateWithoutUserInput>
    connectOrCreate?: TradeSizeDataCreateOrConnectWithoutUserInput
    connect?: TradeSizeDataWhereUniqueInput
  }

  export type PriceStatsCreateNestedOneWithoutUserInput = {
    create?: XOR<PriceStatsCreateWithoutUserInput, PriceStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: PriceStatsCreateOrConnectWithoutUserInput
    connect?: PriceStatsWhereUniqueInput
  }

  export type MonthlyPerformanceCreateNestedManyWithoutUserInput = {
    create?: XOR<MonthlyPerformanceCreateWithoutUserInput, MonthlyPerformanceUncheckedCreateWithoutUserInput> | MonthlyPerformanceCreateWithoutUserInput[] | MonthlyPerformanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MonthlyPerformanceCreateOrConnectWithoutUserInput | MonthlyPerformanceCreateOrConnectWithoutUserInput[]
    createMany?: MonthlyPerformanceCreateManyUserInputEnvelope
    connect?: MonthlyPerformanceWhereUniqueInput | MonthlyPerformanceWhereUniqueInput[]
  }

  export type WeeklyWinRateCreateNestedManyWithoutUserInput = {
    create?: XOR<WeeklyWinRateCreateWithoutUserInput, WeeklyWinRateUncheckedCreateWithoutUserInput> | WeeklyWinRateCreateWithoutUserInput[] | WeeklyWinRateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeeklyWinRateCreateOrConnectWithoutUserInput | WeeklyWinRateCreateOrConnectWithoutUserInput[]
    createMany?: WeeklyWinRateCreateManyUserInputEnvelope
    connect?: WeeklyWinRateWhereUniqueInput | WeeklyWinRateWhereUniqueInput[]
  }

  export type MarketDistributionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MarketDistributionCreateWithoutUserInput, MarketDistributionUncheckedCreateWithoutUserInput> | MarketDistributionCreateWithoutUserInput[] | MarketDistributionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MarketDistributionCreateOrConnectWithoutUserInput | MarketDistributionCreateOrConnectWithoutUserInput[]
    createMany?: MarketDistributionCreateManyUserInputEnvelope
    connect?: MarketDistributionWhereUniqueInput | MarketDistributionWhereUniqueInput[]
  }

  export type BuySellDataUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<BuySellDataCreateWithoutUserInput, BuySellDataUncheckedCreateWithoutUserInput>
    connectOrCreate?: BuySellDataCreateOrConnectWithoutUserInput
    connect?: BuySellDataWhereUniqueInput
  }

  export type TradeSizeDataUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TradeSizeDataCreateWithoutUserInput, TradeSizeDataUncheckedCreateWithoutUserInput>
    connectOrCreate?: TradeSizeDataCreateOrConnectWithoutUserInput
    connect?: TradeSizeDataWhereUniqueInput
  }

  export type PriceStatsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PriceStatsCreateWithoutUserInput, PriceStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: PriceStatsCreateOrConnectWithoutUserInput
    connect?: PriceStatsWhereUniqueInput
  }

  export type MonthlyPerformanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MonthlyPerformanceCreateWithoutUserInput, MonthlyPerformanceUncheckedCreateWithoutUserInput> | MonthlyPerformanceCreateWithoutUserInput[] | MonthlyPerformanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MonthlyPerformanceCreateOrConnectWithoutUserInput | MonthlyPerformanceCreateOrConnectWithoutUserInput[]
    createMany?: MonthlyPerformanceCreateManyUserInputEnvelope
    connect?: MonthlyPerformanceWhereUniqueInput | MonthlyPerformanceWhereUniqueInput[]
  }

  export type WeeklyWinRateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WeeklyWinRateCreateWithoutUserInput, WeeklyWinRateUncheckedCreateWithoutUserInput> | WeeklyWinRateCreateWithoutUserInput[] | WeeklyWinRateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeeklyWinRateCreateOrConnectWithoutUserInput | WeeklyWinRateCreateOrConnectWithoutUserInput[]
    createMany?: WeeklyWinRateCreateManyUserInputEnvelope
    connect?: WeeklyWinRateWhereUniqueInput | WeeklyWinRateWhereUniqueInput[]
  }

  export type MarketDistributionUpdateManyWithoutUserNestedInput = {
    create?: XOR<MarketDistributionCreateWithoutUserInput, MarketDistributionUncheckedCreateWithoutUserInput> | MarketDistributionCreateWithoutUserInput[] | MarketDistributionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MarketDistributionCreateOrConnectWithoutUserInput | MarketDistributionCreateOrConnectWithoutUserInput[]
    upsert?: MarketDistributionUpsertWithWhereUniqueWithoutUserInput | MarketDistributionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MarketDistributionCreateManyUserInputEnvelope
    set?: MarketDistributionWhereUniqueInput | MarketDistributionWhereUniqueInput[]
    disconnect?: MarketDistributionWhereUniqueInput | MarketDistributionWhereUniqueInput[]
    delete?: MarketDistributionWhereUniqueInput | MarketDistributionWhereUniqueInput[]
    connect?: MarketDistributionWhereUniqueInput | MarketDistributionWhereUniqueInput[]
    update?: MarketDistributionUpdateWithWhereUniqueWithoutUserInput | MarketDistributionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MarketDistributionUpdateManyWithWhereWithoutUserInput | MarketDistributionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MarketDistributionScalarWhereInput | MarketDistributionScalarWhereInput[]
  }

  export type BuySellDataUpdateOneWithoutUserNestedInput = {
    create?: XOR<BuySellDataCreateWithoutUserInput, BuySellDataUncheckedCreateWithoutUserInput>
    connectOrCreate?: BuySellDataCreateOrConnectWithoutUserInput
    upsert?: BuySellDataUpsertWithoutUserInput
    disconnect?: BuySellDataWhereInput | boolean
    delete?: BuySellDataWhereInput | boolean
    connect?: BuySellDataWhereUniqueInput
    update?: XOR<XOR<BuySellDataUpdateToOneWithWhereWithoutUserInput, BuySellDataUpdateWithoutUserInput>, BuySellDataUncheckedUpdateWithoutUserInput>
  }

  export type TradeSizeDataUpdateOneWithoutUserNestedInput = {
    create?: XOR<TradeSizeDataCreateWithoutUserInput, TradeSizeDataUncheckedCreateWithoutUserInput>
    connectOrCreate?: TradeSizeDataCreateOrConnectWithoutUserInput
    upsert?: TradeSizeDataUpsertWithoutUserInput
    disconnect?: TradeSizeDataWhereInput | boolean
    delete?: TradeSizeDataWhereInput | boolean
    connect?: TradeSizeDataWhereUniqueInput
    update?: XOR<XOR<TradeSizeDataUpdateToOneWithWhereWithoutUserInput, TradeSizeDataUpdateWithoutUserInput>, TradeSizeDataUncheckedUpdateWithoutUserInput>
  }

  export type PriceStatsUpdateOneWithoutUserNestedInput = {
    create?: XOR<PriceStatsCreateWithoutUserInput, PriceStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: PriceStatsCreateOrConnectWithoutUserInput
    upsert?: PriceStatsUpsertWithoutUserInput
    disconnect?: PriceStatsWhereInput | boolean
    delete?: PriceStatsWhereInput | boolean
    connect?: PriceStatsWhereUniqueInput
    update?: XOR<XOR<PriceStatsUpdateToOneWithWhereWithoutUserInput, PriceStatsUpdateWithoutUserInput>, PriceStatsUncheckedUpdateWithoutUserInput>
  }

  export type MonthlyPerformanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<MonthlyPerformanceCreateWithoutUserInput, MonthlyPerformanceUncheckedCreateWithoutUserInput> | MonthlyPerformanceCreateWithoutUserInput[] | MonthlyPerformanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MonthlyPerformanceCreateOrConnectWithoutUserInput | MonthlyPerformanceCreateOrConnectWithoutUserInput[]
    upsert?: MonthlyPerformanceUpsertWithWhereUniqueWithoutUserInput | MonthlyPerformanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MonthlyPerformanceCreateManyUserInputEnvelope
    set?: MonthlyPerformanceWhereUniqueInput | MonthlyPerformanceWhereUniqueInput[]
    disconnect?: MonthlyPerformanceWhereUniqueInput | MonthlyPerformanceWhereUniqueInput[]
    delete?: MonthlyPerformanceWhereUniqueInput | MonthlyPerformanceWhereUniqueInput[]
    connect?: MonthlyPerformanceWhereUniqueInput | MonthlyPerformanceWhereUniqueInput[]
    update?: MonthlyPerformanceUpdateWithWhereUniqueWithoutUserInput | MonthlyPerformanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MonthlyPerformanceUpdateManyWithWhereWithoutUserInput | MonthlyPerformanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MonthlyPerformanceScalarWhereInput | MonthlyPerformanceScalarWhereInput[]
  }

  export type WeeklyWinRateUpdateManyWithoutUserNestedInput = {
    create?: XOR<WeeklyWinRateCreateWithoutUserInput, WeeklyWinRateUncheckedCreateWithoutUserInput> | WeeklyWinRateCreateWithoutUserInput[] | WeeklyWinRateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeeklyWinRateCreateOrConnectWithoutUserInput | WeeklyWinRateCreateOrConnectWithoutUserInput[]
    upsert?: WeeklyWinRateUpsertWithWhereUniqueWithoutUserInput | WeeklyWinRateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WeeklyWinRateCreateManyUserInputEnvelope
    set?: WeeklyWinRateWhereUniqueInput | WeeklyWinRateWhereUniqueInput[]
    disconnect?: WeeklyWinRateWhereUniqueInput | WeeklyWinRateWhereUniqueInput[]
    delete?: WeeklyWinRateWhereUniqueInput | WeeklyWinRateWhereUniqueInput[]
    connect?: WeeklyWinRateWhereUniqueInput | WeeklyWinRateWhereUniqueInput[]
    update?: WeeklyWinRateUpdateWithWhereUniqueWithoutUserInput | WeeklyWinRateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WeeklyWinRateUpdateManyWithWhereWithoutUserInput | WeeklyWinRateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WeeklyWinRateScalarWhereInput | WeeklyWinRateScalarWhereInput[]
  }

  export type MarketDistributionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MarketDistributionCreateWithoutUserInput, MarketDistributionUncheckedCreateWithoutUserInput> | MarketDistributionCreateWithoutUserInput[] | MarketDistributionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MarketDistributionCreateOrConnectWithoutUserInput | MarketDistributionCreateOrConnectWithoutUserInput[]
    upsert?: MarketDistributionUpsertWithWhereUniqueWithoutUserInput | MarketDistributionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MarketDistributionCreateManyUserInputEnvelope
    set?: MarketDistributionWhereUniqueInput | MarketDistributionWhereUniqueInput[]
    disconnect?: MarketDistributionWhereUniqueInput | MarketDistributionWhereUniqueInput[]
    delete?: MarketDistributionWhereUniqueInput | MarketDistributionWhereUniqueInput[]
    connect?: MarketDistributionWhereUniqueInput | MarketDistributionWhereUniqueInput[]
    update?: MarketDistributionUpdateWithWhereUniqueWithoutUserInput | MarketDistributionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MarketDistributionUpdateManyWithWhereWithoutUserInput | MarketDistributionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MarketDistributionScalarWhereInput | MarketDistributionScalarWhereInput[]
  }

  export type BuySellDataUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<BuySellDataCreateWithoutUserInput, BuySellDataUncheckedCreateWithoutUserInput>
    connectOrCreate?: BuySellDataCreateOrConnectWithoutUserInput
    upsert?: BuySellDataUpsertWithoutUserInput
    disconnect?: BuySellDataWhereInput | boolean
    delete?: BuySellDataWhereInput | boolean
    connect?: BuySellDataWhereUniqueInput
    update?: XOR<XOR<BuySellDataUpdateToOneWithWhereWithoutUserInput, BuySellDataUpdateWithoutUserInput>, BuySellDataUncheckedUpdateWithoutUserInput>
  }

  export type TradeSizeDataUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TradeSizeDataCreateWithoutUserInput, TradeSizeDataUncheckedCreateWithoutUserInput>
    connectOrCreate?: TradeSizeDataCreateOrConnectWithoutUserInput
    upsert?: TradeSizeDataUpsertWithoutUserInput
    disconnect?: TradeSizeDataWhereInput | boolean
    delete?: TradeSizeDataWhereInput | boolean
    connect?: TradeSizeDataWhereUniqueInput
    update?: XOR<XOR<TradeSizeDataUpdateToOneWithWhereWithoutUserInput, TradeSizeDataUpdateWithoutUserInput>, TradeSizeDataUncheckedUpdateWithoutUserInput>
  }

  export type PriceStatsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PriceStatsCreateWithoutUserInput, PriceStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: PriceStatsCreateOrConnectWithoutUserInput
    upsert?: PriceStatsUpsertWithoutUserInput
    disconnect?: PriceStatsWhereInput | boolean
    delete?: PriceStatsWhereInput | boolean
    connect?: PriceStatsWhereUniqueInput
    update?: XOR<XOR<PriceStatsUpdateToOneWithWhereWithoutUserInput, PriceStatsUpdateWithoutUserInput>, PriceStatsUncheckedUpdateWithoutUserInput>
  }

  export type MonthlyPerformanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MonthlyPerformanceCreateWithoutUserInput, MonthlyPerformanceUncheckedCreateWithoutUserInput> | MonthlyPerformanceCreateWithoutUserInput[] | MonthlyPerformanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MonthlyPerformanceCreateOrConnectWithoutUserInput | MonthlyPerformanceCreateOrConnectWithoutUserInput[]
    upsert?: MonthlyPerformanceUpsertWithWhereUniqueWithoutUserInput | MonthlyPerformanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MonthlyPerformanceCreateManyUserInputEnvelope
    set?: MonthlyPerformanceWhereUniqueInput | MonthlyPerformanceWhereUniqueInput[]
    disconnect?: MonthlyPerformanceWhereUniqueInput | MonthlyPerformanceWhereUniqueInput[]
    delete?: MonthlyPerformanceWhereUniqueInput | MonthlyPerformanceWhereUniqueInput[]
    connect?: MonthlyPerformanceWhereUniqueInput | MonthlyPerformanceWhereUniqueInput[]
    update?: MonthlyPerformanceUpdateWithWhereUniqueWithoutUserInput | MonthlyPerformanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MonthlyPerformanceUpdateManyWithWhereWithoutUserInput | MonthlyPerformanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MonthlyPerformanceScalarWhereInput | MonthlyPerformanceScalarWhereInput[]
  }

  export type WeeklyWinRateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WeeklyWinRateCreateWithoutUserInput, WeeklyWinRateUncheckedCreateWithoutUserInput> | WeeklyWinRateCreateWithoutUserInput[] | WeeklyWinRateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeeklyWinRateCreateOrConnectWithoutUserInput | WeeklyWinRateCreateOrConnectWithoutUserInput[]
    upsert?: WeeklyWinRateUpsertWithWhereUniqueWithoutUserInput | WeeklyWinRateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WeeklyWinRateCreateManyUserInputEnvelope
    set?: WeeklyWinRateWhereUniqueInput | WeeklyWinRateWhereUniqueInput[]
    disconnect?: WeeklyWinRateWhereUniqueInput | WeeklyWinRateWhereUniqueInput[]
    delete?: WeeklyWinRateWhereUniqueInput | WeeklyWinRateWhereUniqueInput[]
    connect?: WeeklyWinRateWhereUniqueInput | WeeklyWinRateWhereUniqueInput[]
    update?: WeeklyWinRateUpdateWithWhereUniqueWithoutUserInput | WeeklyWinRateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WeeklyWinRateUpdateManyWithWhereWithoutUserInput | WeeklyWinRateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WeeklyWinRateScalarWhereInput | WeeklyWinRateScalarWhereInput[]
  }

  export type UserAnalyticsCreateNestedOneWithoutMarketDistributionInput = {
    create?: XOR<UserAnalyticsCreateWithoutMarketDistributionInput, UserAnalyticsUncheckedCreateWithoutMarketDistributionInput>
    connectOrCreate?: UserAnalyticsCreateOrConnectWithoutMarketDistributionInput
    connect?: UserAnalyticsWhereUniqueInput
  }

  export type UserAnalyticsUpdateOneRequiredWithoutMarketDistributionNestedInput = {
    create?: XOR<UserAnalyticsCreateWithoutMarketDistributionInput, UserAnalyticsUncheckedCreateWithoutMarketDistributionInput>
    connectOrCreate?: UserAnalyticsCreateOrConnectWithoutMarketDistributionInput
    upsert?: UserAnalyticsUpsertWithoutMarketDistributionInput
    connect?: UserAnalyticsWhereUniqueInput
    update?: XOR<XOR<UserAnalyticsUpdateToOneWithWhereWithoutMarketDistributionInput, UserAnalyticsUpdateWithoutMarketDistributionInput>, UserAnalyticsUncheckedUpdateWithoutMarketDistributionInput>
  }

  export type UserAnalyticsCreateNestedOneWithoutBuySellDataInput = {
    create?: XOR<UserAnalyticsCreateWithoutBuySellDataInput, UserAnalyticsUncheckedCreateWithoutBuySellDataInput>
    connectOrCreate?: UserAnalyticsCreateOrConnectWithoutBuySellDataInput
    connect?: UserAnalyticsWhereUniqueInput
  }

  export type UserAnalyticsUpdateOneRequiredWithoutBuySellDataNestedInput = {
    create?: XOR<UserAnalyticsCreateWithoutBuySellDataInput, UserAnalyticsUncheckedCreateWithoutBuySellDataInput>
    connectOrCreate?: UserAnalyticsCreateOrConnectWithoutBuySellDataInput
    upsert?: UserAnalyticsUpsertWithoutBuySellDataInput
    connect?: UserAnalyticsWhereUniqueInput
    update?: XOR<XOR<UserAnalyticsUpdateToOneWithWhereWithoutBuySellDataInput, UserAnalyticsUpdateWithoutBuySellDataInput>, UserAnalyticsUncheckedUpdateWithoutBuySellDataInput>
  }

  export type UserAnalyticsCreateNestedOneWithoutTradeSizeDataInput = {
    create?: XOR<UserAnalyticsCreateWithoutTradeSizeDataInput, UserAnalyticsUncheckedCreateWithoutTradeSizeDataInput>
    connectOrCreate?: UserAnalyticsCreateOrConnectWithoutTradeSizeDataInput
    connect?: UserAnalyticsWhereUniqueInput
  }

  export type UserAnalyticsUpdateOneRequiredWithoutTradeSizeDataNestedInput = {
    create?: XOR<UserAnalyticsCreateWithoutTradeSizeDataInput, UserAnalyticsUncheckedCreateWithoutTradeSizeDataInput>
    connectOrCreate?: UserAnalyticsCreateOrConnectWithoutTradeSizeDataInput
    upsert?: UserAnalyticsUpsertWithoutTradeSizeDataInput
    connect?: UserAnalyticsWhereUniqueInput
    update?: XOR<XOR<UserAnalyticsUpdateToOneWithWhereWithoutTradeSizeDataInput, UserAnalyticsUpdateWithoutTradeSizeDataInput>, UserAnalyticsUncheckedUpdateWithoutTradeSizeDataInput>
  }

  export type UserAnalyticsCreateNestedOneWithoutPriceStatsInput = {
    create?: XOR<UserAnalyticsCreateWithoutPriceStatsInput, UserAnalyticsUncheckedCreateWithoutPriceStatsInput>
    connectOrCreate?: UserAnalyticsCreateOrConnectWithoutPriceStatsInput
    connect?: UserAnalyticsWhereUniqueInput
  }

  export type UserAnalyticsUpdateOneRequiredWithoutPriceStatsNestedInput = {
    create?: XOR<UserAnalyticsCreateWithoutPriceStatsInput, UserAnalyticsUncheckedCreateWithoutPriceStatsInput>
    connectOrCreate?: UserAnalyticsCreateOrConnectWithoutPriceStatsInput
    upsert?: UserAnalyticsUpsertWithoutPriceStatsInput
    connect?: UserAnalyticsWhereUniqueInput
    update?: XOR<XOR<UserAnalyticsUpdateToOneWithWhereWithoutPriceStatsInput, UserAnalyticsUpdateWithoutPriceStatsInput>, UserAnalyticsUncheckedUpdateWithoutPriceStatsInput>
  }

  export type UserAnalyticsCreateNestedOneWithoutMonthlyPerformanceInput = {
    create?: XOR<UserAnalyticsCreateWithoutMonthlyPerformanceInput, UserAnalyticsUncheckedCreateWithoutMonthlyPerformanceInput>
    connectOrCreate?: UserAnalyticsCreateOrConnectWithoutMonthlyPerformanceInput
    connect?: UserAnalyticsWhereUniqueInput
  }

  export type UserAnalyticsUpdateOneRequiredWithoutMonthlyPerformanceNestedInput = {
    create?: XOR<UserAnalyticsCreateWithoutMonthlyPerformanceInput, UserAnalyticsUncheckedCreateWithoutMonthlyPerformanceInput>
    connectOrCreate?: UserAnalyticsCreateOrConnectWithoutMonthlyPerformanceInput
    upsert?: UserAnalyticsUpsertWithoutMonthlyPerformanceInput
    connect?: UserAnalyticsWhereUniqueInput
    update?: XOR<XOR<UserAnalyticsUpdateToOneWithWhereWithoutMonthlyPerformanceInput, UserAnalyticsUpdateWithoutMonthlyPerformanceInput>, UserAnalyticsUncheckedUpdateWithoutMonthlyPerformanceInput>
  }

  export type UserAnalyticsCreateNestedOneWithoutWeeklyWinRateInput = {
    create?: XOR<UserAnalyticsCreateWithoutWeeklyWinRateInput, UserAnalyticsUncheckedCreateWithoutWeeklyWinRateInput>
    connectOrCreate?: UserAnalyticsCreateOrConnectWithoutWeeklyWinRateInput
    connect?: UserAnalyticsWhereUniqueInput
  }

  export type UserAnalyticsUpdateOneRequiredWithoutWeeklyWinRateNestedInput = {
    create?: XOR<UserAnalyticsCreateWithoutWeeklyWinRateInput, UserAnalyticsUncheckedCreateWithoutWeeklyWinRateInput>
    connectOrCreate?: UserAnalyticsCreateOrConnectWithoutWeeklyWinRateInput
    upsert?: UserAnalyticsUpsertWithoutWeeklyWinRateInput
    connect?: UserAnalyticsWhereUniqueInput
    update?: XOR<XOR<UserAnalyticsUpdateToOneWithWhereWithoutWeeklyWinRateInput, UserAnalyticsUpdateWithoutWeeklyWinRateInput>, UserAnalyticsUncheckedUpdateWithoutWeeklyWinRateInput>
  }

  export type BlogPostCreatetagsArrayInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutBlogPostInput = {
    create?: XOR<UserCreateWithoutBlogPostInput, UserUncheckedCreateWithoutBlogPostInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostInput
    connect?: UserWhereUniqueInput
  }

  export type BlogPostUpdatetagsArrayInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutBlogPostNestedInput = {
    create?: XOR<UserCreateWithoutBlogPostInput, UserUncheckedCreateWithoutBlogPostInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostInput
    upsert?: UserUpsertWithoutBlogPostInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogPostInput, UserUpdateWithoutBlogPostInput>, UserUncheckedUpdateWithoutBlogPostInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusFilter<$PrismaModel> | $Enums.SyncStatus
  }

  export type NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumSyncStatusFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountId?: string | null
    type?: string | null
    providerId?: string | null
    providerAccountId?: string | null
    refresh_token?: string | null
    refreshToken?: string | null
    access_token?: string | null
    accessToken?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    idToken?: string | null
    session_state?: string | null
    accessTokenExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sessionToken?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId?: string | null
    type?: string | null
    providerId?: string | null
    providerAccountId?: string | null
    refresh_token?: string | null
    refreshToken?: string | null
    access_token?: string | null
    accessToken?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    idToken?: string | null
    session_state?: string | null
    accessTokenExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sessionToken?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken?: string | null
    token?: string | null
    expiresAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken?: string | null
    token?: string | null
    expiresAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostCreateWithoutAuthorUserInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    date?: Date | string | null
    tagsArray?: BlogPostCreatetagsArrayInput | string[]
    thumbnail?: string | null
    featured?: boolean
    readTime?: string | null
    published?: boolean
    content: string
    tags: string
    author?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUncheckedCreateWithoutAuthorUserInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    date?: Date | string | null
    tagsArray?: BlogPostCreatetagsArrayInput | string[]
    thumbnail?: string | null
    featured?: boolean
    readTime?: string | null
    published?: boolean
    content: string
    tags: string
    author?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostCreateOrConnectWithoutAuthorUserInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutAuthorUserInput, BlogPostUncheckedCreateWithoutAuthorUserInput>
  }

  export type BlogPostCreateManyAuthorUserInputEnvelope = {
    data: BlogPostCreateManyAuthorUserInput | BlogPostCreateManyAuthorUserInput[]
    skipDuplicates?: boolean
  }

  export type TelegramIntegrationCreateWithoutCreatedByInput = {
    id?: string
    userId: string
    userName: string
    chatId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramIntegrationUncheckedCreateWithoutCreatedByInput = {
    id?: string
    userId: string
    userName: string
    chatId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramIntegrationCreateOrConnectWithoutCreatedByInput = {
    where: TelegramIntegrationWhereUniqueInput
    create: XOR<TelegramIntegrationCreateWithoutCreatedByInput, TelegramIntegrationUncheckedCreateWithoutCreatedByInput>
  }

  export type WatchListCreateWithoutUserInput = {
    id?: string
    marketId: string
    triggerType: string
    triggerValue?: number | null
    frequency?: string
    isActive?: boolean
    isEmailNotification?: boolean
    isTelegramNotification?: boolean
    lastNotifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WatchListUncheckedCreateWithoutUserInput = {
    id?: string
    marketId: string
    triggerType: string
    triggerValue?: number | null
    frequency?: string
    isActive?: boolean
    isEmailNotification?: boolean
    isTelegramNotification?: boolean
    lastNotifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WatchListCreateOrConnectWithoutUserInput = {
    where: WatchListWhereUniqueInput
    create: XOR<WatchListCreateWithoutUserInput, WatchListUncheckedCreateWithoutUserInput>
  }

  export type WatchListCreateManyUserInputEnvelope = {
    data: WatchListCreateManyUserInput | WatchListCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutUserInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    isFavorite?: boolean
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutUserInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    isFavorite?: boolean
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutUserInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationCreateManyUserInputEnvelope = {
    data: ConversationCreateManyUserInput | ConversationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RulesConversationCreateWithoutUserInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    isFavorite?: boolean
    updatedAt?: Date | string
    messages?: RulesMessageCreateNestedManyWithoutConversationInput
  }

  export type RulesConversationUncheckedCreateWithoutUserInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    isFavorite?: boolean
    updatedAt?: Date | string
    messages?: RulesMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type RulesConversationCreateOrConnectWithoutUserInput = {
    where: RulesConversationWhereUniqueInput
    create: XOR<RulesConversationCreateWithoutUserInput, RulesConversationUncheckedCreateWithoutUserInput>
  }

  export type RulesConversationCreateManyUserInputEnvelope = {
    data: RulesConversationCreateManyUserInput | RulesConversationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringNullableFilter<"Account"> | string | null
    userId?: StringFilter<"Account"> | string
    type?: StringNullableFilter<"Account"> | string | null
    providerId?: StringNullableFilter<"Account"> | string | null
    providerAccountId?: StringNullableFilter<"Account"> | string | null
    refresh_token?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    accessToken?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    sessionToken?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringNullableFilter<"Session"> | string | null
    token?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type BlogPostUpsertWithWhereUniqueWithoutAuthorUserInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutAuthorUserInput, BlogPostUncheckedUpdateWithoutAuthorUserInput>
    create: XOR<BlogPostCreateWithoutAuthorUserInput, BlogPostUncheckedCreateWithoutAuthorUserInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutAuthorUserInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutAuthorUserInput, BlogPostUncheckedUpdateWithoutAuthorUserInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutAuthorUserInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutAuthorUserInput>
  }

  export type BlogPostScalarWhereInput = {
    AND?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    OR?: BlogPostScalarWhereInput[]
    NOT?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    slug?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    description?: StringNullableFilter<"BlogPost"> | string | null
    date?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    tagsArray?: StringNullableListFilter<"BlogPost">
    thumbnail?: StringNullableFilter<"BlogPost"> | string | null
    featured?: BoolFilter<"BlogPost"> | boolean
    readTime?: StringNullableFilter<"BlogPost"> | string | null
    published?: BoolFilter<"BlogPost"> | boolean
    authorUserId?: StringNullableFilter<"BlogPost"> | string | null
    content?: StringFilter<"BlogPost"> | string
    tags?: StringFilter<"BlogPost"> | string
    author?: StringNullableFilter<"BlogPost"> | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
  }

  export type TelegramIntegrationUpsertWithoutCreatedByInput = {
    update: XOR<TelegramIntegrationUpdateWithoutCreatedByInput, TelegramIntegrationUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TelegramIntegrationCreateWithoutCreatedByInput, TelegramIntegrationUncheckedCreateWithoutCreatedByInput>
    where?: TelegramIntegrationWhereInput
  }

  export type TelegramIntegrationUpdateToOneWithWhereWithoutCreatedByInput = {
    where?: TelegramIntegrationWhereInput
    data: XOR<TelegramIntegrationUpdateWithoutCreatedByInput, TelegramIntegrationUncheckedUpdateWithoutCreatedByInput>
  }

  export type TelegramIntegrationUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramIntegrationUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchListUpsertWithWhereUniqueWithoutUserInput = {
    where: WatchListWhereUniqueInput
    update: XOR<WatchListUpdateWithoutUserInput, WatchListUncheckedUpdateWithoutUserInput>
    create: XOR<WatchListCreateWithoutUserInput, WatchListUncheckedCreateWithoutUserInput>
  }

  export type WatchListUpdateWithWhereUniqueWithoutUserInput = {
    where: WatchListWhereUniqueInput
    data: XOR<WatchListUpdateWithoutUserInput, WatchListUncheckedUpdateWithoutUserInput>
  }

  export type WatchListUpdateManyWithWhereWithoutUserInput = {
    where: WatchListScalarWhereInput
    data: XOR<WatchListUpdateManyMutationInput, WatchListUncheckedUpdateManyWithoutUserInput>
  }

  export type WatchListScalarWhereInput = {
    AND?: WatchListScalarWhereInput | WatchListScalarWhereInput[]
    OR?: WatchListScalarWhereInput[]
    NOT?: WatchListScalarWhereInput | WatchListScalarWhereInput[]
    id?: StringFilter<"WatchList"> | string
    userId?: StringFilter<"WatchList"> | string
    marketId?: StringFilter<"WatchList"> | string
    triggerType?: StringFilter<"WatchList"> | string
    triggerValue?: FloatNullableFilter<"WatchList"> | number | null
    frequency?: StringFilter<"WatchList"> | string
    isActive?: BoolFilter<"WatchList"> | boolean
    isEmailNotification?: BoolFilter<"WatchList"> | boolean
    isTelegramNotification?: BoolFilter<"WatchList"> | boolean
    lastNotifiedAt?: DateTimeNullableFilter<"WatchList"> | Date | string | null
    createdAt?: DateTimeFilter<"WatchList"> | Date | string
    updatedAt?: DateTimeFilter<"WatchList"> | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
  }

  export type ConversationUpdateManyWithWhereWithoutUserInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutUserInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    userId?: StringFilter<"Conversation"> | string
    title?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    isFavorite?: BoolFilter<"Conversation"> | boolean
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
  }

  export type RulesConversationUpsertWithWhereUniqueWithoutUserInput = {
    where: RulesConversationWhereUniqueInput
    update: XOR<RulesConversationUpdateWithoutUserInput, RulesConversationUncheckedUpdateWithoutUserInput>
    create: XOR<RulesConversationCreateWithoutUserInput, RulesConversationUncheckedCreateWithoutUserInput>
  }

  export type RulesConversationUpdateWithWhereUniqueWithoutUserInput = {
    where: RulesConversationWhereUniqueInput
    data: XOR<RulesConversationUpdateWithoutUserInput, RulesConversationUncheckedUpdateWithoutUserInput>
  }

  export type RulesConversationUpdateManyWithWhereWithoutUserInput = {
    where: RulesConversationScalarWhereInput
    data: XOR<RulesConversationUpdateManyMutationInput, RulesConversationUncheckedUpdateManyWithoutUserInput>
  }

  export type RulesConversationScalarWhereInput = {
    AND?: RulesConversationScalarWhereInput | RulesConversationScalarWhereInput[]
    OR?: RulesConversationScalarWhereInput[]
    NOT?: RulesConversationScalarWhereInput | RulesConversationScalarWhereInput[]
    id?: StringFilter<"RulesConversation"> | string
    userId?: StringFilter<"RulesConversation"> | string
    title?: StringNullableFilter<"RulesConversation"> | string | null
    createdAt?: DateTimeFilter<"RulesConversation"> | Date | string
    isFavorite?: BoolFilter<"RulesConversation"> | boolean
    updatedAt?: DateTimeFilter<"RulesConversation"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    password?: string | null
    verifyToken?: string | null
    verifyTokenExpiry?: Date | string | null
    walletAddress?: string | null
    clobApiKey?: string | null
    clobSecret?: string | null
    clobPassphrase?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken?: string | null
    telegramIntegrationId?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    blogPost?: BlogPostCreateNestedManyWithoutAuthorUserInput
    telegramIntegration?: TelegramIntegrationCreateNestedOneWithoutCreatedByInput
    watchLists?: WatchListCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    rulesConversations?: RulesConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    password?: string | null
    verifyToken?: string | null
    verifyTokenExpiry?: Date | string | null
    walletAddress?: string | null
    clobApiKey?: string | null
    clobSecret?: string | null
    clobPassphrase?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken?: string | null
    telegramIntegrationId?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    blogPost?: BlogPostUncheckedCreateNestedManyWithoutAuthorUserInput
    telegramIntegration?: TelegramIntegrationUncheckedCreateNestedOneWithoutCreatedByInput
    watchLists?: WatchListUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    rulesConversations?: RulesConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clobApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    clobSecret?: NullableStringFieldUpdateOperationsInput | string | null
    clobPassphrase?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    telegramIntegrationId?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    blogPost?: BlogPostUpdateManyWithoutAuthorUserNestedInput
    telegramIntegration?: TelegramIntegrationUpdateOneWithoutCreatedByNestedInput
    watchLists?: WatchListUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    rulesConversations?: RulesConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clobApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    clobSecret?: NullableStringFieldUpdateOperationsInput | string | null
    clobPassphrase?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    telegramIntegrationId?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    blogPost?: BlogPostUncheckedUpdateManyWithoutAuthorUserNestedInput
    telegramIntegration?: TelegramIntegrationUncheckedUpdateOneWithoutCreatedByNestedInput
    watchLists?: WatchListUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    rulesConversations?: RulesConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    password?: string | null
    verifyToken?: string | null
    verifyTokenExpiry?: Date | string | null
    walletAddress?: string | null
    clobApiKey?: string | null
    clobSecret?: string | null
    clobPassphrase?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken?: string | null
    telegramIntegrationId?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    blogPost?: BlogPostCreateNestedManyWithoutAuthorUserInput
    telegramIntegration?: TelegramIntegrationCreateNestedOneWithoutCreatedByInput
    watchLists?: WatchListCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    rulesConversations?: RulesConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    password?: string | null
    verifyToken?: string | null
    verifyTokenExpiry?: Date | string | null
    walletAddress?: string | null
    clobApiKey?: string | null
    clobSecret?: string | null
    clobPassphrase?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken?: string | null
    telegramIntegrationId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    blogPost?: BlogPostUncheckedCreateNestedManyWithoutAuthorUserInput
    telegramIntegration?: TelegramIntegrationUncheckedCreateNestedOneWithoutCreatedByInput
    watchLists?: WatchListUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    rulesConversations?: RulesConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clobApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    clobSecret?: NullableStringFieldUpdateOperationsInput | string | null
    clobPassphrase?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    telegramIntegrationId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    blogPost?: BlogPostUpdateManyWithoutAuthorUserNestedInput
    telegramIntegration?: TelegramIntegrationUpdateOneWithoutCreatedByNestedInput
    watchLists?: WatchListUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    rulesConversations?: RulesConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clobApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    clobSecret?: NullableStringFieldUpdateOperationsInput | string | null
    clobPassphrase?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    telegramIntegrationId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    blogPost?: BlogPostUncheckedUpdateManyWithoutAuthorUserNestedInput
    telegramIntegration?: TelegramIntegrationUncheckedUpdateOneWithoutCreatedByNestedInput
    watchLists?: WatchListUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    rulesConversations?: RulesConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NotificationLogCreateWithoutAlertInput = {
    id?: string
    userId: string
    userEmail: string
    walletAddress: string
    activityId?: string | null
    tradeType: string
    amount: string
    market: string
    notifyVia: string
    status: string
    error?: string | null
    sentAt?: Date | string
  }

  export type NotificationLogUncheckedCreateWithoutAlertInput = {
    id?: string
    userId: string
    userEmail: string
    walletAddress: string
    activityId?: string | null
    tradeType: string
    amount: string
    market: string
    notifyVia: string
    status: string
    error?: string | null
    sentAt?: Date | string
  }

  export type NotificationLogCreateOrConnectWithoutAlertInput = {
    where: NotificationLogWhereUniqueInput
    create: XOR<NotificationLogCreateWithoutAlertInput, NotificationLogUncheckedCreateWithoutAlertInput>
  }

  export type NotificationLogCreateManyAlertInputEnvelope = {
    data: NotificationLogCreateManyAlertInput | NotificationLogCreateManyAlertInput[]
    skipDuplicates?: boolean
  }

  export type MonitoredWalletCreateWithoutAlertInput = {
    id?: string
    proxyWallet: string
    lastActivityTimestamp?: number | null
    lastActivityHash?: string | null
    totalActivities?: number
    lastCheckedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonitoredWalletUncheckedCreateWithoutAlertInput = {
    id?: string
    proxyWallet: string
    lastActivityTimestamp?: number | null
    lastActivityHash?: string | null
    totalActivities?: number
    lastCheckedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonitoredWalletCreateOrConnectWithoutAlertInput = {
    where: MonitoredWalletWhereUniqueInput
    create: XOR<MonitoredWalletCreateWithoutAlertInput, MonitoredWalletUncheckedCreateWithoutAlertInput>
  }

  export type NotificationLogUpsertWithWhereUniqueWithoutAlertInput = {
    where: NotificationLogWhereUniqueInput
    update: XOR<NotificationLogUpdateWithoutAlertInput, NotificationLogUncheckedUpdateWithoutAlertInput>
    create: XOR<NotificationLogCreateWithoutAlertInput, NotificationLogUncheckedCreateWithoutAlertInput>
  }

  export type NotificationLogUpdateWithWhereUniqueWithoutAlertInput = {
    where: NotificationLogWhereUniqueInput
    data: XOR<NotificationLogUpdateWithoutAlertInput, NotificationLogUncheckedUpdateWithoutAlertInput>
  }

  export type NotificationLogUpdateManyWithWhereWithoutAlertInput = {
    where: NotificationLogScalarWhereInput
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyWithoutAlertInput>
  }

  export type NotificationLogScalarWhereInput = {
    AND?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
    OR?: NotificationLogScalarWhereInput[]
    NOT?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
    id?: StringFilter<"NotificationLog"> | string
    userId?: StringFilter<"NotificationLog"> | string
    userEmail?: StringFilter<"NotificationLog"> | string
    alertId?: StringFilter<"NotificationLog"> | string
    walletAddress?: StringFilter<"NotificationLog"> | string
    activityId?: StringNullableFilter<"NotificationLog"> | string | null
    tradeType?: StringFilter<"NotificationLog"> | string
    amount?: StringFilter<"NotificationLog"> | string
    market?: StringFilter<"NotificationLog"> | string
    notifyVia?: StringFilter<"NotificationLog"> | string
    status?: StringFilter<"NotificationLog"> | string
    error?: StringNullableFilter<"NotificationLog"> | string | null
    sentAt?: DateTimeFilter<"NotificationLog"> | Date | string
  }

  export type MonitoredWalletUpsertWithoutAlertInput = {
    update: XOR<MonitoredWalletUpdateWithoutAlertInput, MonitoredWalletUncheckedUpdateWithoutAlertInput>
    create: XOR<MonitoredWalletCreateWithoutAlertInput, MonitoredWalletUncheckedCreateWithoutAlertInput>
    where?: MonitoredWalletWhereInput
  }

  export type MonitoredWalletUpdateToOneWithWhereWithoutAlertInput = {
    where?: MonitoredWalletWhereInput
    data: XOR<MonitoredWalletUpdateWithoutAlertInput, MonitoredWalletUncheckedUpdateWithoutAlertInput>
  }

  export type MonitoredWalletUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    proxyWallet?: StringFieldUpdateOperationsInput | string
    lastActivityTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    lastActivityHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalActivities?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitoredWalletUncheckedUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    proxyWallet?: StringFieldUpdateOperationsInput | string
    lastActivityTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    lastActivityHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalActivities?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutTelegramIntegrationInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    password?: string | null
    verifyToken?: string | null
    verifyTokenExpiry?: Date | string | null
    walletAddress?: string | null
    clobApiKey?: string | null
    clobSecret?: string | null
    clobPassphrase?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken?: string | null
    telegramIntegrationId?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    blogPost?: BlogPostCreateNestedManyWithoutAuthorUserInput
    watchLists?: WatchListCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    rulesConversations?: RulesConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTelegramIntegrationInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    password?: string | null
    verifyToken?: string | null
    verifyTokenExpiry?: Date | string | null
    walletAddress?: string | null
    clobApiKey?: string | null
    clobSecret?: string | null
    clobPassphrase?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken?: string | null
    telegramIntegrationId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    blogPost?: BlogPostUncheckedCreateNestedManyWithoutAuthorUserInput
    watchLists?: WatchListUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    rulesConversations?: RulesConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTelegramIntegrationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTelegramIntegrationInput, UserUncheckedCreateWithoutTelegramIntegrationInput>
  }

  export type UserUpsertWithoutTelegramIntegrationInput = {
    update: XOR<UserUpdateWithoutTelegramIntegrationInput, UserUncheckedUpdateWithoutTelegramIntegrationInput>
    create: XOR<UserCreateWithoutTelegramIntegrationInput, UserUncheckedCreateWithoutTelegramIntegrationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTelegramIntegrationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTelegramIntegrationInput, UserUncheckedUpdateWithoutTelegramIntegrationInput>
  }

  export type UserUpdateWithoutTelegramIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clobApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    clobSecret?: NullableStringFieldUpdateOperationsInput | string | null
    clobPassphrase?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    telegramIntegrationId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    blogPost?: BlogPostUpdateManyWithoutAuthorUserNestedInput
    watchLists?: WatchListUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    rulesConversations?: RulesConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTelegramIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clobApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    clobSecret?: NullableStringFieldUpdateOperationsInput | string | null
    clobPassphrase?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    telegramIntegrationId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    blogPost?: BlogPostUncheckedUpdateManyWithoutAuthorUserNestedInput
    watchLists?: WatchListUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    rulesConversations?: RulesConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AlertCreateWithoutMonitoredWalletInput = {
    id?: string
    userId: string
    userEmail: string
    walletAddress: string
    tradeType: string
    minAmount?: string | null
    market: string
    notifyVia: string
    telegramNotify?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationLogCreateNestedManyWithoutAlertInput
  }

  export type AlertUncheckedCreateWithoutMonitoredWalletInput = {
    id?: string
    userId: string
    userEmail: string
    walletAddress: string
    tradeType: string
    minAmount?: string | null
    market: string
    notifyVia: string
    telegramNotify?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationLogUncheckedCreateNestedManyWithoutAlertInput
  }

  export type AlertCreateOrConnectWithoutMonitoredWalletInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutMonitoredWalletInput, AlertUncheckedCreateWithoutMonitoredWalletInput>
  }

  export type AlertUpsertWithoutMonitoredWalletInput = {
    update: XOR<AlertUpdateWithoutMonitoredWalletInput, AlertUncheckedUpdateWithoutMonitoredWalletInput>
    create: XOR<AlertCreateWithoutMonitoredWalletInput, AlertUncheckedCreateWithoutMonitoredWalletInput>
    where?: AlertWhereInput
  }

  export type AlertUpdateToOneWithWhereWithoutMonitoredWalletInput = {
    where?: AlertWhereInput
    data: XOR<AlertUpdateWithoutMonitoredWalletInput, AlertUncheckedUpdateWithoutMonitoredWalletInput>
  }

  export type AlertUpdateWithoutMonitoredWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    tradeType?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    notifyVia?: StringFieldUpdateOperationsInput | string
    telegramNotify?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationLogUpdateManyWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateWithoutMonitoredWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    tradeType?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    notifyVia?: StringFieldUpdateOperationsInput | string
    telegramNotify?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationLogUncheckedUpdateManyWithoutAlertNestedInput
  }

  export type AlertCreateWithoutNotificationsInput = {
    id?: string
    userId: string
    userEmail: string
    walletAddress: string
    tradeType: string
    minAmount?: string | null
    market: string
    notifyVia: string
    telegramNotify?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    monitoredWallet?: MonitoredWalletCreateNestedOneWithoutAlertInput
  }

  export type AlertUncheckedCreateWithoutNotificationsInput = {
    id?: string
    userId: string
    userEmail: string
    walletAddress: string
    tradeType: string
    minAmount?: string | null
    market: string
    notifyVia: string
    telegramNotify?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    monitoredWallet?: MonitoredWalletUncheckedCreateNestedOneWithoutAlertInput
  }

  export type AlertCreateOrConnectWithoutNotificationsInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutNotificationsInput, AlertUncheckedCreateWithoutNotificationsInput>
  }

  export type AlertUpsertWithoutNotificationsInput = {
    update: XOR<AlertUpdateWithoutNotificationsInput, AlertUncheckedUpdateWithoutNotificationsInput>
    create: XOR<AlertCreateWithoutNotificationsInput, AlertUncheckedCreateWithoutNotificationsInput>
    where?: AlertWhereInput
  }

  export type AlertUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: AlertWhereInput
    data: XOR<AlertUpdateWithoutNotificationsInput, AlertUncheckedUpdateWithoutNotificationsInput>
  }

  export type AlertUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    tradeType?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    notifyVia?: StringFieldUpdateOperationsInput | string
    telegramNotify?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monitoredWallet?: MonitoredWalletUpdateOneWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    tradeType?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    notifyVia?: StringFieldUpdateOperationsInput | string
    telegramNotify?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monitoredWallet?: MonitoredWalletUncheckedUpdateOneWithoutAlertNestedInput
  }

  export type UserCreateWithoutConversationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    password?: string | null
    verifyToken?: string | null
    verifyTokenExpiry?: Date | string | null
    walletAddress?: string | null
    clobApiKey?: string | null
    clobSecret?: string | null
    clobPassphrase?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken?: string | null
    telegramIntegrationId?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    blogPost?: BlogPostCreateNestedManyWithoutAuthorUserInput
    telegramIntegration?: TelegramIntegrationCreateNestedOneWithoutCreatedByInput
    watchLists?: WatchListCreateNestedManyWithoutUserInput
    rulesConversations?: RulesConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConversationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    password?: string | null
    verifyToken?: string | null
    verifyTokenExpiry?: Date | string | null
    walletAddress?: string | null
    clobApiKey?: string | null
    clobSecret?: string | null
    clobPassphrase?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken?: string | null
    telegramIntegrationId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    blogPost?: BlogPostUncheckedCreateNestedManyWithoutAuthorUserInput
    telegramIntegration?: TelegramIntegrationUncheckedCreateNestedOneWithoutCreatedByInput
    watchLists?: WatchListUncheckedCreateNestedManyWithoutUserInput
    rulesConversations?: RulesConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    type: string
    content: string
    images?: MessageCreateimagesInput | string[]
    completed?: boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    type: string
    content: string
    images?: MessageCreateimagesInput | string[]
    completed?: boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutConversationsInput = {
    update: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clobApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    clobSecret?: NullableStringFieldUpdateOperationsInput | string | null
    clobPassphrase?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    telegramIntegrationId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    blogPost?: BlogPostUpdateManyWithoutAuthorUserNestedInput
    telegramIntegration?: TelegramIntegrationUpdateOneWithoutCreatedByNestedInput
    watchLists?: WatchListUpdateManyWithoutUserNestedInput
    rulesConversations?: RulesConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clobApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    clobSecret?: NullableStringFieldUpdateOperationsInput | string | null
    clobPassphrase?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    telegramIntegrationId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    blogPost?: BlogPostUncheckedUpdateManyWithoutAuthorUserNestedInput
    telegramIntegration?: TelegramIntegrationUncheckedUpdateOneWithoutCreatedByNestedInput
    watchLists?: WatchListUncheckedUpdateManyWithoutUserNestedInput
    rulesConversations?: RulesConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    type?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    images?: StringNullableListFilter<"Message">
    completed?: BoolFilter<"Message"> | boolean
    marketData?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    isFavorite?: boolean
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    title?: string | null
    createdAt?: Date | string
    isFavorite?: boolean
    updatedAt?: Date | string
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutRulesConversationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    password?: string | null
    verifyToken?: string | null
    verifyTokenExpiry?: Date | string | null
    walletAddress?: string | null
    clobApiKey?: string | null
    clobSecret?: string | null
    clobPassphrase?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken?: string | null
    telegramIntegrationId?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    blogPost?: BlogPostCreateNestedManyWithoutAuthorUserInput
    telegramIntegration?: TelegramIntegrationCreateNestedOneWithoutCreatedByInput
    watchLists?: WatchListCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRulesConversationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    password?: string | null
    verifyToken?: string | null
    verifyTokenExpiry?: Date | string | null
    walletAddress?: string | null
    clobApiKey?: string | null
    clobSecret?: string | null
    clobPassphrase?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken?: string | null
    telegramIntegrationId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    blogPost?: BlogPostUncheckedCreateNestedManyWithoutAuthorUserInput
    telegramIntegration?: TelegramIntegrationUncheckedCreateNestedOneWithoutCreatedByInput
    watchLists?: WatchListUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRulesConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRulesConversationsInput, UserUncheckedCreateWithoutRulesConversationsInput>
  }

  export type RulesMessageCreateWithoutConversationInput = {
    id?: string
    type: string
    content: string
    images?: RulesMessageCreateimagesInput | string[]
    completed?: boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RulesMessageUncheckedCreateWithoutConversationInput = {
    id?: string
    type: string
    content: string
    images?: RulesMessageCreateimagesInput | string[]
    completed?: boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RulesMessageCreateOrConnectWithoutConversationInput = {
    where: RulesMessageWhereUniqueInput
    create: XOR<RulesMessageCreateWithoutConversationInput, RulesMessageUncheckedCreateWithoutConversationInput>
  }

  export type RulesMessageCreateManyConversationInputEnvelope = {
    data: RulesMessageCreateManyConversationInput | RulesMessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRulesConversationsInput = {
    update: XOR<UserUpdateWithoutRulesConversationsInput, UserUncheckedUpdateWithoutRulesConversationsInput>
    create: XOR<UserCreateWithoutRulesConversationsInput, UserUncheckedCreateWithoutRulesConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRulesConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRulesConversationsInput, UserUncheckedUpdateWithoutRulesConversationsInput>
  }

  export type UserUpdateWithoutRulesConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clobApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    clobSecret?: NullableStringFieldUpdateOperationsInput | string | null
    clobPassphrase?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    telegramIntegrationId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    blogPost?: BlogPostUpdateManyWithoutAuthorUserNestedInput
    telegramIntegration?: TelegramIntegrationUpdateOneWithoutCreatedByNestedInput
    watchLists?: WatchListUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRulesConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clobApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    clobSecret?: NullableStringFieldUpdateOperationsInput | string | null
    clobPassphrase?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    telegramIntegrationId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    blogPost?: BlogPostUncheckedUpdateManyWithoutAuthorUserNestedInput
    telegramIntegration?: TelegramIntegrationUncheckedUpdateOneWithoutCreatedByNestedInput
    watchLists?: WatchListUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RulesMessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: RulesMessageWhereUniqueInput
    update: XOR<RulesMessageUpdateWithoutConversationInput, RulesMessageUncheckedUpdateWithoutConversationInput>
    create: XOR<RulesMessageCreateWithoutConversationInput, RulesMessageUncheckedCreateWithoutConversationInput>
  }

  export type RulesMessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: RulesMessageWhereUniqueInput
    data: XOR<RulesMessageUpdateWithoutConversationInput, RulesMessageUncheckedUpdateWithoutConversationInput>
  }

  export type RulesMessageUpdateManyWithWhereWithoutConversationInput = {
    where: RulesMessageScalarWhereInput
    data: XOR<RulesMessageUpdateManyMutationInput, RulesMessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type RulesMessageScalarWhereInput = {
    AND?: RulesMessageScalarWhereInput | RulesMessageScalarWhereInput[]
    OR?: RulesMessageScalarWhereInput[]
    NOT?: RulesMessageScalarWhereInput | RulesMessageScalarWhereInput[]
    id?: StringFilter<"RulesMessage"> | string
    conversationId?: StringFilter<"RulesMessage"> | string
    type?: StringFilter<"RulesMessage"> | string
    content?: StringFilter<"RulesMessage"> | string
    images?: StringNullableListFilter<"RulesMessage">
    completed?: BoolFilter<"RulesMessage"> | boolean
    marketData?: JsonNullableFilter<"RulesMessage">
    createdAt?: DateTimeFilter<"RulesMessage"> | Date | string
  }

  export type RulesConversationCreateWithoutMessagesInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    isFavorite?: boolean
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRulesConversationsInput
  }

  export type RulesConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    title?: string | null
    createdAt?: Date | string
    isFavorite?: boolean
    updatedAt?: Date | string
  }

  export type RulesConversationCreateOrConnectWithoutMessagesInput = {
    where: RulesConversationWhereUniqueInput
    create: XOR<RulesConversationCreateWithoutMessagesInput, RulesConversationUncheckedCreateWithoutMessagesInput>
  }

  export type RulesConversationUpsertWithoutMessagesInput = {
    update: XOR<RulesConversationUpdateWithoutMessagesInput, RulesConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<RulesConversationCreateWithoutMessagesInput, RulesConversationUncheckedCreateWithoutMessagesInput>
    where?: RulesConversationWhereInput
  }

  export type RulesConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: RulesConversationWhereInput
    data: XOR<RulesConversationUpdateWithoutMessagesInput, RulesConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type RulesConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRulesConversationsNestedInput
  }

  export type RulesConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutWatchListsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    password?: string | null
    verifyToken?: string | null
    verifyTokenExpiry?: Date | string | null
    walletAddress?: string | null
    clobApiKey?: string | null
    clobSecret?: string | null
    clobPassphrase?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken?: string | null
    telegramIntegrationId?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    blogPost?: BlogPostCreateNestedManyWithoutAuthorUserInput
    telegramIntegration?: TelegramIntegrationCreateNestedOneWithoutCreatedByInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    rulesConversations?: RulesConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWatchListsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    password?: string | null
    verifyToken?: string | null
    verifyTokenExpiry?: Date | string | null
    walletAddress?: string | null
    clobApiKey?: string | null
    clobSecret?: string | null
    clobPassphrase?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken?: string | null
    telegramIntegrationId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    blogPost?: BlogPostUncheckedCreateNestedManyWithoutAuthorUserInput
    telegramIntegration?: TelegramIntegrationUncheckedCreateNestedOneWithoutCreatedByInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    rulesConversations?: RulesConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWatchListsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWatchListsInput, UserUncheckedCreateWithoutWatchListsInput>
  }

  export type UserUpsertWithoutWatchListsInput = {
    update: XOR<UserUpdateWithoutWatchListsInput, UserUncheckedUpdateWithoutWatchListsInput>
    create: XOR<UserCreateWithoutWatchListsInput, UserUncheckedCreateWithoutWatchListsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWatchListsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWatchListsInput, UserUncheckedUpdateWithoutWatchListsInput>
  }

  export type UserUpdateWithoutWatchListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clobApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    clobSecret?: NullableStringFieldUpdateOperationsInput | string | null
    clobPassphrase?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    telegramIntegrationId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    blogPost?: BlogPostUpdateManyWithoutAuthorUserNestedInput
    telegramIntegration?: TelegramIntegrationUpdateOneWithoutCreatedByNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    rulesConversations?: RulesConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWatchListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clobApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    clobSecret?: NullableStringFieldUpdateOperationsInput | string | null
    clobPassphrase?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    telegramIntegrationId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    blogPost?: BlogPostUncheckedUpdateManyWithoutAuthorUserNestedInput
    telegramIntegration?: TelegramIntegrationUncheckedUpdateOneWithoutCreatedByNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    rulesConversations?: RulesConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MarketDistributionCreateWithoutUserInput = {
    id?: string
    market: string
    value: number
    trades: number
    volume: number
    uniqueMarkets: number
    createdAt?: Date | string
  }

  export type MarketDistributionUncheckedCreateWithoutUserInput = {
    id?: string
    market: string
    value: number
    trades: number
    volume: number
    uniqueMarkets: number
    createdAt?: Date | string
  }

  export type MarketDistributionCreateOrConnectWithoutUserInput = {
    where: MarketDistributionWhereUniqueInput
    create: XOR<MarketDistributionCreateWithoutUserInput, MarketDistributionUncheckedCreateWithoutUserInput>
  }

  export type MarketDistributionCreateManyUserInputEnvelope = {
    data: MarketDistributionCreateManyUserInput | MarketDistributionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BuySellDataCreateWithoutUserInput = {
    id?: string
    buyPercentage: number
    sellPercentage: number
    buyVolume: number
    sellVolume: number
    buyCount: number
    sellCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuySellDataUncheckedCreateWithoutUserInput = {
    id?: string
    buyPercentage: number
    sellPercentage: number
    buyVolume: number
    sellVolume: number
    buyCount: number
    sellCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuySellDataCreateOrConnectWithoutUserInput = {
    where: BuySellDataWhereUniqueInput
    create: XOR<BuySellDataCreateWithoutUserInput, BuySellDataUncheckedCreateWithoutUserInput>
  }

  export type TradeSizeDataCreateWithoutUserInput = {
    id?: string
    averageSize: number
    medianSize: number
    minSize: number
    maxSize: number
    smallTrades: number
    mediumTrades: number
    largeTrades: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeSizeDataUncheckedCreateWithoutUserInput = {
    id?: string
    averageSize: number
    medianSize: number
    minSize: number
    maxSize: number
    smallTrades: number
    mediumTrades: number
    largeTrades: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeSizeDataCreateOrConnectWithoutUserInput = {
    where: TradeSizeDataWhereUniqueInput
    create: XOR<TradeSizeDataCreateWithoutUserInput, TradeSizeDataUncheckedCreateWithoutUserInput>
  }

  export type PriceStatsCreateWithoutUserInput = {
    id?: string
    averagePrice: number
    minPrice: number
    maxPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceStatsUncheckedCreateWithoutUserInput = {
    id?: string
    averagePrice: number
    minPrice: number
    maxPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceStatsCreateOrConnectWithoutUserInput = {
    where: PriceStatsWhereUniqueInput
    create: XOR<PriceStatsCreateWithoutUserInput, PriceStatsUncheckedCreateWithoutUserInput>
  }

  export type MonthlyPerformanceCreateWithoutUserInput = {
    id?: string
    month: string
    yearMonth: string
    profit: number
    volume: number
    trades: number
    createdAt?: Date | string
  }

  export type MonthlyPerformanceUncheckedCreateWithoutUserInput = {
    id?: string
    month: string
    yearMonth: string
    profit: number
    volume: number
    trades: number
    createdAt?: Date | string
  }

  export type MonthlyPerformanceCreateOrConnectWithoutUserInput = {
    where: MonthlyPerformanceWhereUniqueInput
    create: XOR<MonthlyPerformanceCreateWithoutUserInput, MonthlyPerformanceUncheckedCreateWithoutUserInput>
  }

  export type MonthlyPerformanceCreateManyUserInputEnvelope = {
    data: MonthlyPerformanceCreateManyUserInput | MonthlyPerformanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WeeklyWinRateCreateWithoutUserInput = {
    id?: string
    week: string
    weekDate: Date | string
    winRate: number
    totalTrades: number
    createdAt?: Date | string
  }

  export type WeeklyWinRateUncheckedCreateWithoutUserInput = {
    id?: string
    week: string
    weekDate: Date | string
    winRate: number
    totalTrades: number
    createdAt?: Date | string
  }

  export type WeeklyWinRateCreateOrConnectWithoutUserInput = {
    where: WeeklyWinRateWhereUniqueInput
    create: XOR<WeeklyWinRateCreateWithoutUserInput, WeeklyWinRateUncheckedCreateWithoutUserInput>
  }

  export type WeeklyWinRateCreateManyUserInputEnvelope = {
    data: WeeklyWinRateCreateManyUserInput | WeeklyWinRateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MarketDistributionUpsertWithWhereUniqueWithoutUserInput = {
    where: MarketDistributionWhereUniqueInput
    update: XOR<MarketDistributionUpdateWithoutUserInput, MarketDistributionUncheckedUpdateWithoutUserInput>
    create: XOR<MarketDistributionCreateWithoutUserInput, MarketDistributionUncheckedCreateWithoutUserInput>
  }

  export type MarketDistributionUpdateWithWhereUniqueWithoutUserInput = {
    where: MarketDistributionWhereUniqueInput
    data: XOR<MarketDistributionUpdateWithoutUserInput, MarketDistributionUncheckedUpdateWithoutUserInput>
  }

  export type MarketDistributionUpdateManyWithWhereWithoutUserInput = {
    where: MarketDistributionScalarWhereInput
    data: XOR<MarketDistributionUpdateManyMutationInput, MarketDistributionUncheckedUpdateManyWithoutUserInput>
  }

  export type MarketDistributionScalarWhereInput = {
    AND?: MarketDistributionScalarWhereInput | MarketDistributionScalarWhereInput[]
    OR?: MarketDistributionScalarWhereInput[]
    NOT?: MarketDistributionScalarWhereInput | MarketDistributionScalarWhereInput[]
    id?: StringFilter<"MarketDistribution"> | string
    userId?: StringFilter<"MarketDistribution"> | string
    market?: StringFilter<"MarketDistribution"> | string
    value?: IntFilter<"MarketDistribution"> | number
    trades?: IntFilter<"MarketDistribution"> | number
    volume?: FloatFilter<"MarketDistribution"> | number
    uniqueMarkets?: IntFilter<"MarketDistribution"> | number
    createdAt?: DateTimeFilter<"MarketDistribution"> | Date | string
  }

  export type BuySellDataUpsertWithoutUserInput = {
    update: XOR<BuySellDataUpdateWithoutUserInput, BuySellDataUncheckedUpdateWithoutUserInput>
    create: XOR<BuySellDataCreateWithoutUserInput, BuySellDataUncheckedCreateWithoutUserInput>
    where?: BuySellDataWhereInput
  }

  export type BuySellDataUpdateToOneWithWhereWithoutUserInput = {
    where?: BuySellDataWhereInput
    data: XOR<BuySellDataUpdateWithoutUserInput, BuySellDataUncheckedUpdateWithoutUserInput>
  }

  export type BuySellDataUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyPercentage?: IntFieldUpdateOperationsInput | number
    sellPercentage?: IntFieldUpdateOperationsInput | number
    buyVolume?: FloatFieldUpdateOperationsInput | number
    sellVolume?: FloatFieldUpdateOperationsInput | number
    buyCount?: IntFieldUpdateOperationsInput | number
    sellCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuySellDataUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyPercentage?: IntFieldUpdateOperationsInput | number
    sellPercentage?: IntFieldUpdateOperationsInput | number
    buyVolume?: FloatFieldUpdateOperationsInput | number
    sellVolume?: FloatFieldUpdateOperationsInput | number
    buyCount?: IntFieldUpdateOperationsInput | number
    sellCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeSizeDataUpsertWithoutUserInput = {
    update: XOR<TradeSizeDataUpdateWithoutUserInput, TradeSizeDataUncheckedUpdateWithoutUserInput>
    create: XOR<TradeSizeDataCreateWithoutUserInput, TradeSizeDataUncheckedCreateWithoutUserInput>
    where?: TradeSizeDataWhereInput
  }

  export type TradeSizeDataUpdateToOneWithWhereWithoutUserInput = {
    where?: TradeSizeDataWhereInput
    data: XOR<TradeSizeDataUpdateWithoutUserInput, TradeSizeDataUncheckedUpdateWithoutUserInput>
  }

  export type TradeSizeDataUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    averageSize?: FloatFieldUpdateOperationsInput | number
    medianSize?: FloatFieldUpdateOperationsInput | number
    minSize?: FloatFieldUpdateOperationsInput | number
    maxSize?: FloatFieldUpdateOperationsInput | number
    smallTrades?: IntFieldUpdateOperationsInput | number
    mediumTrades?: IntFieldUpdateOperationsInput | number
    largeTrades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeSizeDataUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    averageSize?: FloatFieldUpdateOperationsInput | number
    medianSize?: FloatFieldUpdateOperationsInput | number
    minSize?: FloatFieldUpdateOperationsInput | number
    maxSize?: FloatFieldUpdateOperationsInput | number
    smallTrades?: IntFieldUpdateOperationsInput | number
    mediumTrades?: IntFieldUpdateOperationsInput | number
    largeTrades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceStatsUpsertWithoutUserInput = {
    update: XOR<PriceStatsUpdateWithoutUserInput, PriceStatsUncheckedUpdateWithoutUserInput>
    create: XOR<PriceStatsCreateWithoutUserInput, PriceStatsUncheckedCreateWithoutUserInput>
    where?: PriceStatsWhereInput
  }

  export type PriceStatsUpdateToOneWithWhereWithoutUserInput = {
    where?: PriceStatsWhereInput
    data: XOR<PriceStatsUpdateWithoutUserInput, PriceStatsUncheckedUpdateWithoutUserInput>
  }

  export type PriceStatsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    averagePrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceStatsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    averagePrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlyPerformanceUpsertWithWhereUniqueWithoutUserInput = {
    where: MonthlyPerformanceWhereUniqueInput
    update: XOR<MonthlyPerformanceUpdateWithoutUserInput, MonthlyPerformanceUncheckedUpdateWithoutUserInput>
    create: XOR<MonthlyPerformanceCreateWithoutUserInput, MonthlyPerformanceUncheckedCreateWithoutUserInput>
  }

  export type MonthlyPerformanceUpdateWithWhereUniqueWithoutUserInput = {
    where: MonthlyPerformanceWhereUniqueInput
    data: XOR<MonthlyPerformanceUpdateWithoutUserInput, MonthlyPerformanceUncheckedUpdateWithoutUserInput>
  }

  export type MonthlyPerformanceUpdateManyWithWhereWithoutUserInput = {
    where: MonthlyPerformanceScalarWhereInput
    data: XOR<MonthlyPerformanceUpdateManyMutationInput, MonthlyPerformanceUncheckedUpdateManyWithoutUserInput>
  }

  export type MonthlyPerformanceScalarWhereInput = {
    AND?: MonthlyPerformanceScalarWhereInput | MonthlyPerformanceScalarWhereInput[]
    OR?: MonthlyPerformanceScalarWhereInput[]
    NOT?: MonthlyPerformanceScalarWhereInput | MonthlyPerformanceScalarWhereInput[]
    id?: StringFilter<"MonthlyPerformance"> | string
    userId?: StringFilter<"MonthlyPerformance"> | string
    month?: StringFilter<"MonthlyPerformance"> | string
    yearMonth?: StringFilter<"MonthlyPerformance"> | string
    profit?: FloatFilter<"MonthlyPerformance"> | number
    volume?: FloatFilter<"MonthlyPerformance"> | number
    trades?: IntFilter<"MonthlyPerformance"> | number
    createdAt?: DateTimeFilter<"MonthlyPerformance"> | Date | string
  }

  export type WeeklyWinRateUpsertWithWhereUniqueWithoutUserInput = {
    where: WeeklyWinRateWhereUniqueInput
    update: XOR<WeeklyWinRateUpdateWithoutUserInput, WeeklyWinRateUncheckedUpdateWithoutUserInput>
    create: XOR<WeeklyWinRateCreateWithoutUserInput, WeeklyWinRateUncheckedCreateWithoutUserInput>
  }

  export type WeeklyWinRateUpdateWithWhereUniqueWithoutUserInput = {
    where: WeeklyWinRateWhereUniqueInput
    data: XOR<WeeklyWinRateUpdateWithoutUserInput, WeeklyWinRateUncheckedUpdateWithoutUserInput>
  }

  export type WeeklyWinRateUpdateManyWithWhereWithoutUserInput = {
    where: WeeklyWinRateScalarWhereInput
    data: XOR<WeeklyWinRateUpdateManyMutationInput, WeeklyWinRateUncheckedUpdateManyWithoutUserInput>
  }

  export type WeeklyWinRateScalarWhereInput = {
    AND?: WeeklyWinRateScalarWhereInput | WeeklyWinRateScalarWhereInput[]
    OR?: WeeklyWinRateScalarWhereInput[]
    NOT?: WeeklyWinRateScalarWhereInput | WeeklyWinRateScalarWhereInput[]
    id?: StringFilter<"WeeklyWinRate"> | string
    userId?: StringFilter<"WeeklyWinRate"> | string
    week?: StringFilter<"WeeklyWinRate"> | string
    weekDate?: DateTimeFilter<"WeeklyWinRate"> | Date | string
    winRate?: FloatFilter<"WeeklyWinRate"> | number
    totalTrades?: IntFilter<"WeeklyWinRate"> | number
    createdAt?: DateTimeFilter<"WeeklyWinRate"> | Date | string
  }

  export type UserAnalyticsCreateWithoutMarketDistributionInput = {
    id?: string
    address: string
    totalVolume?: number
    totalProfit?: number
    positionValue?: number
    totalTrades?: number
    totalPositions?: number
    averageWinRate?: number
    avgMonthlyProfit?: number
    avgMonthlyTrades?: number
    mostTradedCategory?: string | null
    tradingStyle?: string | null
    riskProfile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    buySellData?: BuySellDataCreateNestedOneWithoutUserInput
    tradeSizeData?: TradeSizeDataCreateNestedOneWithoutUserInput
    priceStats?: PriceStatsCreateNestedOneWithoutUserInput
    monthlyPerformance?: MonthlyPerformanceCreateNestedManyWithoutUserInput
    weeklyWinRate?: WeeklyWinRateCreateNestedManyWithoutUserInput
  }

  export type UserAnalyticsUncheckedCreateWithoutMarketDistributionInput = {
    id?: string
    address: string
    totalVolume?: number
    totalProfit?: number
    positionValue?: number
    totalTrades?: number
    totalPositions?: number
    averageWinRate?: number
    avgMonthlyProfit?: number
    avgMonthlyTrades?: number
    mostTradedCategory?: string | null
    tradingStyle?: string | null
    riskProfile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    buySellData?: BuySellDataUncheckedCreateNestedOneWithoutUserInput
    tradeSizeData?: TradeSizeDataUncheckedCreateNestedOneWithoutUserInput
    priceStats?: PriceStatsUncheckedCreateNestedOneWithoutUserInput
    monthlyPerformance?: MonthlyPerformanceUncheckedCreateNestedManyWithoutUserInput
    weeklyWinRate?: WeeklyWinRateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserAnalyticsCreateOrConnectWithoutMarketDistributionInput = {
    where: UserAnalyticsWhereUniqueInput
    create: XOR<UserAnalyticsCreateWithoutMarketDistributionInput, UserAnalyticsUncheckedCreateWithoutMarketDistributionInput>
  }

  export type UserAnalyticsUpsertWithoutMarketDistributionInput = {
    update: XOR<UserAnalyticsUpdateWithoutMarketDistributionInput, UserAnalyticsUncheckedUpdateWithoutMarketDistributionInput>
    create: XOR<UserAnalyticsCreateWithoutMarketDistributionInput, UserAnalyticsUncheckedCreateWithoutMarketDistributionInput>
    where?: UserAnalyticsWhereInput
  }

  export type UserAnalyticsUpdateToOneWithWhereWithoutMarketDistributionInput = {
    where?: UserAnalyticsWhereInput
    data: XOR<UserAnalyticsUpdateWithoutMarketDistributionInput, UserAnalyticsUncheckedUpdateWithoutMarketDistributionInput>
  }

  export type UserAnalyticsUpdateWithoutMarketDistributionInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    positionValue?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    totalPositions?: IntFieldUpdateOperationsInput | number
    averageWinRate?: FloatFieldUpdateOperationsInput | number
    avgMonthlyProfit?: FloatFieldUpdateOperationsInput | number
    avgMonthlyTrades?: IntFieldUpdateOperationsInput | number
    mostTradedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    tradingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    riskProfile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buySellData?: BuySellDataUpdateOneWithoutUserNestedInput
    tradeSizeData?: TradeSizeDataUpdateOneWithoutUserNestedInput
    priceStats?: PriceStatsUpdateOneWithoutUserNestedInput
    monthlyPerformance?: MonthlyPerformanceUpdateManyWithoutUserNestedInput
    weeklyWinRate?: WeeklyWinRateUpdateManyWithoutUserNestedInput
  }

  export type UserAnalyticsUncheckedUpdateWithoutMarketDistributionInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    positionValue?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    totalPositions?: IntFieldUpdateOperationsInput | number
    averageWinRate?: FloatFieldUpdateOperationsInput | number
    avgMonthlyProfit?: FloatFieldUpdateOperationsInput | number
    avgMonthlyTrades?: IntFieldUpdateOperationsInput | number
    mostTradedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    tradingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    riskProfile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buySellData?: BuySellDataUncheckedUpdateOneWithoutUserNestedInput
    tradeSizeData?: TradeSizeDataUncheckedUpdateOneWithoutUserNestedInput
    priceStats?: PriceStatsUncheckedUpdateOneWithoutUserNestedInput
    monthlyPerformance?: MonthlyPerformanceUncheckedUpdateManyWithoutUserNestedInput
    weeklyWinRate?: WeeklyWinRateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserAnalyticsCreateWithoutBuySellDataInput = {
    id?: string
    address: string
    totalVolume?: number
    totalProfit?: number
    positionValue?: number
    totalTrades?: number
    totalPositions?: number
    averageWinRate?: number
    avgMonthlyProfit?: number
    avgMonthlyTrades?: number
    mostTradedCategory?: string | null
    tradingStyle?: string | null
    riskProfile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    marketDistribution?: MarketDistributionCreateNestedManyWithoutUserInput
    tradeSizeData?: TradeSizeDataCreateNestedOneWithoutUserInput
    priceStats?: PriceStatsCreateNestedOneWithoutUserInput
    monthlyPerformance?: MonthlyPerformanceCreateNestedManyWithoutUserInput
    weeklyWinRate?: WeeklyWinRateCreateNestedManyWithoutUserInput
  }

  export type UserAnalyticsUncheckedCreateWithoutBuySellDataInput = {
    id?: string
    address: string
    totalVolume?: number
    totalProfit?: number
    positionValue?: number
    totalTrades?: number
    totalPositions?: number
    averageWinRate?: number
    avgMonthlyProfit?: number
    avgMonthlyTrades?: number
    mostTradedCategory?: string | null
    tradingStyle?: string | null
    riskProfile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    marketDistribution?: MarketDistributionUncheckedCreateNestedManyWithoutUserInput
    tradeSizeData?: TradeSizeDataUncheckedCreateNestedOneWithoutUserInput
    priceStats?: PriceStatsUncheckedCreateNestedOneWithoutUserInput
    monthlyPerformance?: MonthlyPerformanceUncheckedCreateNestedManyWithoutUserInput
    weeklyWinRate?: WeeklyWinRateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserAnalyticsCreateOrConnectWithoutBuySellDataInput = {
    where: UserAnalyticsWhereUniqueInput
    create: XOR<UserAnalyticsCreateWithoutBuySellDataInput, UserAnalyticsUncheckedCreateWithoutBuySellDataInput>
  }

  export type UserAnalyticsUpsertWithoutBuySellDataInput = {
    update: XOR<UserAnalyticsUpdateWithoutBuySellDataInput, UserAnalyticsUncheckedUpdateWithoutBuySellDataInput>
    create: XOR<UserAnalyticsCreateWithoutBuySellDataInput, UserAnalyticsUncheckedCreateWithoutBuySellDataInput>
    where?: UserAnalyticsWhereInput
  }

  export type UserAnalyticsUpdateToOneWithWhereWithoutBuySellDataInput = {
    where?: UserAnalyticsWhereInput
    data: XOR<UserAnalyticsUpdateWithoutBuySellDataInput, UserAnalyticsUncheckedUpdateWithoutBuySellDataInput>
  }

  export type UserAnalyticsUpdateWithoutBuySellDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    positionValue?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    totalPositions?: IntFieldUpdateOperationsInput | number
    averageWinRate?: FloatFieldUpdateOperationsInput | number
    avgMonthlyProfit?: FloatFieldUpdateOperationsInput | number
    avgMonthlyTrades?: IntFieldUpdateOperationsInput | number
    mostTradedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    tradingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    riskProfile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketDistribution?: MarketDistributionUpdateManyWithoutUserNestedInput
    tradeSizeData?: TradeSizeDataUpdateOneWithoutUserNestedInput
    priceStats?: PriceStatsUpdateOneWithoutUserNestedInput
    monthlyPerformance?: MonthlyPerformanceUpdateManyWithoutUserNestedInput
    weeklyWinRate?: WeeklyWinRateUpdateManyWithoutUserNestedInput
  }

  export type UserAnalyticsUncheckedUpdateWithoutBuySellDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    positionValue?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    totalPositions?: IntFieldUpdateOperationsInput | number
    averageWinRate?: FloatFieldUpdateOperationsInput | number
    avgMonthlyProfit?: FloatFieldUpdateOperationsInput | number
    avgMonthlyTrades?: IntFieldUpdateOperationsInput | number
    mostTradedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    tradingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    riskProfile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketDistribution?: MarketDistributionUncheckedUpdateManyWithoutUserNestedInput
    tradeSizeData?: TradeSizeDataUncheckedUpdateOneWithoutUserNestedInput
    priceStats?: PriceStatsUncheckedUpdateOneWithoutUserNestedInput
    monthlyPerformance?: MonthlyPerformanceUncheckedUpdateManyWithoutUserNestedInput
    weeklyWinRate?: WeeklyWinRateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserAnalyticsCreateWithoutTradeSizeDataInput = {
    id?: string
    address: string
    totalVolume?: number
    totalProfit?: number
    positionValue?: number
    totalTrades?: number
    totalPositions?: number
    averageWinRate?: number
    avgMonthlyProfit?: number
    avgMonthlyTrades?: number
    mostTradedCategory?: string | null
    tradingStyle?: string | null
    riskProfile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    marketDistribution?: MarketDistributionCreateNestedManyWithoutUserInput
    buySellData?: BuySellDataCreateNestedOneWithoutUserInput
    priceStats?: PriceStatsCreateNestedOneWithoutUserInput
    monthlyPerformance?: MonthlyPerformanceCreateNestedManyWithoutUserInput
    weeklyWinRate?: WeeklyWinRateCreateNestedManyWithoutUserInput
  }

  export type UserAnalyticsUncheckedCreateWithoutTradeSizeDataInput = {
    id?: string
    address: string
    totalVolume?: number
    totalProfit?: number
    positionValue?: number
    totalTrades?: number
    totalPositions?: number
    averageWinRate?: number
    avgMonthlyProfit?: number
    avgMonthlyTrades?: number
    mostTradedCategory?: string | null
    tradingStyle?: string | null
    riskProfile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    marketDistribution?: MarketDistributionUncheckedCreateNestedManyWithoutUserInput
    buySellData?: BuySellDataUncheckedCreateNestedOneWithoutUserInput
    priceStats?: PriceStatsUncheckedCreateNestedOneWithoutUserInput
    monthlyPerformance?: MonthlyPerformanceUncheckedCreateNestedManyWithoutUserInput
    weeklyWinRate?: WeeklyWinRateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserAnalyticsCreateOrConnectWithoutTradeSizeDataInput = {
    where: UserAnalyticsWhereUniqueInput
    create: XOR<UserAnalyticsCreateWithoutTradeSizeDataInput, UserAnalyticsUncheckedCreateWithoutTradeSizeDataInput>
  }

  export type UserAnalyticsUpsertWithoutTradeSizeDataInput = {
    update: XOR<UserAnalyticsUpdateWithoutTradeSizeDataInput, UserAnalyticsUncheckedUpdateWithoutTradeSizeDataInput>
    create: XOR<UserAnalyticsCreateWithoutTradeSizeDataInput, UserAnalyticsUncheckedCreateWithoutTradeSizeDataInput>
    where?: UserAnalyticsWhereInput
  }

  export type UserAnalyticsUpdateToOneWithWhereWithoutTradeSizeDataInput = {
    where?: UserAnalyticsWhereInput
    data: XOR<UserAnalyticsUpdateWithoutTradeSizeDataInput, UserAnalyticsUncheckedUpdateWithoutTradeSizeDataInput>
  }

  export type UserAnalyticsUpdateWithoutTradeSizeDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    positionValue?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    totalPositions?: IntFieldUpdateOperationsInput | number
    averageWinRate?: FloatFieldUpdateOperationsInput | number
    avgMonthlyProfit?: FloatFieldUpdateOperationsInput | number
    avgMonthlyTrades?: IntFieldUpdateOperationsInput | number
    mostTradedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    tradingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    riskProfile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketDistribution?: MarketDistributionUpdateManyWithoutUserNestedInput
    buySellData?: BuySellDataUpdateOneWithoutUserNestedInput
    priceStats?: PriceStatsUpdateOneWithoutUserNestedInput
    monthlyPerformance?: MonthlyPerformanceUpdateManyWithoutUserNestedInput
    weeklyWinRate?: WeeklyWinRateUpdateManyWithoutUserNestedInput
  }

  export type UserAnalyticsUncheckedUpdateWithoutTradeSizeDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    positionValue?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    totalPositions?: IntFieldUpdateOperationsInput | number
    averageWinRate?: FloatFieldUpdateOperationsInput | number
    avgMonthlyProfit?: FloatFieldUpdateOperationsInput | number
    avgMonthlyTrades?: IntFieldUpdateOperationsInput | number
    mostTradedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    tradingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    riskProfile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketDistribution?: MarketDistributionUncheckedUpdateManyWithoutUserNestedInput
    buySellData?: BuySellDataUncheckedUpdateOneWithoutUserNestedInput
    priceStats?: PriceStatsUncheckedUpdateOneWithoutUserNestedInput
    monthlyPerformance?: MonthlyPerformanceUncheckedUpdateManyWithoutUserNestedInput
    weeklyWinRate?: WeeklyWinRateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserAnalyticsCreateWithoutPriceStatsInput = {
    id?: string
    address: string
    totalVolume?: number
    totalProfit?: number
    positionValue?: number
    totalTrades?: number
    totalPositions?: number
    averageWinRate?: number
    avgMonthlyProfit?: number
    avgMonthlyTrades?: number
    mostTradedCategory?: string | null
    tradingStyle?: string | null
    riskProfile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    marketDistribution?: MarketDistributionCreateNestedManyWithoutUserInput
    buySellData?: BuySellDataCreateNestedOneWithoutUserInput
    tradeSizeData?: TradeSizeDataCreateNestedOneWithoutUserInput
    monthlyPerformance?: MonthlyPerformanceCreateNestedManyWithoutUserInput
    weeklyWinRate?: WeeklyWinRateCreateNestedManyWithoutUserInput
  }

  export type UserAnalyticsUncheckedCreateWithoutPriceStatsInput = {
    id?: string
    address: string
    totalVolume?: number
    totalProfit?: number
    positionValue?: number
    totalTrades?: number
    totalPositions?: number
    averageWinRate?: number
    avgMonthlyProfit?: number
    avgMonthlyTrades?: number
    mostTradedCategory?: string | null
    tradingStyle?: string | null
    riskProfile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    marketDistribution?: MarketDistributionUncheckedCreateNestedManyWithoutUserInput
    buySellData?: BuySellDataUncheckedCreateNestedOneWithoutUserInput
    tradeSizeData?: TradeSizeDataUncheckedCreateNestedOneWithoutUserInput
    monthlyPerformance?: MonthlyPerformanceUncheckedCreateNestedManyWithoutUserInput
    weeklyWinRate?: WeeklyWinRateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserAnalyticsCreateOrConnectWithoutPriceStatsInput = {
    where: UserAnalyticsWhereUniqueInput
    create: XOR<UserAnalyticsCreateWithoutPriceStatsInput, UserAnalyticsUncheckedCreateWithoutPriceStatsInput>
  }

  export type UserAnalyticsUpsertWithoutPriceStatsInput = {
    update: XOR<UserAnalyticsUpdateWithoutPriceStatsInput, UserAnalyticsUncheckedUpdateWithoutPriceStatsInput>
    create: XOR<UserAnalyticsCreateWithoutPriceStatsInput, UserAnalyticsUncheckedCreateWithoutPriceStatsInput>
    where?: UserAnalyticsWhereInput
  }

  export type UserAnalyticsUpdateToOneWithWhereWithoutPriceStatsInput = {
    where?: UserAnalyticsWhereInput
    data: XOR<UserAnalyticsUpdateWithoutPriceStatsInput, UserAnalyticsUncheckedUpdateWithoutPriceStatsInput>
  }

  export type UserAnalyticsUpdateWithoutPriceStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    positionValue?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    totalPositions?: IntFieldUpdateOperationsInput | number
    averageWinRate?: FloatFieldUpdateOperationsInput | number
    avgMonthlyProfit?: FloatFieldUpdateOperationsInput | number
    avgMonthlyTrades?: IntFieldUpdateOperationsInput | number
    mostTradedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    tradingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    riskProfile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketDistribution?: MarketDistributionUpdateManyWithoutUserNestedInput
    buySellData?: BuySellDataUpdateOneWithoutUserNestedInput
    tradeSizeData?: TradeSizeDataUpdateOneWithoutUserNestedInput
    monthlyPerformance?: MonthlyPerformanceUpdateManyWithoutUserNestedInput
    weeklyWinRate?: WeeklyWinRateUpdateManyWithoutUserNestedInput
  }

  export type UserAnalyticsUncheckedUpdateWithoutPriceStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    positionValue?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    totalPositions?: IntFieldUpdateOperationsInput | number
    averageWinRate?: FloatFieldUpdateOperationsInput | number
    avgMonthlyProfit?: FloatFieldUpdateOperationsInput | number
    avgMonthlyTrades?: IntFieldUpdateOperationsInput | number
    mostTradedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    tradingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    riskProfile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketDistribution?: MarketDistributionUncheckedUpdateManyWithoutUserNestedInput
    buySellData?: BuySellDataUncheckedUpdateOneWithoutUserNestedInput
    tradeSizeData?: TradeSizeDataUncheckedUpdateOneWithoutUserNestedInput
    monthlyPerformance?: MonthlyPerformanceUncheckedUpdateManyWithoutUserNestedInput
    weeklyWinRate?: WeeklyWinRateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserAnalyticsCreateWithoutMonthlyPerformanceInput = {
    id?: string
    address: string
    totalVolume?: number
    totalProfit?: number
    positionValue?: number
    totalTrades?: number
    totalPositions?: number
    averageWinRate?: number
    avgMonthlyProfit?: number
    avgMonthlyTrades?: number
    mostTradedCategory?: string | null
    tradingStyle?: string | null
    riskProfile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    marketDistribution?: MarketDistributionCreateNestedManyWithoutUserInput
    buySellData?: BuySellDataCreateNestedOneWithoutUserInput
    tradeSizeData?: TradeSizeDataCreateNestedOneWithoutUserInput
    priceStats?: PriceStatsCreateNestedOneWithoutUserInput
    weeklyWinRate?: WeeklyWinRateCreateNestedManyWithoutUserInput
  }

  export type UserAnalyticsUncheckedCreateWithoutMonthlyPerformanceInput = {
    id?: string
    address: string
    totalVolume?: number
    totalProfit?: number
    positionValue?: number
    totalTrades?: number
    totalPositions?: number
    averageWinRate?: number
    avgMonthlyProfit?: number
    avgMonthlyTrades?: number
    mostTradedCategory?: string | null
    tradingStyle?: string | null
    riskProfile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    marketDistribution?: MarketDistributionUncheckedCreateNestedManyWithoutUserInput
    buySellData?: BuySellDataUncheckedCreateNestedOneWithoutUserInput
    tradeSizeData?: TradeSizeDataUncheckedCreateNestedOneWithoutUserInput
    priceStats?: PriceStatsUncheckedCreateNestedOneWithoutUserInput
    weeklyWinRate?: WeeklyWinRateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserAnalyticsCreateOrConnectWithoutMonthlyPerformanceInput = {
    where: UserAnalyticsWhereUniqueInput
    create: XOR<UserAnalyticsCreateWithoutMonthlyPerformanceInput, UserAnalyticsUncheckedCreateWithoutMonthlyPerformanceInput>
  }

  export type UserAnalyticsUpsertWithoutMonthlyPerformanceInput = {
    update: XOR<UserAnalyticsUpdateWithoutMonthlyPerformanceInput, UserAnalyticsUncheckedUpdateWithoutMonthlyPerformanceInput>
    create: XOR<UserAnalyticsCreateWithoutMonthlyPerformanceInput, UserAnalyticsUncheckedCreateWithoutMonthlyPerformanceInput>
    where?: UserAnalyticsWhereInput
  }

  export type UserAnalyticsUpdateToOneWithWhereWithoutMonthlyPerformanceInput = {
    where?: UserAnalyticsWhereInput
    data: XOR<UserAnalyticsUpdateWithoutMonthlyPerformanceInput, UserAnalyticsUncheckedUpdateWithoutMonthlyPerformanceInput>
  }

  export type UserAnalyticsUpdateWithoutMonthlyPerformanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    positionValue?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    totalPositions?: IntFieldUpdateOperationsInput | number
    averageWinRate?: FloatFieldUpdateOperationsInput | number
    avgMonthlyProfit?: FloatFieldUpdateOperationsInput | number
    avgMonthlyTrades?: IntFieldUpdateOperationsInput | number
    mostTradedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    tradingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    riskProfile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketDistribution?: MarketDistributionUpdateManyWithoutUserNestedInput
    buySellData?: BuySellDataUpdateOneWithoutUserNestedInput
    tradeSizeData?: TradeSizeDataUpdateOneWithoutUserNestedInput
    priceStats?: PriceStatsUpdateOneWithoutUserNestedInput
    weeklyWinRate?: WeeklyWinRateUpdateManyWithoutUserNestedInput
  }

  export type UserAnalyticsUncheckedUpdateWithoutMonthlyPerformanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    positionValue?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    totalPositions?: IntFieldUpdateOperationsInput | number
    averageWinRate?: FloatFieldUpdateOperationsInput | number
    avgMonthlyProfit?: FloatFieldUpdateOperationsInput | number
    avgMonthlyTrades?: IntFieldUpdateOperationsInput | number
    mostTradedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    tradingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    riskProfile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketDistribution?: MarketDistributionUncheckedUpdateManyWithoutUserNestedInput
    buySellData?: BuySellDataUncheckedUpdateOneWithoutUserNestedInput
    tradeSizeData?: TradeSizeDataUncheckedUpdateOneWithoutUserNestedInput
    priceStats?: PriceStatsUncheckedUpdateOneWithoutUserNestedInput
    weeklyWinRate?: WeeklyWinRateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserAnalyticsCreateWithoutWeeklyWinRateInput = {
    id?: string
    address: string
    totalVolume?: number
    totalProfit?: number
    positionValue?: number
    totalTrades?: number
    totalPositions?: number
    averageWinRate?: number
    avgMonthlyProfit?: number
    avgMonthlyTrades?: number
    mostTradedCategory?: string | null
    tradingStyle?: string | null
    riskProfile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    marketDistribution?: MarketDistributionCreateNestedManyWithoutUserInput
    buySellData?: BuySellDataCreateNestedOneWithoutUserInput
    tradeSizeData?: TradeSizeDataCreateNestedOneWithoutUserInput
    priceStats?: PriceStatsCreateNestedOneWithoutUserInput
    monthlyPerformance?: MonthlyPerformanceCreateNestedManyWithoutUserInput
  }

  export type UserAnalyticsUncheckedCreateWithoutWeeklyWinRateInput = {
    id?: string
    address: string
    totalVolume?: number
    totalProfit?: number
    positionValue?: number
    totalTrades?: number
    totalPositions?: number
    averageWinRate?: number
    avgMonthlyProfit?: number
    avgMonthlyTrades?: number
    mostTradedCategory?: string | null
    tradingStyle?: string | null
    riskProfile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    marketDistribution?: MarketDistributionUncheckedCreateNestedManyWithoutUserInput
    buySellData?: BuySellDataUncheckedCreateNestedOneWithoutUserInput
    tradeSizeData?: TradeSizeDataUncheckedCreateNestedOneWithoutUserInput
    priceStats?: PriceStatsUncheckedCreateNestedOneWithoutUserInput
    monthlyPerformance?: MonthlyPerformanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserAnalyticsCreateOrConnectWithoutWeeklyWinRateInput = {
    where: UserAnalyticsWhereUniqueInput
    create: XOR<UserAnalyticsCreateWithoutWeeklyWinRateInput, UserAnalyticsUncheckedCreateWithoutWeeklyWinRateInput>
  }

  export type UserAnalyticsUpsertWithoutWeeklyWinRateInput = {
    update: XOR<UserAnalyticsUpdateWithoutWeeklyWinRateInput, UserAnalyticsUncheckedUpdateWithoutWeeklyWinRateInput>
    create: XOR<UserAnalyticsCreateWithoutWeeklyWinRateInput, UserAnalyticsUncheckedCreateWithoutWeeklyWinRateInput>
    where?: UserAnalyticsWhereInput
  }

  export type UserAnalyticsUpdateToOneWithWhereWithoutWeeklyWinRateInput = {
    where?: UserAnalyticsWhereInput
    data: XOR<UserAnalyticsUpdateWithoutWeeklyWinRateInput, UserAnalyticsUncheckedUpdateWithoutWeeklyWinRateInput>
  }

  export type UserAnalyticsUpdateWithoutWeeklyWinRateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    positionValue?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    totalPositions?: IntFieldUpdateOperationsInput | number
    averageWinRate?: FloatFieldUpdateOperationsInput | number
    avgMonthlyProfit?: FloatFieldUpdateOperationsInput | number
    avgMonthlyTrades?: IntFieldUpdateOperationsInput | number
    mostTradedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    tradingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    riskProfile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketDistribution?: MarketDistributionUpdateManyWithoutUserNestedInput
    buySellData?: BuySellDataUpdateOneWithoutUserNestedInput
    tradeSizeData?: TradeSizeDataUpdateOneWithoutUserNestedInput
    priceStats?: PriceStatsUpdateOneWithoutUserNestedInput
    monthlyPerformance?: MonthlyPerformanceUpdateManyWithoutUserNestedInput
  }

  export type UserAnalyticsUncheckedUpdateWithoutWeeklyWinRateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    totalVolume?: FloatFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    positionValue?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    totalPositions?: IntFieldUpdateOperationsInput | number
    averageWinRate?: FloatFieldUpdateOperationsInput | number
    avgMonthlyProfit?: FloatFieldUpdateOperationsInput | number
    avgMonthlyTrades?: IntFieldUpdateOperationsInput | number
    mostTradedCategory?: NullableStringFieldUpdateOperationsInput | string | null
    tradingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    riskProfile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketDistribution?: MarketDistributionUncheckedUpdateManyWithoutUserNestedInput
    buySellData?: BuySellDataUncheckedUpdateOneWithoutUserNestedInput
    tradeSizeData?: TradeSizeDataUncheckedUpdateOneWithoutUserNestedInput
    priceStats?: PriceStatsUncheckedUpdateOneWithoutUserNestedInput
    monthlyPerformance?: MonthlyPerformanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBlogPostInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    password?: string | null
    verifyToken?: string | null
    verifyTokenExpiry?: Date | string | null
    walletAddress?: string | null
    clobApiKey?: string | null
    clobSecret?: string | null
    clobPassphrase?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken?: string | null
    telegramIntegrationId?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    telegramIntegration?: TelegramIntegrationCreateNestedOneWithoutCreatedByInput
    watchLists?: WatchListCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    rulesConversations?: RulesConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlogPostInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    password?: string | null
    verifyToken?: string | null
    verifyTokenExpiry?: Date | string | null
    walletAddress?: string | null
    clobApiKey?: string | null
    clobSecret?: string | null
    clobPassphrase?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken?: string | null
    telegramIntegrationId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    telegramIntegration?: TelegramIntegrationUncheckedCreateNestedOneWithoutCreatedByInput
    watchLists?: WatchListUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    rulesConversations?: RulesConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlogPostInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogPostInput, UserUncheckedCreateWithoutBlogPostInput>
  }

  export type UserUpsertWithoutBlogPostInput = {
    update: XOR<UserUpdateWithoutBlogPostInput, UserUncheckedUpdateWithoutBlogPostInput>
    create: XOR<UserCreateWithoutBlogPostInput, UserUncheckedCreateWithoutBlogPostInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogPostInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogPostInput, UserUncheckedUpdateWithoutBlogPostInput>
  }

  export type UserUpdateWithoutBlogPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clobApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    clobSecret?: NullableStringFieldUpdateOperationsInput | string | null
    clobPassphrase?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    telegramIntegrationId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    telegramIntegration?: TelegramIntegrationUpdateOneWithoutCreatedByNestedInput
    watchLists?: WatchListUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    rulesConversations?: RulesConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clobApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    clobSecret?: NullableStringFieldUpdateOperationsInput | string | null
    clobPassphrase?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    telegramIntegrationId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    telegramIntegration?: TelegramIntegrationUncheckedUpdateOneWithoutCreatedByNestedInput
    watchLists?: WatchListUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    rulesConversations?: RulesConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountId?: string | null
    type?: string | null
    providerId?: string | null
    providerAccountId?: string | null
    refresh_token?: string | null
    refreshToken?: string | null
    access_token?: string | null
    accessToken?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    idToken?: string | null
    session_state?: string | null
    accessTokenExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sessionToken?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken?: string | null
    token?: string | null
    expiresAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostCreateManyAuthorUserInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    date?: Date | string | null
    tagsArray?: BlogPostCreatetagsArrayInput | string[]
    thumbnail?: string | null
    featured?: boolean
    readTime?: string | null
    published?: boolean
    content: string
    tags: string
    author?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WatchListCreateManyUserInput = {
    id?: string
    marketId: string
    triggerType: string
    triggerValue?: number | null
    frequency?: string
    isActive?: boolean
    isEmailNotification?: boolean
    isTelegramNotification?: boolean
    lastNotifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateManyUserInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    isFavorite?: boolean
    updatedAt?: Date | string
  }

  export type RulesConversationCreateManyUserInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    isFavorite?: boolean
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUpdateWithoutAuthorUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagsArray?: BlogPostUpdatetagsArrayInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    readTime?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    content?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateWithoutAuthorUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagsArray?: BlogPostUpdatetagsArrayInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    readTime?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    content?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagsArray?: BlogPostUpdatetagsArrayInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    readTime?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    content?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchListUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailNotification?: BoolFieldUpdateOperationsInput | boolean
    isTelegramNotification?: BoolFieldUpdateOperationsInput | boolean
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchListUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailNotification?: BoolFieldUpdateOperationsInput | boolean
    isTelegramNotification?: BoolFieldUpdateOperationsInput | boolean
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchListUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailNotification?: BoolFieldUpdateOperationsInput | boolean
    isTelegramNotification?: BoolFieldUpdateOperationsInput | boolean
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RulesConversationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: RulesMessageUpdateManyWithoutConversationNestedInput
  }

  export type RulesConversationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: RulesMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type RulesConversationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateManyAlertInput = {
    id?: string
    userId: string
    userEmail: string
    walletAddress: string
    activityId?: string | null
    tradeType: string
    amount: string
    market: string
    notifyVia: string
    status: string
    error?: string | null
    sentAt?: Date | string
  }

  export type NotificationLogUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeType?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    notifyVia?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeType?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    notifyVia?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateManyWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeType?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    notifyVia?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    type: string
    content: string
    images?: MessageCreateimagesInput | string[]
    completed?: boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: MessageUpdateimagesInput | string[]
    completed?: BoolFieldUpdateOperationsInput | boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: MessageUpdateimagesInput | string[]
    completed?: BoolFieldUpdateOperationsInput | boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: MessageUpdateimagesInput | string[]
    completed?: BoolFieldUpdateOperationsInput | boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RulesMessageCreateManyConversationInput = {
    id?: string
    type: string
    content: string
    images?: RulesMessageCreateimagesInput | string[]
    completed?: boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RulesMessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: RulesMessageUpdateimagesInput | string[]
    completed?: BoolFieldUpdateOperationsInput | boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RulesMessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: RulesMessageUpdateimagesInput | string[]
    completed?: BoolFieldUpdateOperationsInput | boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RulesMessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: RulesMessageUpdateimagesInput | string[]
    completed?: BoolFieldUpdateOperationsInput | boolean
    marketData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketDistributionCreateManyUserInput = {
    id?: string
    market: string
    value: number
    trades: number
    volume: number
    uniqueMarkets: number
    createdAt?: Date | string
  }

  export type MonthlyPerformanceCreateManyUserInput = {
    id?: string
    month: string
    yearMonth: string
    profit: number
    volume: number
    trades: number
    createdAt?: Date | string
  }

  export type WeeklyWinRateCreateManyUserInput = {
    id?: string
    week: string
    weekDate: Date | string
    winRate: number
    totalTrades: number
    createdAt?: Date | string
  }

  export type MarketDistributionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    uniqueMarkets?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketDistributionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    uniqueMarkets?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketDistributionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    uniqueMarkets?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlyPerformanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    yearMonth?: StringFieldUpdateOperationsInput | string
    profit?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlyPerformanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    yearMonth?: StringFieldUpdateOperationsInput | string
    profit?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlyPerformanceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    yearMonth?: StringFieldUpdateOperationsInput | string
    profit?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyWinRateUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: StringFieldUpdateOperationsInput | string
    weekDate?: DateTimeFieldUpdateOperationsInput | Date | string
    winRate?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyWinRateUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: StringFieldUpdateOperationsInput | string
    weekDate?: DateTimeFieldUpdateOperationsInput | Date | string
    winRate?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyWinRateUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: StringFieldUpdateOperationsInput | string
    weekDate?: DateTimeFieldUpdateOperationsInput | Date | string
    winRate?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}